diff -Nur linux-2.6.31.old/include/linux/netfilter_bridge/ebt_ip.h linux-2.6.31.bak/include/linux/netfilter_bridge/ebt_ip.h
--- linux-2.6.31.old/include/linux/netfilter_bridge/ebt_ip.h	2011-01-26 16:28:19.000000000 +0800
+++ linux-2.6.31.bak/include/linux/netfilter_bridge/ebt_ip.h	2011-01-26 16:07:36.000000000 +0800
@@ -21,10 +21,14 @@
 #define EBT_IP_PROTO 0x08
 #define EBT_IP_SPORT 0x10
 #define EBT_IP_DPORT 0x20
+#define EBT_IP_MSIP  0x40
+#define EBT_IP_DRANGE 0x80
 #define EBT_IP_MASK (EBT_IP_SOURCE | EBT_IP_DEST | EBT_IP_TOS | EBT_IP_PROTO |\
- EBT_IP_SPORT | EBT_IP_DPORT )
+ EBT_IP_SPORT | EBT_IP_DPORT | EBT_IP_MSIP | EBT_IP_DRANGE)
 #define EBT_IP_MATCH "ip"
 
+#define SOURCE_SIZE 8
+
 /* the same values are used for the invflags */
 struct ebt_ip_info
 {
@@ -38,6 +42,8 @@
 	uint8_t  invflags;
 	uint16_t sport[2];
 	uint16_t dport[2];
+	uint32_t msip[SOURCE_SIZE];
+	uint32_t dip_range[2];
 };
 
 #endif
diff -Nur linux-2.6.31.old/include/linux/skbuff.h linux-2.6.31.bak/include/linux/skbuff.h
--- linux-2.6.31.old/include/linux/skbuff.h	2011-01-26 16:28:19.000000000 +0800
+++ linux-2.6.31.bak/include/linux/skbuff.h	2011-01-26 16:07:36.000000000 +0800
@@ -427,6 +427,10 @@
 	sk_buff_data_t		end;
 	unsigned char		*head,
 				*data;
+
+#if defined(CONFIG_DNI_PHYSICAL_INGRESS_ID) 
+	unsigned short phy_ingress_port; 
+#endif 
 	unsigned int		truesize;
 	atomic_t		users;
 #ifdef CONFIG_ATHRS_HW_NAT
diff -Nur linux-2.6.31.old/net/bridge/br.c linux-2.6.31.bak/net/bridge/br.c
--- linux-2.6.31.old/net/bridge/br.c	2011-01-26 16:43:36.000000000 +0800
+++ linux-2.6.31.bak/net/bridge/br.c	2011-01-26 16:44:45.000000000 +0800
@@ -22,8 +22,130 @@
 
 #include "br_private.h"
 
+#ifdef CONFIG_DNI_MCAST_TO_UNICAST
+#include <linux/proc_fs.h>
+struct __mac_cache mac_cache[MCAST_ENTRY_SIZE];
+int igmp_snoop_enable;
+struct __mgroup_list *mhead = NULL;
+static struct proc_dir_entry *mcast_proc_entry;
+static struct proc_dir_entry *igmp_snoop_proc_entry;
+static struct proc_dir_entry *mcast_set_proc_entry;
+extern struct proc_dir_entry proc_root;
+#endif
+
 int (*br_should_route_hook)(struct sk_buff *skb);
 
+#ifdef CONFIG_DNI_MCAST_TO_UNICAST
+unsigned long 
+a2n(char *addr)
+{
+      int i1 = 0, i2 = 0, i3 = 0, i4 = 0;
+      sscanf(addr,"%d.%d.%d.%d", &i1, &i2, &i3, &i4);
+      return (unsigned long)( (i1<<24) | (i2<<16) | (i3<<8) | (i4));
+}
+
+int mcast_read( char *page, char **start, off_t off,
+                                int count, int *eof, void *data )
+{
+      struct __mgroup_list *ptr = mhead;
+      struct __mgroup_mbr_list *mptr;
+      int i;
+      while (ptr)
+      {
+              printk("group %8x has wireless member :\n", ptr->gip);
+              mptr = ptr->member;
+              while (mptr)
+              {
+                      printk("client : %8x\n", mptr->sip);
+                      mptr = mptr->next;
+              }
+              ptr = ptr->next;
+      }
+      for (i = 0; i < MCAST_ENTRY_SIZE; i++)
+      {
+              if (mac_cache[i].valid)
+                      printk("mac cache entry %d for %x (%2x:%2x:%2x:%2x:%2x:%2x)\n",
+                      i, mac_cache[i].sip, mac_cache[i].mac[0], mac_cache[i].mac[1], mac_cache[i].mac[2],
+                      mac_cache[i].mac[3], mac_cache[i].mac[4], mac_cache[i].mac[5]);
+      }
+      return 0;
+}
+
+ssize_t mcast_write( struct file *filp, const char __user *buff,
+                                         unsigned long len, void *data )
+{
+      char line[32];
+	char *ptr, *tmp = line;
+      unsigned long ip, gip;
+      if (copy_from_user( line, buff, len ))
+              return -EFAULT;
+      line[len] = 0;
+      ptr = strsep(&tmp, " ");
+      switch(line[0])
+      {
+              case 'a':
+              case 'd':
+                      ptr = strsep(&tmp, " ");
+                      ip = a2n(ptr);
+                      gip = a2n(tmp);
+                      proc_mcast_entry(line[0], ip, gip);
+                      break;
+              default:
+                      break;
+      }
+      return len;
+}
+
+int igmp_snoop_read( char *page, char **start, off_t off,
+                                int count, int *eof, void *data )
+{
+      printk("IGMP Snoop %s.\n", (igmp_snoop_enable)?"Enable":"Disable");
+      return 0;
+}
+
+ssize_t igmp_snoop_write( struct file *filp, const char __user *buff,
+                                         unsigned long len, void *data )
+{
+      char line[4];
+      if (copy_from_user( line, buff, len ))
+	return -EFAULT;
+      igmp_snoop_enable = line[0] - '0';
+      return len;
+}
+
+void create_porc_entry(void)
+{
+      mcast_proc_entry = create_proc_entry(BR_PROC_MCAST_NAME, 0666, NULL);
+
+      if(mcast_proc_entry) {
+              mcast_proc_entry->read_proc = mcast_read;
+              mcast_proc_entry->write_proc = mcast_write;
+      }
+
+      igmp_snoop_proc_entry = create_proc_entry(BR_IGMP_SNOOP_NAME, 0666, NULL);
+
+      if(igmp_snoop_proc_entry) {
+              igmp_snoop_proc_entry->read_proc = igmp_snoop_read;
+              igmp_snoop_proc_entry->write_proc = igmp_snoop_write;
+      }
+
+      memset(mac_cache, 0, MCAST_ENTRY_SIZE* sizeof(struct __mac_cache));
+      igmp_snoop_enable = 0;
+
+      mcast_set_proc_entry = create_proc_entry(BR_MCAST_SET_NAME, 0666, NULL);
+
+      if (mcast_set_proc_entry) {
+              mcast_set_proc_entry->read_proc = mcast_set_read;
+              mcast_set_proc_entry->write_proc = mcast_set_write;
+      }
+
+}
+
+void delete_porc_entry(void)
+{
+      remove_proc_entry(BR_PROC_MCAST_NAME, &proc_root);
+}
+#endif
 static const struct stp_proto br_stp_proto = {
 	.rcv	= br_stp_rcv,
 };
@@ -102,6 +224,10 @@
 
 	br_handle_frame_hook = NULL;
 	br_fdb_fini();
+
+#ifdef CONFIG_DNI_MCAST_TO_UNICAST
+      delete_porc_entry();
+#endif
 }
 
 EXPORT_SYMBOL(br_should_route_hook);
diff -Nur linux-2.6.31.old/net/bridge/br_forward.bak linux-2.6.31.bak/net/bridge/br_forward.bak
--- linux-2.6.31.old/net/bridge/br_forward.bak	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.31.bak/net/bridge/br_forward.bak	2011-01-27 10:18:49.000000000 +0800
@@ -0,0 +1,563 @@
+/*
+ *	Forwarding decision
+ *	Linux ethernet bridge
+ *
+ *	Authors:
+ *	Lennert Buytenhek		<buytenh@gnu.org>
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_vlan.h>
+#include <linux/netfilter_bridge.h>
+#include "br_private.h"
+
+#ifdef CONFIG_DNI_MCAST_TO_UNICAST
+#include <linux/ip.h>
+static inline struct __mac_cache *
+find_mac_cache(unsigned long sip, unsigned long gip)
+{
+      int i;
+      for (i = 0; i < MCAST_ENTRY_SIZE; i++)
+      {
+              if (mac_cache[i].valid)
+              {
+                      if (mac_cache[i].sip == sip)
+                              return &mac_cache[i];
+              }
+      }
+      return NULL;
+}
+
+static inline struct __mgroup_mbr_list *
+mbr_find(struct __mgroup_list *mg, unsigned long sip)
+{
+      struct __mgroup_mbr_list *ptr = mg->member;
+
+      while (ptr)
+      {
+              if (ptr->sip == sip)
+                      break;
+              ptr = ptr->next;
+      }
+
+      return ptr;
+}
+
+static inline struct __mgroup_mbr_list *
+mbr_add(struct __mac_cache *cache)
+{
+      struct __mgroup_mbr_list *ptr = NULL;
+
+      ptr = kmalloc( sizeof(struct __mgroup_mbr_list), GFP_ATOMIC);
+      if (likely(ptr))
+      {
+              memcpy(ptr->mac, cache->mac, 6);
+              ptr->sip = cache->sip;
+              ptr->dev = cache->dev;
+              ptr->next = NULL;
+      }
+      return ptr;
+}
+
+static inline void
+mbr_del(struct __mgroup_list *mg, unsigned long sip)
+{
+      struct __mgroup_mbr_list *ptr = mg->member, *preptr = NULL;
+
+      while (ptr)
+      {
+              if (ptr->sip == sip)
+                      break;
+              preptr = ptr;
+              ptr = ptr->next;
+      }
+      if (preptr)
+              preptr->next = ptr->next;
+      else if (ptr->next)
+              mg->member = ptr->next;
+      else
+              mg->member = NULL;
+
+      kfree(ptr);
+      return;
+}
+
+static inline struct __mgroup_list *
+mgroup_find(unsigned long gip)
+{
+      struct __mgroup_list *ptr = mhead;
+      while (ptr)
+      {
+              if (ptr->gip == gip)
+                      break;
+              ptr = ptr->next;
+      }
+
+      return ptr;
+}
+
+static inline struct __mgroup_list *
+mgroup_add(unsigned long sip, unsigned long gip)
+{
+      struct __mgroup_list *ptr = mhead, *tmp;
+      struct __mac_cache *cache = NULL;
+      struct __mgroup_mbr_list *msource = NULL;
+
+      while (ptr)
+              ptr = ptr->next;
+      cache = find_mac_cache(sip, gip);
+      if (cache)
+              ptr = kmalloc( sizeof(struct __mgroup_list), GFP_ATOMIC);
+
+      if (likely(ptr))
+      {
+              ptr->gip = gip;
+              msource = mbr_add(cache);
+              if (unlikely(!msource))
+              {
+                      kfree(ptr);
+                      return NULL;
+              }
+              ptr->member = msource;
+              ptr->next = NULL;
+
+              if (mhead)
+                      INSERT_TO_TAIL(mhead, ptr, tmp);
+              else
+                      mhead = ptr;
+              cache->valid = 0;
+      }
+      else
+              ptr = NULL;
+      return ptr;
+}
+
+static inline void
+mgroup_del(unsigned long gip)
+{
+      struct __mgroup_list *ptr = mhead, *preptr = NULL;
+
+      while (ptr)
+      {
+              if (ptr->gip == gip)
+                      break;
+              preptr = ptr;
+              ptr = ptr->next;
+      }
+      if (preptr)
+              preptr->next = ptr->next;
+      else if (ptr->next)
+              mhead = ptr->next;
+      else
+              mhead = NULL;
+
+      kfree(ptr);
+      return ;
+}
+
+void
+proc_mcast_entry(char cmd, unsigned long sip , unsigned long gip)
+{
+      struct __mgroup_list *ptr = NULL;
+      struct __mgroup_mbr_list *mptr = NULL, *tmp;
+      struct __mac_cache * cache = NULL;
+      if (cmd == 'a')
+      {
+              ptr = mgroup_find(gip);
+              if (ptr)
+              {
+                      mptr = mbr_find(ptr, sip);
+                      if (!mptr)
+                      {
+                              cache = find_mac_cache(sip, gip);
+                              if (cache)
+                              {
+                                      mptr = mbr_add(cache);
+                                      if (mptr)
+                                              INSERT_TO_TAIL(ptr->member, mptr, tmp);
+                              }
+                      }
+              }
+              else
+                      ptr = mgroup_add(sip, gip);
+      }
+      else
+      {
+              ptr = mgroup_find(gip);
+              if (ptr)
+              {
+                      mptr = mbr_find(ptr, sip);
+                      if (mptr)
+                      {
+                              mbr_del(ptr, sip);
+                              if (!ptr->member)
+                                      mgroup_del(gip);
+                      }
+              }
+      }
+      return;
+}
+
+#define LOCAL_CONTROL_START 0xE0000000
+#define LOCAL_CONTROL_END   0XE00000FF
+#define SSDP    0XEFFFFFFA
+
+static inline int 
+not_ctrl_group(unsigned long ip)
+{
+      if ( (ip >= LOCAL_CONTROL_START) &&( ip <= LOCAL_CONTROL_END))
+              return 0;
+      else if (ip == SSDP)
+              return 0;
+      return 1;
+}
+
+static inline struct sk_buff *
+modifyMcast2Ucast(struct sk_buff *skb,unsigned char *mac)
+{
+      struct sk_buff *mSkb;
+
+      mSkb=skb_copy(skb,GFP_ATOMIC);
+      memcpy(ethernet->h_dest, mac, 6);
+      struct ethhdr *ethernet = (struct ethhdr *)mSkb->mac_header;
+
+      return mSkb;
+}
+
+int mcast_set_read( char *page, char **start, off_t off,
+                                int count, int *eof, void *data )
+{
+      struct __mgroup_list *ptr = mhead;
+      struct __mgroup_mbr_list *mptr;
+      int i;
+      while (ptr)
+      {
+              mptr = ptr->member;
+              while (mptr)
+              {
+                      printk("client : [%8x] join group [%8x]\n", mptr->sip, ptr->gip);
+                      printk("mode : %s\n", (mptr->set.mode)?"Include":"Exclude");
+                      for (i = 0; i < mptr->set.num; i++)
+                              printk("source%d : %8x\n", i, mptr->set.sip[i]);
+                      mptr = mptr->next;
+              }
+              ptr = ptr->next;
+      }
+
+      return 0;
+}
+
+ssize_t mcast_set_write( struct file *filp, const char __user *buff,
+                                         unsigned long len, void *data )
+{
+      char line[256], *p, *e, i;
+      struct __mgroup_list *ptr = NULL;
+      struct __mgroup_mbr_list *mptr = NULL;
+      unsigned long sip, gip;
+      struct source_set set;
+      if (copy_from_user( line, buff, len ))
+              return -EFAULT;
+      line[len] = 0;
+      // ip gip mode num source1 source2
+      p = line;
+      e = strsep(&p, " ");
+      if (!e)
+              return len;
+      sip = a2n(e);
+
+      e = strsep(&p, " ");
+      if (!e)
+              return len;
+      gip = a2n(e);
+
+      memset(&set, 0, sizeof(set));
+      e = strsep(&p, " ");
+      if (!e)
+              return len;
+      set.mode = *e - '0';
+
+      e = strsep(&p, " ");
+      if (!e)
+              return len;
+      set.num = *e - '0';
+
+      for (i = 0; i < set.num; i++)
+      {
+              e = strsep(&p, " ");
+              if (!e)
+                      return len;
+              set.sip[i] = a2n(e);
+      }
+
+      ptr = mgroup_find(gip);
+      if (ptr)
+      {
+              mptr = mbr_find(ptr, sip);
+              if (mptr)
+                      memcpy(&mptr->set, &set, sizeof(set));
+
+      }
+      return len;
+}
+
+static inline int
+include_check(unsigned long sip, struct source_set *set)
+{
+      int i;
+      for (i = 0; i < set->num; i++)
+              if (sip == set->sip[i])
+                      return 1;
+      return 0;
+}
+
+static inline int
+exclude_check(unsigned long sip, struct source_set *set)
+{
+      int i;
+      for (i = 0; i < set->num; i++)
+              if (sip == set->sip[i])
+                      return 0;
+      return 1;
+}
+
+static inline int
+pass_check(unsigned long sip, struct __mgroup_mbr_list *mbr)
+{
+      if (mbr->set.mode)
+              return include_check(sip, &mbr->set);
+      else
+              return exclude_check(sip, &mbr->set);
+}
+#endif
+
+/* Don't forward packets to originating port or forwarding diasabled */
+static inline int should_deliver(const struct net_bridge_port *p,
+				 const struct sk_buff *skb)
+{
+#ifdef CONFIG_DNI_MULTI_LAN_SUPPORT
+      // if skb is from eth1/eth2/eth3/eth4 and destination is eth1/eth2/eth3/eth4, to drop skb
+      if (skb->dev->name[0] == 'e' && 
+              (skb->dev->name[0] == p->dev->name[0]))
+              return 0;
+#endif
+	return (skb->dev != p->dev && p->state == BR_STATE_FORWARDING);
+}
+
+static inline unsigned packet_length(const struct sk_buff *skb)
+{
+	return skb->len - (skb->protocol == htons(ETH_P_8021Q) ? VLAN_HLEN : 0);
+}
+
+int br_dev_queue_push_xmit(struct sk_buff *skb)
+{
+	/* drop mtu oversized packets except gso */
+	if (packet_length(skb) > skb->dev->mtu && !skb_is_gso(skb))
+		kfree_skb(skb);
+	else {
+		/* ip_refrag calls ip_fragment, doesn't copy the MAC header. */
+		if (nf_bridge_maybe_copy_header(skb))
+			kfree_skb(skb);
+		else {
+			skb_push(skb, ETH_HLEN);
+
+			dev_queue_xmit(skb);
+		}
+	}
+
+	return 0;
+}
+
+int br_forward_finish(struct sk_buff *skb)
+{
+	return NF_HOOK(PF_BRIDGE, NF_BR_POST_ROUTING, skb, NULL, skb->dev,
+		       br_dev_queue_push_xmit);
+
+}
+
+static void __br_deliver(const struct net_bridge_port *to, struct sk_buff *skb)
+{
+	skb->dev = to->dev;
+	NF_HOOK(PF_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,
+			br_forward_finish);
+}
+
+static void __br_forward(const struct net_bridge_port *to, struct sk_buff *skb)
+{
+	struct net_device *indev;
+
+	if (skb_warn_if_lro(skb)) {
+		kfree_skb(skb);
+		return;
+	}
+
+	indev = skb->dev;
+	skb->dev = to->dev;
+	skb_forward_csum(skb);
+
+	NF_HOOK(PF_BRIDGE, NF_BR_FORWARD, skb, indev, skb->dev,
+			br_forward_finish);
+}
+
+/* called with rcu_read_lock */
+void br_deliver(const struct net_bridge_port *to, struct sk_buff *skb)
+{
+	if (should_deliver(to, skb)) {
+		__br_deliver(to, skb);
+		return;
+	}
+
+	kfree_skb(skb);
+}
+
+/* called with rcu_read_lock */
+void br_forward(const struct net_bridge_port *to, struct sk_buff *skb)
+{
+	if (should_deliver(to, skb)) {
+		__br_forward(to, skb);
+		return;
+	}
+
+	kfree_skb(skb);
+}
+
+/* called under bridge lock */
+static void br_flood(struct net_bridge *br, struct sk_buff *skb,
+	void (*__packet_hook)(const struct net_bridge_port *p,
+			      struct sk_buff *skb))
+{
+	struct net_bridge_port *p;
+	struct net_bridge_port *prev;
+	struct ethhdr *ethernet = (struct ethhdr *)skb->mac_header;
+	prev = NULL;
+
+	list_for_each_entry_rcu(p, &br->port_list, list) {
+		if (should_deliver(p, skb)) {
+#ifdef CONFIG_DNI_MCAST_TO_UNICAST
+                      if (prev)
+                      {
+                              struct sk_buff *skb2;
+
+                              if (igmp_snoop_enable && prev->dev->name[0] == 'a')
+                              {
+				      unsigned char *dest = ethernet->h_dest;
+                                      struct iphdr *iph = (struct iphdr *)skb->network_header;
+                                      if ( MULTICAST_MAC(dest) && not_ctrl_group(iph->daddr))
+                                      {
+                                              struct __mgroup_list *mg = NULL;
+                                              struct __mgroup_mbr_list *mbr;
+                                              mg = mgroup_find(iph->daddr);
+                                              if (mg)
+                                              {
+                                                      mbr = mg->member;
+                                                      while (mbr)
+                                                      {
+                                                              if ((mbr->dev == prev->dev) &&
+                                                                      pass_check(iph->saddr, mbr))
+                                                              {
+                                                                      if((skb2=modifyMcast2Ucast(skb, mbr->mac)) == NULL)
+                                                                      {
+                                                                              br->dev->stats.tx_dropped++;
+                                                                              kfree_skb(skb);
+                                                                              return;
+                                                                      }
+                                                                      __packet_hook(prev, skb2);
+                                                              }
+                                                              mbr = mbr->next;
+                                                      }
+                                              }
+
+                                              prev = p;
+                                              continue;
+                                      }
+                              }
+
+                              if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) {
+                                      br->dev->stats.tx_dropped++;
+                                      kfree_skb(skb);
+                                      return;
+                              }
+
+                              __packet_hook(prev, skb2);
+
+                      }
+                      prev = p;
+#else
+			if (prev != NULL) {
+				struct sk_buff *skb2;
+
+				if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) {
+					br->dev->stats.tx_dropped++;
+					kfree_skb(skb);
+					return;
+				}
+
+				__packet_hook(prev, skb2);
+			}
+
+			prev = p;
+		}
+	}
+#endif
+	if (prev != NULL) {
+#ifdef CONFIG_DNI_MCAST_TO_UNICAST
+              struct sk_buff *skb2;
+
+              if (prev->dev->name[0] == 'a')
+              {
+                      unsigned char *dest = ethernet->h_dest;
+                      struct iphdr *iph = (struct iphdr *)skb->network_header;
+                      if ( MULTICAST_MAC(dest) && not_ctrl_group(iph->daddr))
+                      {
+                              struct __mgroup_list *mg = NULL;
+                              struct __mgroup_mbr_list *mbr;
+                              mg = mgroup_find(iph->daddr);
+                              if (mg)
+                              {
+                                      mbr = mg->member;
+                                      while (mbr)
+                                      {
+                                              if ((mbr->dev == prev->dev)&&
+                                                      pass_check(iph->saddr, mbr))
+                                              {
+                                                      if((skb2=modifyMcast2Ucast(skb, mbr->mac)) == NULL)
+                                                      {
+                                                              br->dev->stats.tx_dropped++;
+                                                              kfree_skb(skb);
+                                                              return;
+                                                      }
+                                                      __packet_hook(prev, skb2);
+                                              }
+                                              mbr = mbr->next;
+                                      }
+                                      kfree_skb(skb);
+                                      return;
+                              }
+                      }
+              }
+#endif
+		__packet_hook(prev, skb);
+		return;
+	}
+
+	kfree_skb(skb);
+}
+
+
+/* called with rcu_read_lock */
+void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb)
+{
+	br_flood(br, skb, __br_deliver);
+}
+
+/* called under bridge lock */
+void br_flood_forward(struct net_bridge *br, struct sk_buff *skb)
+{
+	br_flood(br, skb, __br_forward);
+}
diff -Nur linux-2.6.31.old/net/bridge/br_forward.c linux-2.6.31.bak/net/bridge/br_forward.c
--- linux-2.6.31.old/net/bridge/br_forward.c	2011-01-26 16:43:36.000000000 +0800
+++ linux-2.6.31.bak/net/bridge/br_forward.c	2011-01-27 10:20:22.000000000 +0800
@@ -18,10 +18,338 @@
 #include <linux/netfilter_bridge.h>
 #include "br_private.h"
 
+#ifdef CONFIG_DNI_MCAST_TO_UNICAST
+#include <linux/ip.h>
+static inline struct __mac_cache *
+find_mac_cache(unsigned long sip, unsigned long gip)
+{
+      int i;
+      for (i = 0; i < MCAST_ENTRY_SIZE; i++)
+      {
+              if (mac_cache[i].valid)
+              {
+                      if (mac_cache[i].sip == sip)
+                              return &mac_cache[i];
+              }
+      }
+      return NULL;
+}
+
+static inline struct __mgroup_mbr_list *
+mbr_find(struct __mgroup_list *mg, unsigned long sip)
+{
+      struct __mgroup_mbr_list *ptr = mg->member;
+
+      while (ptr)
+      {
+              if (ptr->sip == sip)
+                      break;
+              ptr = ptr->next;
+      }
+
+      return ptr;
+}
+
+static inline struct __mgroup_mbr_list *
+mbr_add(struct __mac_cache *cache)
+{
+      struct __mgroup_mbr_list *ptr = NULL;
+
+      ptr = kmalloc( sizeof(struct __mgroup_mbr_list), GFP_ATOMIC);
+      if (likely(ptr))
+      {
+              memcpy(ptr->mac, cache->mac, 6);
+              ptr->sip = cache->sip;
+              ptr->dev = cache->dev;
+              ptr->next = NULL;
+      }
+      return ptr;
+}
+
+static inline void
+mbr_del(struct __mgroup_list *mg, unsigned long sip)
+{
+      struct __mgroup_mbr_list *ptr = mg->member, *preptr = NULL;
+
+      while (ptr)
+      {
+              if (ptr->sip == sip)
+                      break;
+              preptr = ptr;
+              ptr = ptr->next;
+      }
+      if (preptr)
+              preptr->next = ptr->next;
+      else if (ptr->next)
+              mg->member = ptr->next;
+      else
+              mg->member = NULL;
+
+      kfree(ptr);
+      return;
+}
+
+static inline struct __mgroup_list *
+mgroup_find(unsigned long gip)
+{
+      struct __mgroup_list *ptr = mhead;
+      while (ptr)
+      {
+              if (ptr->gip == gip)
+                      break;
+              ptr = ptr->next;
+      }
+
+      return ptr;
+}
+
+static inline struct __mgroup_list *
+mgroup_add(unsigned long sip, unsigned long gip)
+{
+      struct __mgroup_list *ptr = mhead, *tmp;
+      struct __mac_cache *cache = NULL;
+      struct __mgroup_mbr_list *msource = NULL;
+
+      while (ptr)
+              ptr = ptr->next;
+      cache = find_mac_cache(sip, gip);
+      if (cache)
+              ptr = kmalloc( sizeof(struct __mgroup_list), GFP_ATOMIC);
+
+      if (likely(ptr))
+      {
+              ptr->gip = gip;
+              msource = mbr_add(cache);
+              if (unlikely(!msource))
+              {
+                      kfree(ptr);
+                      return NULL;
+              }
+              ptr->member = msource;
+              ptr->next = NULL;
+
+              if (mhead)
+                      INSERT_TO_TAIL(mhead, ptr, tmp);
+              else
+                      mhead = ptr;
+              cache->valid = 0;
+      }
+      else
+              ptr = NULL;
+      return ptr;
+}
+
+static inline void
+mgroup_del(unsigned long gip)
+{
+      struct __mgroup_list *ptr = mhead, *preptr = NULL;
+
+      while (ptr)
+      {
+              if (ptr->gip == gip)
+                      break;
+              preptr = ptr;
+              ptr = ptr->next;
+      }
+      if (preptr)
+              preptr->next = ptr->next;
+      else if (ptr->next)
+              mhead = ptr->next;
+      else
+              mhead = NULL;
+
+      kfree(ptr);
+      return ;
+}
+
+void
+proc_mcast_entry(char cmd, unsigned long sip , unsigned long gip)
+{
+      struct __mgroup_list *ptr = NULL;
+      struct __mgroup_mbr_list *mptr = NULL, *tmp;
+      struct __mac_cache * cache = NULL;
+      if (cmd == 'a')
+      {
+              ptr = mgroup_find(gip);
+              if (ptr)
+              {
+                      mptr = mbr_find(ptr, sip);
+                      if (!mptr)
+                      {
+                              cache = find_mac_cache(sip, gip);
+                              if (cache)
+                              {
+                                      mptr = mbr_add(cache);
+                                      if (mptr)
+                                              INSERT_TO_TAIL(ptr->member, mptr, tmp);
+                              }
+                      }
+              }
+              else
+                      ptr = mgroup_add(sip, gip);
+      }
+      else
+      {
+              ptr = mgroup_find(gip);
+              if (ptr)
+              {
+                      mptr = mbr_find(ptr, sip);
+                      if (mptr)
+                      {
+                              mbr_del(ptr, sip);
+                              if (!ptr->member)
+                                      mgroup_del(gip);
+                      }
+              }
+      }
+      return;
+}
+
+#define LOCAL_CONTROL_START 0xE0000000
+#define LOCAL_CONTROL_END   0XE00000FF
+#define SSDP    0XEFFFFFFA
+
+static inline int 
+not_ctrl_group(unsigned long ip)
+{
+      if ( (ip >= LOCAL_CONTROL_START) &&( ip <= LOCAL_CONTROL_END))
+              return 0;
+      else if (ip == SSDP)
+              return 0;
+      return 1;
+}
+
+static inline struct sk_buff *
+modifyMcast2Ucast(struct sk_buff *skb,unsigned char *mac)
+{
+      struct sk_buff *mSkb;
+
+      mSkb=skb_copy(skb,GFP_ATOMIC);
+      struct ethhdr *ethernet = (struct ethhdr *)mSkb->mac_header;
+      memcpy(ethernet->h_dest, mac, 6);
+
+      return mSkb;
+}
+
+int mcast_set_read( char *page, char **start, off_t off,
+                                int count, int *eof, void *data )
+{
+      struct __mgroup_list *ptr = mhead;
+      struct __mgroup_mbr_list *mptr;
+      int i;
+      while (ptr)
+      {
+              mptr = ptr->member;
+              while (mptr)
+              {
+                      printk("client : [%8x] join group [%8x]\n", mptr->sip, ptr->gip);
+                      printk("mode : %s\n", (mptr->set.mode)?"Include":"Exclude");
+                      for (i = 0; i < mptr->set.num; i++)
+                              printk("source%d : %8x\n", i, mptr->set.sip[i]);
+                      mptr = mptr->next;
+              }
+              ptr = ptr->next;
+      }
+
+      return 0;
+}
+
+ssize_t mcast_set_write( struct file *filp, const char __user *buff,
+                                         unsigned long len, void *data )
+{
+      char line[256], *p, *e, i;
+      struct __mgroup_list *ptr = NULL;
+      struct __mgroup_mbr_list *mptr = NULL;
+      unsigned long sip, gip;
+      struct source_set set;
+      if (copy_from_user( line, buff, len ))
+              return -EFAULT;
+      line[len] = 0;
+      // ip gip mode num source1 source2
+      p = line;
+      e = strsep(&p, " ");
+      if (!e)
+              return len;
+      sip = a2n(e);
+
+      e = strsep(&p, " ");
+      if (!e)
+              return len;
+      gip = a2n(e);
+
+      memset(&set, 0, sizeof(set));
+      e = strsep(&p, " ");
+      if (!e)
+              return len;
+      set.mode = *e - '0';
+
+      e = strsep(&p, " ");
+      if (!e)
+              return len;
+      set.num = *e - '0';
+
+      for (i = 0; i < set.num; i++)
+      {
+              e = strsep(&p, " ");
+              if (!e)
+                      return len;
+              set.sip[i] = a2n(e);
+      }
+
+      ptr = mgroup_find(gip);
+      if (ptr)
+      {
+              mptr = mbr_find(ptr, sip);
+              if (mptr)
+                      memcpy(&mptr->set, &set, sizeof(set));
+
+      }
+      return len;
+}
+
+static inline int
+include_check(unsigned long sip, struct source_set *set)
+{
+      int i;
+      for (i = 0; i < set->num; i++)
+              if (sip == set->sip[i])
+                      return 1;
+      return 0;
+}
+
+static inline int
+exclude_check(unsigned long sip, struct source_set *set)
+{
+      int i;
+      for (i = 0; i < set->num; i++)
+              if (sip == set->sip[i])
+                      return 0;
+      return 1;
+}
+
+static inline int
+pass_check(unsigned long sip, struct __mgroup_mbr_list *mbr)
+{
+      if (mbr->set.mode)
+              return include_check(sip, &mbr->set);
+      else
+              return exclude_check(sip, &mbr->set);
+}
+#endif
+
 /* Don't forward packets to originating port or forwarding diasabled */
 static inline int should_deliver(const struct net_bridge_port *p,
 				 const struct sk_buff *skb)
 {
+#ifdef CONFIG_DNI_MULTI_LAN_SUPPORT
+      // if skb is from/to eth1/ath1/ath0, to deliver skb, do nothing for not going into else if.
+      if(skb->dev->name[3] == '1' || p->dev->name[3] == '1') {
+      }
+      // if skb is from eth1/eth2/eth3/eth4 and destination is eth1/eth2/eth3/eth4, to drop skb
+      else if (skb->dev->name[0] == 'e' &&
+                  (skb->dev->name[0] == p->dev->name[0]))
+              return 0;
+#endif
 	return (skb->dev != p->dev && p->state == BR_STATE_FORWARDING);
 }
 
@@ -109,11 +437,61 @@
 {
 	struct net_bridge_port *p;
 	struct net_bridge_port *prev;
-
+	struct ethhdr *ethernet = (struct ethhdr *)skb->mac_header;
 	prev = NULL;
 
 	list_for_each_entry_rcu(p, &br->port_list, list) {
 		if (should_deliver(p, skb)) {
+#ifdef CONFIG_DNI_MCAST_TO_UNICAST
+                      if (prev)
+                      {
+                              struct sk_buff *skb2;
+
+                              if (igmp_snoop_enable && prev->dev->name[0] == 'a')
+                              {
+				      unsigned char *dest = ethernet->h_dest;
+                                      struct iphdr *iph = (struct iphdr *)skb->network_header;
+                                      if ( MULTICAST_MAC(dest) && not_ctrl_group(iph->daddr))
+                                      {
+                                              struct __mgroup_list *mg = NULL;
+                                              struct __mgroup_mbr_list *mbr;
+                                              mg = mgroup_find(iph->daddr);
+                                              if (mg)
+                                              {
+                                                      mbr = mg->member;
+                                                      while (mbr)
+                                                      {
+                                                              if ((mbr->dev == prev->dev) &&
+                                                                      pass_check(iph->saddr, mbr))
+                                                              {
+                                                                      if((skb2=modifyMcast2Ucast(skb, mbr->mac)) == NULL)
+                                                                      {
+                                                                              br->dev->stats.tx_dropped++;
+                                                                              kfree_skb(skb);
+                                                                              return;
+                                                                      }
+                                                                      __packet_hook(prev, skb2);
+                                                              }
+                                                              mbr = mbr->next;
+                                                      }
+                                              }
+
+                                              prev = p;
+                                              continue;
+                                      }
+                              }
+
+                              if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) {
+                                      br->dev->stats.tx_dropped++;
+                                      kfree_skb(skb);
+                                      return;
+                              }
+
+                              __packet_hook(prev, skb2);
+
+                      }
+                      prev = p;
+#else
 			if (prev != NULL) {
 				struct sk_buff *skb2;
 
@@ -127,10 +505,46 @@
 			}
 
 			prev = p;
+#endif
 		}
 	}
-
 	if (prev != NULL) {
+#ifdef CONFIG_DNI_MCAST_TO_UNICAST
+              struct sk_buff *skb2;
+
+              if (prev->dev->name[0] == 'a')
+              {
+                      unsigned char *dest = ethernet->h_dest;
+                      struct iphdr *iph = (struct iphdr *)skb->network_header;
+                      if ( MULTICAST_MAC(dest) && not_ctrl_group(iph->daddr))
+                      {
+                              struct __mgroup_list *mg = NULL;
+                              struct __mgroup_mbr_list *mbr;
+                              mg = mgroup_find(iph->daddr);
+                              if (mg)
+                              {
+                                      mbr = mg->member;
+                                      while (mbr)
+                                      {
+                                              if ((mbr->dev == prev->dev)&&
+                                                      pass_check(iph->saddr, mbr))
+                                              {
+                                                      if((skb2=modifyMcast2Ucast(skb, mbr->mac)) == NULL)
+                                                      {
+                                                              br->dev->stats.tx_dropped++;
+                                                              kfree_skb(skb);
+                                                              return;
+                                                      }
+                                                      __packet_hook(prev, skb2);
+                                              }
+                                              mbr = mbr->next;
+                                      }
+                                      kfree_skb(skb);
+                                      return;
+                              }
+                      }
+              }
+#endif
 		__packet_hook(prev, skb);
 		return;
 	}
diff -Nur linux-2.6.31.old/net/bridge/br_input.c linux-2.6.31.bak/net/bridge/br_input.c
--- linux-2.6.31.old/net/bridge/br_input.c	2011-01-26 16:43:36.000000000 +0800
+++ linux-2.6.31.bak/net/bridge/br_input.c	2011-01-27 10:51:02.000000000 +0800
@@ -16,13 +16,81 @@
 #include <linux/etherdevice.h>
 #include <linux/netfilter_bridge.h>
 #include "br_private.h"
+#ifdef CONFIG_DNI_MCAST_TO_UNICAST
+#include <linux/ip.h>
+#include <linux/igmp.h>
 
+static inline void 
+add_mac_cache(struct sk_buff *skb)
+{
+      unsigned char i, num = 0xff;
+      unsigned char *src, check = 1;
+      struct iphdr *iph;
+      struct ethhdr *ethernet=(struct ethhdr *)skb->mac_header;
+
+      iph = (struct iphdr *)skb->network_header;
+      src = ethernet->h_source;
+
+      for (i = 0; i < MCAST_ENTRY_SIZE; i++)
+      {
+              if (mac_cache[i].valid)
+                      if ((++mac_cache[i].count) == MAX_CLEAN_COUNT)
+                              mac_cache[i].valid = 0;
+      }
+
+      for (i = 0; i < MCAST_ENTRY_SIZE; i++)
+      {
+              if (mac_cache[i].valid)
+              {
+                      if (mac_cache[i].sip==iph->saddr)
+                      {
+                              num = i;
+                              break;
+                      }
+              }
+              else if (check)
+              {
+                      num=i;
+                      check = 0;
+              }
+      }
+
+      if (num < MCAST_ENTRY_SIZE)
+      {
+              mac_cache[num].valid = mac_cache[num].count = 1;
+              memcpy(mac_cache[num].mac, src, 6);
+              mac_cache[num].sip = iph->saddr;
+              mac_cache[num].dev = skb->dev;
+      }
+}
+
+#endif
 /* Bridge group multicast address 802.1d (pg 51). */
 const u8 br_group_address[ETH_ALEN] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x00 };
 
 static void br_pass_frame_up(struct net_bridge *br, struct sk_buff *skb)
 {
 	struct net_device *indev, *brdev = br->dev;
+#ifdef CONFIG_DNI_MCAST_TO_UNICAST
+      unsigned char *dest;
+      struct iphdr *iph;
+      unsigned char proto=0;
+      struct ethhdr *ethernet=(struct ethhdr *)skb->mac_header;
+
+      // if skb come from wireless interface, ex. ath0, ath1, ath2...
+      if (skb->dev->name[0] == 'a')
+      {
+              iph = (struct iphdr *)skb->network_header;
+              proto =  iph->protocol;
+              dest = ethernet->h_dest;
+              if ( igmp_snoop_enable && MULTICAST_MAC(dest) 
+                       && (ethernet->h_proto == ETH_P_IP))
+              {
+                      if (proto == IPPROTO_IGMP)
+                              add_mac_cache(skb);
+              }
+      }
+#endif
 
 	brdev->stats.rx_packets++;
 	brdev->stats.rx_bytes += skb->len;
@@ -61,7 +129,11 @@
 
 	dst = NULL;
 
-	if (is_multicast_ether_addr(dest)) {
+	if (is_multicast_ether_addr(dest) 
+#ifdef CONFIG_DNI_IPV6_PASSTHROUGH
+		|| (skb->protocol == __constant_htons(ETH_P_IPV6))
+#endif
+	) {
 		br->dev->stats.multicast++;
 		skb2 = skb;
 	} else if ((dst = __br_fdb_get(br, dest)) && dst->is_local) {
@@ -79,8 +151,9 @@
 	if (skb) {
 		if (dst)
 			br_forward(dst->dst, skb);
-		else
-			br_flood_forward(br, skb);
+		else {
+			br_flood_forward(br, skb);			
+		}
 	}
 
 out:
diff -Nur linux-2.6.31.old/net/bridge/br_private.h linux-2.6.31.bak/net/bridge/br_private.h
--- linux-2.6.31.old/net/bridge/br_private.h	2011-01-26 16:43:36.000000000 +0800
+++ linux-2.6.31.bak/net/bridge/br_private.h	2011-01-26 16:44:45.000000000 +0800
@@ -263,5 +263,64 @@
 #define br_sysfs_addbr(dev)	(0)
 #define br_sysfs_delbr(dev)	do { } while(0)
 #endif /* CONFIG_SYSFS */
+#ifdef CONFIG_DNI_MCAST_TO_UNICAST
+#define MCAST_ENTRY_SIZE 10
+#define MAX_CLEAN_COUNT 4
+#define MAX_SOURCE_SIZE 8
+#define BR_PROC_MCAST_NAME "mcast"
+#define BR_IGMP_SNOOP_NAME "igmpsnoop"
+#define BR_MCAST_SET_NAME "mcast_set"
+#define MULTICAST_MAC(mac)       ((mac[0]==0x01)&&(mac[1]==0x00)&&(mac[2]==0x5e))
+#define INSERT_TO_TAIL(X, Y, Z)  do{ \
+      Z=X; \
+      while (Z->next)  \
+              Z = Z->next; \
+      Z->next = Y; \
+      } while(0)
+
+struct __mac_cache
+{
+      unsigned char valid;
+      unsigned char count;
+      unsigned char mac[6];
+      unsigned long sip;
+      struct net_device *dev;
+};
+
+struct source_set
+{
+      unsigned short num;
+      unsigned short mode;
+      unsigned long sip[MAX_SOURCE_SIZE];
+};
+
+struct __mgroup_mbr_list
+{
+      unsigned char mac[6];
+      char noused[2]; // just for aligned
+      unsigned long sip;
+      struct source_set set;
+      struct net_device *dev;
+      struct __mgroup_mbr_list *next;
+};
+
+struct __mgroup_list
+{
+      unsigned long gip;
+      struct __mgroup_mbr_list *member;
+      struct __mgroup_list *next;
+};
+
+extern struct __mac_cache mac_cache[MCAST_ENTRY_SIZE];
+extern int igmp_snoop_enable;
+extern struct __mgroup_list *mhead;
+
+void proc_mcast_entry(char cmd, unsigned long ip ,unsigned long gip);
+int mcast_set_read( char *page, char **start, off_t off,
+                                int count, int *eof, void *data );
+ssize_t mcast_set_write( struct file *filp, const char __user *buff,
+                                         unsigned long len, void *data );
+unsigned long a2n(char *addr);
+#endif
 
 #endif
diff -Nur linux-2.6.31.old/net/bridge/Kconfig linux-2.6.31.bak/net/bridge/Kconfig
--- linux-2.6.31.old/net/bridge/Kconfig	2011-01-26 16:43:36.000000000 +0800
+++ linux-2.6.31.bak/net/bridge/Kconfig	2011-01-26 16:44:45.000000000 +0800
@@ -31,3 +31,13 @@
 	  will be called bridge.
 
 	  If unsure, say N.
+
+config DNI_MCAST_TO_UNICAST
+      tristate "DNI_MCAST_TO_UNICAST"
+      ---help---
+          DNI_MCAST_TO_UNICAST
+
+config DNI_MULTI_LAN_SUPPORT
+      tristate "DNI_MULTI_LAN_SUPPORT"
+      ---help---
+          DNI_MULTI_LAN_SUPPORT
diff -Nur linux-2.6.31.old/net/bridge/netfilter/ebt_ip.c linux-2.6.31.bak/net/bridge/netfilter/ebt_ip.c
--- linux-2.6.31.old/net/bridge/netfilter/ebt_ip.c	2011-01-26 16:43:36.000000000 +0800
+++ linux-2.6.31.bak/net/bridge/netfilter/ebt_ip.c	2011-01-26 16:44:45.000000000 +0800
@@ -24,6 +24,21 @@
 	__be16 dst;
 };
 
+static inline int
+check_source(u32 src, struct ebt_ip_info *info)
+{
+      int i;
+      int flag = 1;
+
+      for (i = 0; i < SOURCE_SIZE; i++)
+      {
+              if (src == info->msip[i])
+                      flag = 0;
+      }
+
+      return flag;
+}
+
 static bool
 ebt_ip_mt(const struct sk_buff *skb, const struct xt_match_param *par)
 {
@@ -74,6 +89,20 @@
 			return false;
 		}
 	}
+        if (info->bitmask & EBT_IP_MSIP)
+        {
+              u32 src = ih->saddr;
+              if (FWINV( check_source(src, info), EBT_IP_MSIP))
+                      return false;
+        }
+        if (info->bitmask & EBT_IP_DRANGE)
+        {
+              u32 dst = ih->daddr;
+              if (FWINV((dst < info->dip_range[0] || 
+                      dst > info->dip_range[1]), 
+                      EBT_IP_DRANGE))
+                      return false;
+        }
 	return true;
 }
 
@@ -101,6 +130,8 @@
 		return false;
 	if (info->bitmask & EBT_IP_SPORT && info->sport[0] > info->sport[1])
 		return false;
+        if (info->bitmask & EBT_IP_DRANGE && info->dip_range[0] > info->dip_range[1])
+              return false;
 	return true;
 }
 
