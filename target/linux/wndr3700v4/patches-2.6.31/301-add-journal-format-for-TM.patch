diff -Nur linux-2.6.32-old//fs/hfsplus_journal/bfind.c linux-2.6.32/fs/hfsplus_journal/bfind.c
--- linux-2.6.32-old//fs/hfsplus_journal/bfind.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/bfind.c	2011-11-17 09:00:40.778818402 -0500
@@ -0,0 +1,233 @@
+/*
+ *  linux/fs/hfsplus/bfind.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Search routines for btrees
+ */
+
+#include <linux/slab.h>
+#include "hfsplus_fs.h"
+
+int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)
+{
+	void *ptr;
+
+	fd->tree = tree;
+	fd->bnode = NULL;
+	ptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+	fd->search_key = ptr;
+	fd->key = ptr + tree->max_key_len + 2;
+	dprint(DBG_BNODE_REFS, "find_init: %d (%p)\n", tree->cnid, __builtin_return_address(0));
+	down(&tree->tree_lock);
+	return 0;
+}
+
+void hfs_find_exit(hfsplus_handle_t *hfsplus_handle, struct hfs_find_data *fd)
+{
+	hfs_bnode_put(hfsplus_handle, fd->bnode);
+	kfree(fd->search_key);
+	dprint(DBG_BNODE_REFS, "find_exit: %d (%p)\n", fd->tree->cnid, __builtin_return_address(0));
+	up(&fd->tree->tree_lock);
+	fd->tree = NULL;
+}
+
+int hfsplus_journalled_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)
+{
+	void *ptr;
+
+	fd->tree = tree;
+	fd->bnode = NULL;
+	ptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+	fd->search_key = ptr;
+	fd->key = ptr + tree->max_key_len + 2;
+	dprint(DBG_BNODE_REFS, "find_init: %d (%p)\n", tree->cnid, __builtin_return_address(0));
+	return 0;
+}
+
+void hfsplus_journalled_find_exit(hfsplus_handle_t *hfsplus_handle, struct hfs_find_data *fd)
+{
+	hfs_bnode_put(hfsplus_handle, fd->bnode);
+	kfree(fd->search_key);
+	dprint(DBG_BNODE_REFS, "find_exit: %d (%p)\n", fd->tree->cnid, __builtin_return_address(0));
+	fd->tree = NULL;
+}
+
+/* Find the record in bnode that best matches key (not greater than...)*/
+int __hfs_brec_find(struct hfs_bnode *bnode, struct hfs_find_data *fd)
+{
+	int cmpval;
+	u16 off, len, keylen;
+	int rec;
+	int b, e;
+	int res;
+
+	b = 0;
+	e = bnode->num_recs - 1;
+	res = -ENOENT;
+	do {
+		rec = (e + b) / 2;
+		len = hfs_brec_lenoff(bnode, rec, &off);
+		keylen = hfs_brec_keylen(bnode, rec);
+		hfs_bnode_read(bnode, fd->key, off, keylen);
+		cmpval = bnode->tree->keycmp(fd->key, fd->search_key);
+		if (!cmpval) {
+			e = rec;
+			res = 0;
+			goto done;
+		}
+		if (cmpval < 0)
+			b = rec + 1;
+		else
+			e = rec - 1;
+	} while (b <= e);
+	//printk("%d: %d,%d,%d\n", bnode->this, b, e, rec);
+	if (rec != e && e >= 0) {
+		len = hfs_brec_lenoff(bnode, e, &off);
+		keylen = hfs_brec_keylen(bnode, e);
+		hfs_bnode_read(bnode, fd->key, off, keylen);
+	}
+done:
+	fd->record = e;
+	fd->keyoffset = off;
+	fd->keylength = keylen;
+	fd->entryoffset = off + keylen;
+	fd->entrylength = len - keylen;
+	return res;
+}
+
+/* Traverse a B*Tree from the root to a leaf finding best fit to key */
+/* Return allocated copy of node found, set recnum to best record */
+int hfs_brec_find(hfsplus_handle_t *hfsplus_handle, struct hfs_find_data *fd)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *bnode;
+	u32 nidx, parent;
+	__be32 data;
+	int height, res;
+
+	tree = fd->tree;
+	if (fd->bnode)
+		hfs_bnode_put(hfsplus_handle, fd->bnode);
+	fd->bnode = NULL;
+	nidx = tree->root;
+	if (!nidx)
+		return -ENOENT;
+	height = tree->depth;
+	res = 0;
+	parent = 0;
+	for (;;) {
+		bnode = hfs_bnode_find(hfsplus_handle, tree, nidx);
+		if (IS_ERR(bnode)) {
+			res = PTR_ERR(bnode);
+			bnode = NULL;
+			break;
+		}
+		if (bnode->height != height)
+			goto invalid;
+		if (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))
+			goto invalid;
+		bnode->parent = parent;
+
+		res = __hfs_brec_find(bnode, fd);
+		if (!height)
+			break;
+		if (fd->record < 0)
+			goto release;
+
+		parent = nidx;
+		hfs_bnode_read(bnode, &data, fd->entryoffset, 4);
+		nidx = be32_to_cpu(data);
+		hfs_bnode_put(hfsplus_handle, bnode);
+	}
+	fd->bnode = bnode;
+	return res;
+
+invalid:
+	printk(KERN_ERR "hfs: inconsistency in B*Tree (%d,%d,%d,%u,%u)\n",
+		height, bnode->height, bnode->type, nidx, parent);
+	res = -EIO;
+release:
+	hfs_bnode_put(hfsplus_handle, bnode);
+	return res;
+}
+
+int hfs_brec_read(hfsplus_handle_t *hfsplus_handle, struct hfs_find_data *fd, void *rec, int rec_len)
+{
+	int res;
+
+	res = hfs_brec_find(hfsplus_handle, fd);
+	if (res)
+		return res;
+	if (fd->entrylength > rec_len)
+		return -EINVAL;
+	hfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);
+	return 0;
+}
+
+int hfs_brec_goto(hfsplus_handle_t *hfsplus_handle, struct hfs_find_data *fd, int cnt)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *bnode;
+	int idx, res = 0;
+	u16 off, len, keylen;
+
+	bnode = fd->bnode;
+	tree = bnode->tree;
+
+	if (cnt < 0) {
+		cnt = -cnt;
+		while (cnt > fd->record) {
+			cnt -= fd->record + 1;
+			fd->record = bnode->num_recs - 1;
+			idx = bnode->prev;
+			if (!idx) {
+				res = -ENOENT;
+				goto out;
+			}
+			hfs_bnode_put(hfsplus_handle, bnode);
+			bnode = hfs_bnode_find(hfsplus_handle, tree, idx);
+			if (IS_ERR(bnode)) {
+				res = PTR_ERR(bnode);
+				bnode = NULL;
+				goto out;
+			}
+		}
+		fd->record -= cnt;
+	} else {
+		while (cnt >= bnode->num_recs - fd->record) {
+			cnt -= bnode->num_recs - fd->record;
+			fd->record = 0;
+			idx = bnode->next;
+			if (!idx) {
+				res = -ENOENT;
+				goto out;
+			}
+			hfs_bnode_put(hfsplus_handle, bnode);
+			bnode = hfs_bnode_find(hfsplus_handle, tree, idx);
+			if (IS_ERR(bnode)) {
+				res = PTR_ERR(bnode);
+				bnode = NULL;
+				goto out;
+			}
+		}
+		fd->record += cnt;
+	}
+
+	len = hfs_brec_lenoff(bnode, fd->record, &off);
+	keylen = hfs_brec_keylen(bnode, fd->record);
+	fd->keyoffset = off;
+	fd->keylength = keylen;
+	fd->entryoffset = off + keylen;
+	fd->entrylength = len - keylen;
+	hfs_bnode_read(bnode, fd->key, off, keylen);
+out:
+	fd->bnode = bnode;
+	return res;
+}
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/bitmap.c linux-2.6.32/fs/hfsplus_journal/bitmap.c
--- linux-2.6.32-old//fs/hfsplus_journal/bitmap.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/bitmap.c	2011-11-17 09:00:40.778818402 -0500
@@ -0,0 +1,232 @@
+/*
+ *  linux/fs/hfsplus/bitmap.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handling of allocation file
+ */
+
+#include <linux/pagemap.h>
+
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+#define PAGE_CACHE_BITS	(PAGE_CACHE_SIZE * 8)
+
+int hfsplus_block_allocate(hfsplus_handle_t *hfsplus_handle, struct super_block *sb, u32 size, u32 offset, u32 *max)
+{
+	struct page *page;
+	struct address_space *mapping;
+	__be32 *pptr, *curr, *end;
+	u32 mask, start, len, n;
+	__be32 val;
+	int i;
+
+	len = *max;
+	if (!len)
+		return size;
+
+	dprint(DBG_BITMAP, "block_allocate: %u,%u,%u\n", size, offset, len);
+	mutex_lock(&HFSPLUS_SB(sb).alloc_file->i_mutex);
+	mapping = HFSPLUS_SB(sb).alloc_file->i_mapping;
+	page = read_mapping_page(mapping, offset / PAGE_CACHE_BITS, NULL);
+	if (IS_ERR(page)) {
+		start = size;
+		goto out;
+	}
+	pptr = kmap(page);
+	curr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;
+	i = offset % 32;
+	offset &= ~(PAGE_CACHE_BITS - 1);
+	if ((size ^ offset) / PAGE_CACHE_BITS)
+		end = pptr + PAGE_CACHE_BITS / 32;
+	else
+		end = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;
+
+	/* scan the first partial u32 for zero bits */
+	val = *curr;
+	if (~val) {
+		n = be32_to_cpu(val);
+		mask = (1U << 31) >> i;
+		for (; i < 32; mask >>= 1, i++) {
+			if (!(n & mask))
+				goto found;
+		}
+	}
+	curr++;
+
+	/* scan complete u32s for the first zero bit */
+	while (1) {
+		while (curr < end) {
+			val = *curr;
+			if (~val) {
+				n = be32_to_cpu(val);
+				mask = 1 << 31;
+				for (i = 0; i < 32; mask >>= 1, i++) {
+					if (!(n & mask))
+						goto found;
+				}
+			}
+			curr++;
+		}
+		kunmap(page);
+		offset += PAGE_CACHE_BITS;
+		if (offset >= size)
+			break;
+		page = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,
+					 NULL);
+		if (IS_ERR(page)) {
+			start = size;
+			goto out;
+		}
+		curr = pptr = kmap(page);
+		if ((size ^ offset) / PAGE_CACHE_BITS)
+			end = pptr + PAGE_CACHE_BITS / 32;
+		else
+			end = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;
+	}
+	dprint(DBG_BITMAP, "bitmap full\n");
+	start = size;
+	goto out;
+
+found:
+	start = offset + (curr - pptr) * 32 + i;
+	if (start >= size) {
+		dprint(DBG_BITMAP, "bitmap full\n");
+		goto out;
+	}
+	/* do any partial u32 at the start */
+	len = min(size - start, len);
+	while (1) {
+		n |= mask;
+		if (++i >= 32)
+			break;
+		mask >>= 1;
+		if (!--len || n & mask)
+			goto done;
+	}
+	if (!--len)
+		goto done;
+	*curr++ = cpu_to_be32(n);
+	/* do full u32s */
+	while (1) {
+		while (curr < end) {
+			n = be32_to_cpu(*curr);
+			if (len < 32)
+				goto last;
+			if (n) {
+				len = 32;
+				goto last;
+			}
+			*curr++ = cpu_to_be32(0xffffffff);
+			len -= 32;
+		}
+		hfsplus_journalled_set_page_dirty(hfsplus_handle, page);
+		kunmap(page);
+		offset += PAGE_CACHE_BITS;
+		page = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,
+					 NULL);
+		if (IS_ERR(page)) {
+			start = size;
+			goto out;
+		}
+		pptr = kmap(page);
+		curr = pptr;
+		end = pptr + PAGE_CACHE_BITS / 32;
+	}
+last:
+	/* do any partial u32 at end */
+	mask = 1U << 31;
+	for (i = 0; i < len; i++) {
+		if (n & mask)
+			break;
+		n |= mask;
+		mask >>= 1;
+	}
+done:
+	*curr = cpu_to_be32(n);
+	hfsplus_journalled_set_page_dirty(hfsplus_handle, page);
+	kunmap(page);
+	*max = offset + (curr - pptr) * 32 + i - start;
+	HFSPLUS_SB(sb).free_blocks -= *max;
+	sb->s_dirt = 1;
+	dprint(DBG_BITMAP, "-> %u,%u\n", start, *max);
+out:
+	mutex_unlock(&HFSPLUS_SB(sb).alloc_file->i_mutex);
+	return start;
+}
+
+int hfsplus_block_free(hfsplus_handle_t *hfsplus_handle, struct super_block *sb, u32 offset, u32 count)
+{
+	struct page *page;
+	struct address_space *mapping;
+	__be32 *pptr, *curr, *end;
+	u32 mask, len, pnr;
+	int i;
+
+	/* is there any actual work to be done? */
+	if (!count)
+		return 0;
+
+	dprint(DBG_BITMAP, "block_free: %u,%u\n", offset, count);
+	/* are all of the bits in range? */
+	if ((offset + count) > HFSPLUS_SB(sb).total_blocks)
+		return -2;
+
+	mutex_lock(&HFSPLUS_SB(sb).alloc_file->i_mutex);
+	mapping = HFSPLUS_SB(sb).alloc_file->i_mapping;
+	pnr = offset / PAGE_CACHE_BITS;
+	page = read_mapping_page(mapping, pnr, NULL);
+	pptr = kmap(page);
+	curr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;
+	end = pptr + PAGE_CACHE_BITS / 32;
+	len = count;
+
+	/* do any partial u32 at the start */
+	i = offset % 32;
+	if (i) {
+		int j = 32 - i;
+		mask = 0xffffffffU << j;
+		if (j > count) {
+			mask |= 0xffffffffU >> (i + count);
+			*curr++ &= cpu_to_be32(mask);
+			goto out;
+		}
+		*curr++ &= cpu_to_be32(mask);
+		count -= j;
+	}
+
+	/* do full u32s */
+	while (1) {
+		while (curr < end) {
+			if (count < 32)
+				goto done;
+			*curr++ = 0;
+			count -= 32;
+		}
+		if (!count)
+			break;
+		hfsplus_journalled_set_page_dirty(hfsplus_handle, page);
+		kunmap(page);
+		page = read_mapping_page(mapping, ++pnr, NULL);
+		pptr = kmap(page);
+		curr = pptr;
+		end = pptr + PAGE_CACHE_BITS / 32;
+	}
+done:
+	/* do any partial u32 at end */
+	if (count) {
+		mask = 0xffffffffU >> count;
+		*curr &= cpu_to_be32(mask);
+	}
+out:
+	hfsplus_journalled_set_page_dirty(hfsplus_handle, page);
+	kunmap(page);
+	HFSPLUS_SB(sb).free_blocks += len;
+	sb->s_dirt = 1;
+	mutex_unlock(&HFSPLUS_SB(sb).alloc_file->i_mutex);
+
+	return 0;
+}
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/bnode.c linux-2.6.32/fs/hfsplus_journal/bnode.c
--- linux-2.6.32-old//fs/hfsplus_journal/bnode.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/bnode.c	2011-11-17 09:00:40.778818402 -0500
@@ -0,0 +1,642 @@
+/*
+ *  linux/fs/hfsplus/bnode.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handle basic btree node operations
+ */
+
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
+#include <linux/swap.h>
+
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+/* Copy a specified range of bytes from the raw data of a node */
+void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)
+{
+	struct page **pagep;
+	int l;
+
+	off += node->page_offset;
+	pagep = node->page + (off >> PAGE_CACHE_SHIFT);
+	off &= ~PAGE_CACHE_MASK;
+
+	l = min(len, (int)PAGE_CACHE_SIZE - off);
+	memcpy(buf, kmap(*pagep) + off, l);
+	kunmap(*pagep);
+
+	while ((len -= l) != 0) {
+		buf += l;
+		l = min(len, (int)PAGE_CACHE_SIZE);
+		memcpy(buf, kmap(*++pagep), l);
+		kunmap(*pagep);
+	}
+}
+
+u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)
+{
+	__be16 data;
+	// optimize later...
+	hfs_bnode_read(node, &data, off, 2);
+	return be16_to_cpu(data);
+}
+
+u8 hfs_bnode_read_u8(struct hfs_bnode *node, int off)
+{
+	u8 data;
+	// optimize later...
+	hfs_bnode_read(node, &data, off, 1);
+	return data;
+}
+
+void hfs_bnode_read_key(struct hfs_bnode *node, void *key, int off)
+{
+	struct hfs_btree *tree;
+	int key_len;
+
+	tree = node->tree;
+	if (node->type == HFS_NODE_LEAF ||
+	    tree->attributes & HFS_TREE_VARIDXKEYS)
+		key_len = hfs_bnode_read_u16(node, off) + 2;
+	else
+		key_len = tree->max_key_len + 2;
+
+	hfs_bnode_read(node, key, off, key_len);
+}
+
+void hfs_bnode_write(hfsplus_handle_t *hfsplus_handle, struct hfs_bnode *node, void *buf, int off, int len)
+{
+	struct page **pagep;
+	int l;
+
+	off += node->page_offset;
+	pagep = node->page + (off >> PAGE_CACHE_SHIFT);
+	off &= ~PAGE_CACHE_MASK;
+
+	l = min(len, (int)PAGE_CACHE_SIZE - off);
+	memcpy(kmap(*pagep) + off, buf, l);
+	hfsplus_journalled_set_page_dirty(hfsplus_handle, *pagep);
+	kunmap(*pagep);
+
+	while ((len -= l) != 0) {
+		buf += l;
+		l = min(len, (int)PAGE_CACHE_SIZE);
+		memcpy(kmap(*++pagep), buf, l);
+		hfsplus_journalled_set_page_dirty(hfsplus_handle, *pagep);
+		kunmap(*pagep);
+	}
+}
+
+void hfs_bnode_write_u16(hfsplus_handle_t *hfsplus_handle, struct hfs_bnode *node, int off, u16 data)
+{
+	__be16 v = cpu_to_be16(data);
+	// optimize later...
+	hfs_bnode_write(hfsplus_handle, node, &v, off, 2);
+}
+
+void hfs_bnode_clear(hfsplus_handle_t *hfsplus_handle, struct hfs_bnode *node, int off, int len)
+{
+	struct page **pagep;
+	int l;
+
+	off += node->page_offset;
+	pagep = node->page + (off >> PAGE_CACHE_SHIFT);
+	off &= ~PAGE_CACHE_MASK;
+
+	l = min(len, (int)PAGE_CACHE_SIZE - off);
+	memset(kmap(*pagep) + off, 0, l);
+	hfsplus_journalled_set_page_dirty(hfsplus_handle, *pagep);
+	kunmap(*pagep);
+
+	while ((len -= l) != 0) {
+		l = min(len, (int)PAGE_CACHE_SIZE);
+		memset(kmap(*++pagep), 0, l);
+		hfsplus_journalled_set_page_dirty(hfsplus_handle, *pagep);
+		kunmap(*pagep);
+	}
+}
+
+void hfs_bnode_copy(hfsplus_handle_t *hfsplus_handle, struct hfs_bnode *dst_node, int dst,
+		    struct hfs_bnode *src_node, int src, int len)
+{
+	struct hfs_btree *tree;
+	struct page **src_page, **dst_page;
+	int l;
+
+	dprint(DBG_BNODE_MOD, "copybytes: %u,%u,%u\n", dst, src, len);
+	if (!len)
+		return;
+	tree = src_node->tree;
+	src += src_node->page_offset;
+	dst += dst_node->page_offset;
+	src_page = src_node->page + (src >> PAGE_CACHE_SHIFT);
+	src &= ~PAGE_CACHE_MASK;
+	dst_page = dst_node->page + (dst >> PAGE_CACHE_SHIFT);
+	dst &= ~PAGE_CACHE_MASK;
+
+	if (src == dst) {
+		l = min(len, (int)PAGE_CACHE_SIZE - src);
+		memcpy(kmap(*dst_page) + src, kmap(*src_page) + src, l);
+		kunmap(*src_page);
+		hfsplus_journalled_set_page_dirty(hfsplus_handle, *dst_page);
+		kunmap(*dst_page);
+
+		while ((len -= l) != 0) {
+			l = min(len, (int)PAGE_CACHE_SIZE);
+			memcpy(kmap(*++dst_page), kmap(*++src_page), l);
+			kunmap(*src_page);
+			hfsplus_journalled_set_page_dirty(hfsplus_handle, *dst_page);
+			kunmap(*dst_page);
+		}
+	} else {
+		void *src_ptr, *dst_ptr;
+
+		do {
+			src_ptr = kmap(*src_page) + src;
+			dst_ptr = kmap(*dst_page) + dst;
+			if (PAGE_CACHE_SIZE - src < PAGE_CACHE_SIZE - dst) {
+				l = PAGE_CACHE_SIZE - src;
+				src = 0;
+				dst += l;
+			} else {
+				l = PAGE_CACHE_SIZE - dst;
+				src += l;
+				dst = 0;
+			}
+			l = min(len, l);
+			memcpy(dst_ptr, src_ptr, l);
+			kunmap(*src_page);
+			hfsplus_journalled_set_page_dirty(hfsplus_handle, *dst_page);
+			kunmap(*dst_page);
+			if (!dst)
+				dst_page++;
+			else
+				src_page++;
+		} while ((len -= l));
+	}
+}
+
+void hfs_bnode_move(hfsplus_handle_t *hfsplus_handle, struct hfs_bnode *node, int dst, int src, int len)
+{
+	struct page **src_page, **dst_page;
+	int l;
+
+	dprint(DBG_BNODE_MOD, "movebytes: %u,%u,%u\n", dst, src, len);
+	if (!len)
+		return;
+	src += node->page_offset;
+	dst += node->page_offset;
+	if (dst > src) {
+		src += len - 1;
+		src_page = node->page + (src >> PAGE_CACHE_SHIFT);
+		src = (src & ~PAGE_CACHE_MASK) + 1;
+		dst += len - 1;
+		dst_page = node->page + (dst >> PAGE_CACHE_SHIFT);
+		dst = (dst & ~PAGE_CACHE_MASK) + 1;
+
+		if (src == dst) {
+			while (src < len) {
+				memmove(kmap(*dst_page), kmap(*src_page), src);
+				kunmap(*src_page);
+				hfsplus_journalled_set_page_dirty(hfsplus_handle, *dst_page);
+				kunmap(*dst_page);
+				len -= src;
+				src = PAGE_CACHE_SIZE;
+				src_page--;
+				dst_page--;
+			}
+			src -= len;
+			memmove(kmap(*dst_page) + src, kmap(*src_page) + src, len);
+			kunmap(*src_page);
+			hfsplus_journalled_set_page_dirty(hfsplus_handle, *dst_page);
+			kunmap(*dst_page);
+		} else {
+			void *src_ptr, *dst_ptr;
+
+			do {
+				src_ptr = kmap(*src_page) + src;
+				dst_ptr = kmap(*dst_page) + dst;
+				if (src < dst) {
+					l = src;
+					src = PAGE_CACHE_SIZE;
+					dst -= l;
+				} else {
+					l = dst;
+					src -= l;
+					dst = PAGE_CACHE_SIZE;
+				}
+				l = min(len, l);
+				memmove(dst_ptr - l, src_ptr - l, l);
+				kunmap(*src_page);
+				hfsplus_journalled_set_page_dirty(hfsplus_handle, *dst_page);
+				kunmap(*dst_page);
+				if (dst == PAGE_CACHE_SIZE)
+					dst_page--;
+				else
+					src_page--;
+			} while ((len -= l));
+		}
+	} else {
+		src_page = node->page + (src >> PAGE_CACHE_SHIFT);
+		src &= ~PAGE_CACHE_MASK;
+		dst_page = node->page + (dst >> PAGE_CACHE_SHIFT);
+		dst &= ~PAGE_CACHE_MASK;
+
+		if (src == dst) {
+			l = min(len, (int)PAGE_CACHE_SIZE - src);
+			memmove(kmap(*dst_page) + src, kmap(*src_page) + src, l);
+			kunmap(*src_page);
+			hfsplus_journalled_set_page_dirty(hfsplus_handle, *dst_page);
+			kunmap(*dst_page);
+
+			while ((len -= l) != 0) {
+				l = min(len, (int)PAGE_CACHE_SIZE);
+				memmove(kmap(*++dst_page), kmap(*++src_page), l);
+				kunmap(*src_page);
+				hfsplus_journalled_set_page_dirty(hfsplus_handle, *dst_page);
+				kunmap(*dst_page);
+			}
+		} else {
+			void *src_ptr, *dst_ptr;
+
+			do {
+				src_ptr = kmap(*src_page) + src;
+				dst_ptr = kmap(*dst_page) + dst;
+				if (PAGE_CACHE_SIZE - src < PAGE_CACHE_SIZE - dst) {
+					l = PAGE_CACHE_SIZE - src;
+					src = 0;
+					dst += l;
+				} else {
+					l = PAGE_CACHE_SIZE - dst;
+					src += l;
+					dst = 0;
+				}
+				l = min(len, l);
+				memmove(dst_ptr, src_ptr, l);
+				kunmap(*src_page);
+				hfsplus_journalled_set_page_dirty(hfsplus_handle, *dst_page);
+				kunmap(*dst_page);
+				if (!dst)
+					dst_page++;
+				else
+					src_page++;
+			} while ((len -= l));
+		}
+	}
+}
+
+void hfs_bnode_dump(struct hfs_bnode *node)
+{
+	struct hfs_bnode_desc desc;
+	__be32 cnid;
+	int i, off, key_off;
+
+	dprint(DBG_BNODE_MOD, "bnode: %d\n", node->this);
+	hfs_bnode_read(node, &desc, 0, sizeof(desc));
+	dprint(DBG_BNODE_MOD, "%d, %d, %d, %d, %d\n",
+		be32_to_cpu(desc.next), be32_to_cpu(desc.prev),
+		desc.type, desc.height, be16_to_cpu(desc.num_recs));
+
+	off = node->tree->node_size - 2;
+	for (i = be16_to_cpu(desc.num_recs); i >= 0; off -= 2, i--) {
+		key_off = hfs_bnode_read_u16(node, off);
+		dprint(DBG_BNODE_MOD, " %d", key_off);
+		if (i && node->type == HFS_NODE_INDEX) {
+			int tmp;
+
+			if (node->tree->attributes & HFS_TREE_VARIDXKEYS)
+				tmp = hfs_bnode_read_u16(node, key_off) + 2;
+			else
+				tmp = node->tree->max_key_len + 2;
+			dprint(DBG_BNODE_MOD, " (%d", tmp);
+			hfs_bnode_read(node, &cnid, key_off + tmp, 4);
+			dprint(DBG_BNODE_MOD, ",%d)", be32_to_cpu(cnid));
+		} else if (i && node->type == HFS_NODE_LEAF) {
+			int tmp;
+
+			tmp = hfs_bnode_read_u16(node, key_off);
+			dprint(DBG_BNODE_MOD, " (%d)", tmp);
+		}
+	}
+	dprint(DBG_BNODE_MOD, "\n");
+}
+
+void hfs_bnode_unlink(hfsplus_handle_t *hfsplus_handle, struct hfs_bnode *node)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *tmp;
+	__be32 cnid;
+
+	tree = node->tree;
+	if (node->prev) {
+		tmp = hfs_bnode_find(hfsplus_handle, tree, node->prev);
+		if (IS_ERR(tmp))
+			return;
+		tmp->next = node->next;
+		cnid = cpu_to_be32(tmp->next);
+		hfs_bnode_write(hfsplus_handle, tmp, &cnid, offsetof(struct hfs_bnode_desc, next), 4);
+		hfs_bnode_put(hfsplus_handle, tmp);
+	} else if (node->type == HFS_NODE_LEAF)
+		tree->leaf_head = node->next;
+
+	if (node->next) {
+		tmp = hfs_bnode_find(hfsplus_handle, tree, node->next);
+		if (IS_ERR(tmp))
+			return;
+		tmp->prev = node->prev;
+		cnid = cpu_to_be32(tmp->prev);
+		hfs_bnode_write(hfsplus_handle, tmp, &cnid, offsetof(struct hfs_bnode_desc, prev), 4);
+		hfs_bnode_put(hfsplus_handle, tmp);
+	} else if (node->type == HFS_NODE_LEAF)
+		tree->leaf_tail = node->prev;
+
+	// move down?
+	if (!node->prev && !node->next) {
+		printk(KERN_DEBUG "hfs_btree_del_level\n");
+	}
+	if (!node->parent) {
+		tree->root = 0;
+		tree->depth = 0;
+	}
+	set_bit(HFS_BNODE_DELETED, &node->flags);
+}
+
+static inline int hfs_bnode_hash(u32 num)
+{
+	num = (num >> 16) + num;
+	num += num >> 8;
+	return num & (NODE_HASH_SIZE - 1);
+}
+
+struct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid)
+{
+	struct hfs_bnode *node;
+
+	if (cnid >= tree->node_count) {
+		printk(KERN_ERR "hfs: request for non-existent node %d in B*Tree\n", cnid);
+		return NULL;
+	}
+
+	for (node = tree->node_hash[hfs_bnode_hash(cnid)];
+	     node; node = node->next_hash) {
+		if (node->this == cnid) {
+			return node;
+		}
+	}
+	return NULL;
+}
+
+static struct hfs_bnode *__hfs_bnode_create(struct hfs_btree *tree, u32 cnid)
+{
+	struct super_block *sb;
+	struct hfs_bnode *node, *node2;
+	struct address_space *mapping;
+	struct page *page;
+	int size, block, i, hash;
+	loff_t off;
+
+	if (cnid >= tree->node_count) {
+		printk(KERN_ERR "hfs: request for non-existent node %d in B*Tree\n", cnid);
+		return NULL;
+	}
+
+	sb = tree->inode->i_sb;
+	size = sizeof(struct hfs_bnode) + tree->pages_per_bnode *
+		sizeof(struct page *);
+	node = kzalloc(size, GFP_KERNEL);
+	if (!node)
+		return NULL;
+	node->tree = tree;
+	node->this = cnid;
+	set_bit(HFS_BNODE_NEW, &node->flags);
+	atomic_set(&node->refcnt, 1);
+	dprint(DBG_BNODE_REFS, "new_node(%d:%d): 1\n",
+	       node->tree->cnid, node->this);
+	init_waitqueue_head(&node->lock_wq);
+	spin_lock(&tree->hash_lock);
+	node2 = hfs_bnode_findhash(tree, cnid);
+	if (!node2) {
+		hash = hfs_bnode_hash(cnid);
+		node->next_hash = tree->node_hash[hash];
+		tree->node_hash[hash] = node;
+		tree->node_hash_cnt++;
+	} else {
+		spin_unlock(&tree->hash_lock);
+		kfree(node);
+		wait_event(node2->lock_wq, !test_bit(HFS_BNODE_NEW, &node2->flags));
+		return node2;
+	}
+	spin_unlock(&tree->hash_lock);
+
+	mapping = tree->inode->i_mapping;
+	off = (loff_t)cnid << tree->node_size_shift;
+	block = off >> PAGE_CACHE_SHIFT;
+	node->page_offset = off & ~PAGE_CACHE_MASK;
+	for (i = 0; i < tree->pages_per_bnode; block++, i++) {
+		page = read_mapping_page(mapping, block, NULL);
+		if (IS_ERR(page))
+			goto fail;
+		if (PageError(page)) {
+			page_cache_release(page);
+			goto fail;
+		}
+		page_cache_release(page);
+		node->page[i] = page;
+	}
+
+	return node;
+fail:
+	set_bit(HFS_BNODE_ERROR, &node->flags);
+	return node;
+}
+
+void hfs_bnode_unhash(struct hfs_bnode *node)
+{
+	struct hfs_bnode **p;
+
+	dprint(DBG_BNODE_REFS, "remove_node(%d:%d): %d\n",
+		node->tree->cnid, node->this, atomic_read(&node->refcnt));
+	for (p = &node->tree->node_hash[hfs_bnode_hash(node->this)];
+	     *p && *p != node; p = &(*p)->next_hash)
+		;
+	BUG_ON(!*p);
+	*p = node->next_hash;
+	node->tree->node_hash_cnt--;
+}
+
+/* Load a particular node out of a tree */
+struct hfs_bnode *hfs_bnode_find(hfsplus_handle_t *hfsplus_handle, struct hfs_btree *tree, u32 num)
+{
+	struct hfs_bnode *node;
+	struct hfs_bnode_desc *desc;
+	int i, rec_off, off, next_off;
+	int entry_size, key_size;
+
+	spin_lock(&tree->hash_lock);
+	node = hfs_bnode_findhash(tree, num);
+	if (node) {
+		hfs_bnode_get(node);
+		spin_unlock(&tree->hash_lock);
+		wait_event(node->lock_wq, !test_bit(HFS_BNODE_NEW, &node->flags));
+		if (test_bit(HFS_BNODE_ERROR, &node->flags))
+			goto node_error;
+		return node;
+	}
+	spin_unlock(&tree->hash_lock);
+	node = __hfs_bnode_create(tree, num);
+	if (!node)
+		return ERR_PTR(-ENOMEM);
+	if (test_bit(HFS_BNODE_ERROR, &node->flags))
+		goto node_error;
+	if (!test_bit(HFS_BNODE_NEW, &node->flags))
+		return node;
+
+	desc = (struct hfs_bnode_desc *)(kmap(node->page[0]) + node->page_offset);
+	node->prev = be32_to_cpu(desc->prev);
+	node->next = be32_to_cpu(desc->next);
+	node->num_recs = be16_to_cpu(desc->num_recs);
+	node->type = desc->type;
+	node->height = desc->height;
+	kunmap(node->page[0]);
+
+	switch (node->type) {
+	case HFS_NODE_HEADER:
+	case HFS_NODE_MAP:
+		if (node->height != 0)
+			goto node_error;
+		break;
+	case HFS_NODE_LEAF:
+		if (node->height != 1)
+			goto node_error;
+		break;
+	case HFS_NODE_INDEX:
+		if (node->height <= 1 || node->height > tree->depth)
+			goto node_error;
+		break;
+	default:
+		goto node_error;
+	}
+
+	rec_off = tree->node_size - 2;
+	off = hfs_bnode_read_u16(node, rec_off);
+	if (off != sizeof(struct hfs_bnode_desc))
+		goto node_error;
+	for (i = 1; i <= node->num_recs; off = next_off, i++) {
+		rec_off -= 2;
+		next_off = hfs_bnode_read_u16(node, rec_off);
+		if (next_off <= off ||
+		    next_off > tree->node_size ||
+		    next_off & 1)
+			goto node_error;
+		entry_size = next_off - off;
+		if (node->type != HFS_NODE_INDEX &&
+		    node->type != HFS_NODE_LEAF)
+			continue;
+		key_size = hfs_bnode_read_u16(node, off) + 2;
+		if (key_size >= entry_size || key_size & 1)
+			goto node_error;
+	}
+	clear_bit(HFS_BNODE_NEW, &node->flags);
+	wake_up(&node->lock_wq);
+	return node;
+
+node_error:
+	set_bit(HFS_BNODE_ERROR, &node->flags);
+	clear_bit(HFS_BNODE_NEW, &node->flags);
+	wake_up(&node->lock_wq);
+	hfs_bnode_put(hfsplus_handle, node);
+	return ERR_PTR(-EIO);
+}
+
+void hfs_bnode_free(struct hfs_bnode *node)
+{
+	//int i;
+
+	//for (i = 0; i < node->tree->pages_per_bnode; i++)
+	//	if (node->page[i])
+	//		page_cache_release(node->page[i]);
+	kfree(node);
+}
+
+struct hfs_bnode *hfs_bnode_create(hfsplus_handle_t *hfsplus_handle, struct hfs_btree *tree, u32 num)
+{
+	struct hfs_bnode *node;
+	struct page **pagep;
+	int i;
+
+	spin_lock(&tree->hash_lock);
+	node = hfs_bnode_findhash(tree, num);
+	spin_unlock(&tree->hash_lock);
+	if (node) {
+		printk(KERN_CRIT "new node %u already hashed?\n", num);
+		WARN_ON(1);
+		return node;
+	}
+	node = __hfs_bnode_create(tree, num);
+	if (!node)
+		return ERR_PTR(-ENOMEM);
+	if (test_bit(HFS_BNODE_ERROR, &node->flags)) {
+		hfs_bnode_put(hfsplus_handle, node);
+		return ERR_PTR(-EIO);
+	}
+
+	pagep = node->page;
+	memset(kmap(*pagep) + node->page_offset, 0,
+	       min((int)PAGE_CACHE_SIZE, (int)tree->node_size));
+	hfsplus_journalled_set_page_dirty(hfsplus_handle, *pagep);
+	kunmap(*pagep);
+	for (i = 1; i < tree->pages_per_bnode; i++) {
+		memset(kmap(*++pagep), 0, PAGE_CACHE_SIZE);
+		hfsplus_journalled_set_page_dirty(hfsplus_handle, *pagep);
+		kunmap(*pagep);
+	}
+	clear_bit(HFS_BNODE_NEW, &node->flags);
+	wake_up(&node->lock_wq);
+
+	return node;
+}
+
+void hfs_bnode_get(struct hfs_bnode *node)
+{
+	if (node) {
+		atomic_inc(&node->refcnt);
+		dprint(DBG_BNODE_REFS, "get_node(%d:%d): %d\n",
+		       node->tree->cnid, node->this, atomic_read(&node->refcnt));
+	}
+}
+
+/* Dispose of resources used by a node */
+void hfs_bnode_put(hfsplus_handle_t *hfsplus_handle, struct hfs_bnode *node)
+{
+	if (node) {
+		struct hfs_btree *tree = node->tree;
+		int i;
+
+		dprint(DBG_BNODE_REFS, "put_node(%d:%d): %d\n",
+		       node->tree->cnid, node->this, atomic_read(&node->refcnt));
+		BUG_ON(!atomic_read(&node->refcnt));
+		if (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))
+			return;
+		for (i = 0; i < tree->pages_per_bnode; i++) {
+			if (!node->page[i])
+				continue;
+			mark_page_accessed(node->page[i]);
+		}
+
+		if (test_bit(HFS_BNODE_DELETED, &node->flags)) {
+			hfs_bnode_unhash(node);
+			spin_unlock(&tree->hash_lock);
+			hfs_bmap_free(hfsplus_handle, node);
+			hfs_bnode_free(node);
+			return;
+		}
+		spin_unlock(&tree->hash_lock);
+	}
+}
+
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/brec.c linux-2.6.32/fs/hfsplus_journal/brec.c
--- linux-2.6.32-old//fs/hfsplus_journal/brec.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/brec.c	2011-11-17 09:00:40.778818402 -0500
@@ -0,0 +1,495 @@
+/*
+ *  linux/fs/hfsplus/brec.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handle individual btree records
+ */
+
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+static struct hfs_bnode *hfs_bnode_split(hfsplus_handle_t *hfsplus_handle, struct hfs_find_data *fd);
+static int hfs_brec_update_parent(hfsplus_handle_t *hfsplus_handle, struct hfs_find_data *fd);
+static int hfs_btree_inc_height(hfsplus_handle_t *hfsplus_handle, struct hfs_btree *);
+
+/* Get the length and offset of the given record in the given node */
+u16 hfs_brec_lenoff(struct hfs_bnode *node, u16 rec, u16 *off)
+{
+	__be16 retval[2];
+	u16 dataoff;
+
+	dataoff = node->tree->node_size - (rec + 2) * 2;
+	hfs_bnode_read(node, retval, dataoff, 4);
+	*off = be16_to_cpu(retval[1]);
+	return be16_to_cpu(retval[0]) - *off;
+}
+
+/* Get the length of the key from a keyed record */
+u16 hfs_brec_keylen(struct hfs_bnode *node, u16 rec)
+{
+	u16 retval, recoff;
+
+	if (node->type != HFS_NODE_INDEX && node->type != HFS_NODE_LEAF)
+		return 0;
+
+	if ((node->type == HFS_NODE_INDEX) &&
+	   !(node->tree->attributes & HFS_TREE_VARIDXKEYS)) {
+		retval = node->tree->max_key_len + 2;
+	} else {
+		recoff = hfs_bnode_read_u16(node, node->tree->node_size - (rec + 1) * 2);
+		if (!recoff)
+			return 0;
+		if (node->tree->attributes & HFS_TREE_BIGKEYS)
+			retval = hfs_bnode_read_u16(node, recoff) + 2;
+		else
+			retval = (hfs_bnode_read_u8(node, recoff) | 1) + 1;
+	}
+	return retval;
+}
+
+int hfs_brec_insert(hfsplus_handle_t *hfsplus_handle, struct hfs_find_data *fd, void *entry, int entry_len)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *node, *new_node;
+	int size, key_len, rec;
+	int data_off, end_off;
+	int idx_rec_off, data_rec_off, end_rec_off;
+	__be32 cnid;
+
+	tree = fd->tree;
+	if (!fd->bnode) {
+		if (!tree->root)
+			hfs_btree_inc_height(hfsplus_handle, tree);
+		fd->bnode = hfs_bnode_find(hfsplus_handle, tree, tree->leaf_head);
+		if (IS_ERR(fd->bnode))
+			return PTR_ERR(fd->bnode);
+		fd->record = -1;
+	}
+	new_node = NULL;
+	key_len = be16_to_cpu(fd->search_key->key_len) + 2;
+again:
+	/* new record idx and complete record size */
+	rec = fd->record + 1;
+	size = key_len + entry_len;
+
+	node = fd->bnode;
+	hfs_bnode_dump(node);
+	/* get last offset */
+	end_rec_off = tree->node_size - (node->num_recs + 1) * 2;
+	end_off = hfs_bnode_read_u16(node, end_rec_off);
+	end_rec_off -= 2;
+	dprint(DBG_BNODE_MOD, "insert_rec: %d, %d, %d, %d\n", rec, size, end_off, end_rec_off);
+	if (size > end_rec_off - end_off) {
+		if (new_node)
+			panic("not enough room!\n");
+		new_node = hfs_bnode_split(hfsplus_handle, fd);
+		if (IS_ERR(new_node))
+			return PTR_ERR(new_node);
+		goto again;
+	}
+	if (node->type == HFS_NODE_LEAF) {
+		tree->leaf_count++;
+		if (hfsplus_journalled_mark_inode_dirty(__FUNCTION__, hfsplus_handle, tree->inode))
+			return -1;
+	}
+	node->num_recs++;
+	/* write new last offset */
+	hfs_bnode_write_u16(hfsplus_handle, node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);
+	hfs_bnode_write_u16(hfsplus_handle, node, end_rec_off, end_off + size);
+	data_off = end_off;
+	data_rec_off = end_rec_off + 2;
+	idx_rec_off = tree->node_size - (rec + 1) * 2;
+	if (idx_rec_off == data_rec_off)
+		goto skip;
+	/* move all following entries */
+	do {
+		data_off = hfs_bnode_read_u16(node, data_rec_off + 2);
+		hfs_bnode_write_u16(hfsplus_handle, node, data_rec_off, data_off + size);
+		data_rec_off += 2;
+	} while (data_rec_off < idx_rec_off);
+
+	/* move data away */
+	hfs_bnode_move(hfsplus_handle, node, data_off + size, data_off,
+		       end_off - data_off);
+
+skip:
+	hfs_bnode_write(hfsplus_handle, node, fd->search_key, data_off, key_len);
+	hfs_bnode_write(hfsplus_handle, node, entry, data_off + key_len, entry_len);
+	hfs_bnode_dump(node);
+
+	if (new_node) {
+		/* update parent key if we inserted a key
+		 * at the start of the first node
+		 */
+		if (!rec && new_node != node)
+			hfs_brec_update_parent(hfsplus_handle, fd);
+
+		hfs_bnode_put(hfsplus_handle, fd->bnode);
+		if (!new_node->parent) {
+			hfs_btree_inc_height(hfsplus_handle, tree);
+			new_node->parent = tree->root;
+		}
+		fd->bnode = hfs_bnode_find(hfsplus_handle, tree, new_node->parent);
+
+		/* create index data entry */
+		cnid = cpu_to_be32(new_node->this);
+		entry = &cnid;
+		entry_len = sizeof(cnid);
+
+		/* get index key */
+		hfs_bnode_read_key(new_node, fd->search_key, 14);
+		__hfs_brec_find(fd->bnode, fd);
+
+		hfs_bnode_put(hfsplus_handle, new_node);
+		new_node = NULL;
+
+		if (tree->attributes & HFS_TREE_VARIDXKEYS)
+			key_len = be16_to_cpu(fd->search_key->key_len) + 2;
+		else {
+			fd->search_key->key_len = cpu_to_be16(tree->max_key_len);
+			key_len = tree->max_key_len + 2;
+		}
+		goto again;
+	}
+
+	if (!rec)
+		hfs_brec_update_parent(hfsplus_handle, fd);
+
+	return 0;
+}
+
+int hfs_brec_remove(hfsplus_handle_t *hfsplus_handle, struct hfs_find_data *fd)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *node, *parent;
+	int end_off, rec_off, data_off, size;
+
+	tree = fd->tree;
+	node = fd->bnode;
+again:
+	rec_off = tree->node_size - (fd->record + 2) * 2;
+	end_off = tree->node_size - (node->num_recs + 1) * 2;
+
+	if (node->type == HFS_NODE_LEAF) {
+		tree->leaf_count--;
+		if (hfsplus_journalled_mark_inode_dirty(__FUNCTION__, hfsplus_handle, tree->inode))
+			return -1;
+	}
+	hfs_bnode_dump(node);
+	dprint(DBG_BNODE_MOD, "remove_rec: %d, %d\n", fd->record, fd->keylength + fd->entrylength);
+	if (!--node->num_recs) {
+		hfs_bnode_unlink(hfsplus_handle, node);
+		if (!node->parent)
+			return 0;
+		parent = hfs_bnode_find(hfsplus_handle, tree, node->parent);
+		if (IS_ERR(parent))
+			return PTR_ERR(parent);
+		hfs_bnode_put(hfsplus_handle, node);
+		node = fd->bnode = parent;
+
+		__hfs_brec_find(node, fd);
+		goto again;
+	}
+	hfs_bnode_write_u16(hfsplus_handle, node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);
+
+	if (rec_off == end_off)
+		goto skip;
+	size = fd->keylength + fd->entrylength;
+
+	do {
+		data_off = hfs_bnode_read_u16(node, rec_off);
+		hfs_bnode_write_u16(hfsplus_handle, node, rec_off + 2, data_off - size);
+		rec_off -= 2;
+	} while (rec_off >= end_off);
+
+	/* fill hole */
+	hfs_bnode_move(hfsplus_handle, node, fd->keyoffset, fd->keyoffset + size,
+		       data_off - fd->keyoffset - size);
+skip:
+	hfs_bnode_dump(node);
+	if (!fd->record)
+		hfs_brec_update_parent(hfsplus_handle, fd);
+	return 0;
+}
+
+static struct hfs_bnode *hfs_bnode_split(hfsplus_handle_t *hfsplus_handle, struct hfs_find_data *fd)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *node, *new_node;
+	struct hfs_bnode_desc node_desc;
+	int num_recs, new_rec_off, new_off, old_rec_off;
+	int data_start, data_end, size;
+
+	tree = fd->tree;
+	node = fd->bnode;
+	new_node = hfs_bmap_alloc(hfsplus_handle, tree);
+	if (IS_ERR(new_node))
+		return new_node;
+	hfs_bnode_get(node);
+	dprint(DBG_BNODE_MOD, "split_nodes: %d - %d - %d\n",
+		node->this, new_node->this, node->next);
+	new_node->next = node->next;
+	new_node->prev = node->this;
+	new_node->parent = node->parent;
+	new_node->type = node->type;
+	new_node->height = node->height;
+
+	size = tree->node_size / 2 - node->num_recs * 2 - 14;
+	old_rec_off = tree->node_size - 4;
+	num_recs = 1;
+	for (;;) {
+		data_start = hfs_bnode_read_u16(node, old_rec_off);
+		if (data_start > size)
+			break;
+		old_rec_off -= 2;
+		if (++num_recs < node->num_recs)
+			continue;
+		/* panic? */
+		hfs_bnode_put(hfsplus_handle, node);
+		hfs_bnode_put(hfsplus_handle, new_node);
+		return ERR_PTR(-ENOSPC);
+	}
+
+	if (fd->record + 1 < num_recs) {
+		/* new record is in the lower half,
+		 * so leave some more space there
+		 */
+		old_rec_off += 2;
+		num_recs--;
+		data_start = hfs_bnode_read_u16(node, old_rec_off);
+	} else {
+		hfs_bnode_put(hfsplus_handle, node);
+		hfs_bnode_get(new_node);
+		fd->bnode = new_node;
+		fd->record -= num_recs;
+		fd->keyoffset -= data_start - 14;
+		fd->entryoffset -= data_start - 14;
+	}
+	new_node->num_recs = node->num_recs - num_recs;
+	node->num_recs = num_recs;
+
+	new_rec_off = tree->node_size - 2;
+	new_off = 14;
+	size = data_start - new_off;
+	num_recs = new_node->num_recs;
+	data_end = data_start;
+	while (num_recs) {
+		hfs_bnode_write_u16(hfsplus_handle, new_node, new_rec_off, new_off);
+		old_rec_off -= 2;
+		new_rec_off -= 2;
+		data_end = hfs_bnode_read_u16(node, old_rec_off);
+		new_off = data_end - size;
+		num_recs--;
+	}
+	hfs_bnode_write_u16(hfsplus_handle, new_node, new_rec_off, new_off);
+	hfs_bnode_copy(hfsplus_handle, new_node, 14, node, data_start, data_end - data_start);
+
+	/* update new bnode header */
+	node_desc.next = cpu_to_be32(new_node->next);
+	node_desc.prev = cpu_to_be32(new_node->prev);
+	node_desc.type = new_node->type;
+	node_desc.height = new_node->height;
+	node_desc.num_recs = cpu_to_be16(new_node->num_recs);
+	node_desc.reserved = 0;
+	hfs_bnode_write(hfsplus_handle, new_node, &node_desc, 0, sizeof(node_desc));
+
+	/* update previous bnode header */
+	node->next = new_node->this;
+	hfs_bnode_read(node, &node_desc, 0, sizeof(node_desc));
+	node_desc.next = cpu_to_be32(node->next);
+	node_desc.num_recs = cpu_to_be16(node->num_recs);
+	hfs_bnode_write(hfsplus_handle, node, &node_desc, 0, sizeof(node_desc));
+
+	/* update next bnode header */
+	if (new_node->next) {
+		struct hfs_bnode *next_node = hfs_bnode_find(hfsplus_handle, tree, new_node->next);
+		next_node->prev = new_node->this;
+		hfs_bnode_read(next_node, &node_desc, 0, sizeof(node_desc));
+		node_desc.prev = cpu_to_be32(next_node->prev);
+		hfs_bnode_write(hfsplus_handle, next_node, &node_desc, 0, sizeof(node_desc));
+		hfs_bnode_put(hfsplus_handle, next_node);
+	} else if (node->this == tree->leaf_tail) {
+		/* if there is no next node, this might be the new tail */
+		tree->leaf_tail = new_node->this;
+		if (hfsplus_journalled_mark_inode_dirty(__FUNCTION__, hfsplus_handle, tree->inode))
+			return NULL;
+	}
+
+	hfs_bnode_dump(node);
+	hfs_bnode_dump(new_node);
+	hfs_bnode_put(hfsplus_handle, node);
+
+	return new_node;
+}
+
+static int hfs_brec_update_parent(hfsplus_handle_t *hfsplus_handle, struct hfs_find_data *fd)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *node, *new_node, *parent;
+	int newkeylen, diff;
+	int rec, rec_off, end_rec_off;
+	int start_off, end_off;
+
+	tree = fd->tree;
+	node = fd->bnode;
+	new_node = NULL;
+	if (!node->parent)
+		return 0;
+
+again:
+	parent = hfs_bnode_find(hfsplus_handle, tree, node->parent);
+	if (IS_ERR(parent))
+		return PTR_ERR(parent);
+	__hfs_brec_find(parent, fd);
+	hfs_bnode_dump(parent);
+	rec = fd->record;
+
+	/* size difference between old and new key */
+	if (tree->attributes & HFS_TREE_VARIDXKEYS)
+		newkeylen = hfs_bnode_read_u16(node, 14) + 2;
+	else
+		fd->keylength = newkeylen = tree->max_key_len + 2;
+	dprint(DBG_BNODE_MOD, "update_rec: %d, %d, %d\n", rec, fd->keylength, newkeylen);
+
+	rec_off = tree->node_size - (rec + 2) * 2;
+	end_rec_off = tree->node_size - (parent->num_recs + 1) * 2;
+	diff = newkeylen - fd->keylength;
+	if (!diff)
+		goto skip;
+	if (diff > 0) {
+		end_off = hfs_bnode_read_u16(parent, end_rec_off);
+		if (end_rec_off - end_off < diff) {
+
+			printk(KERN_DEBUG "hfs: splitting index node...\n");
+			fd->bnode = parent;
+			new_node = hfs_bnode_split(hfsplus_handle, fd);
+			if (IS_ERR(new_node))
+				return PTR_ERR(new_node);
+			parent = fd->bnode;
+			rec = fd->record;
+			rec_off = tree->node_size - (rec + 2) * 2;
+			end_rec_off = tree->node_size - (parent->num_recs + 1) * 2;
+		}
+	}
+
+	end_off = start_off = hfs_bnode_read_u16(parent, rec_off);
+	hfs_bnode_write_u16(hfsplus_handle, parent, rec_off, start_off + diff);
+	start_off -= 4;	/* move previous cnid too */
+
+	while (rec_off > end_rec_off) {
+		rec_off -= 2;
+		end_off = hfs_bnode_read_u16(parent, rec_off);
+		hfs_bnode_write_u16(hfsplus_handle, parent, rec_off, end_off + diff);
+	}
+	hfs_bnode_move(hfsplus_handle, parent, start_off + diff, start_off,
+		       end_off - start_off);
+skip:
+	hfs_bnode_copy(hfsplus_handle, parent, fd->keyoffset, node, 14, newkeylen);
+	hfs_bnode_dump(parent);
+
+	hfs_bnode_put(hfsplus_handle, node);
+	node = parent;
+
+	if (new_node) {
+		__be32 cnid;
+
+		fd->bnode = hfs_bnode_find(hfsplus_handle, tree, new_node->parent);
+		/* create index key and entry */
+		hfs_bnode_read_key(new_node, fd->search_key, 14);
+		cnid = cpu_to_be32(new_node->this);
+
+		__hfs_brec_find(fd->bnode, fd);
+		hfs_brec_insert(hfsplus_handle, fd, &cnid, sizeof(cnid));
+		hfs_bnode_put(hfsplus_handle, fd->bnode);
+		hfs_bnode_put(hfsplus_handle, new_node);
+
+		if (!rec) {
+			if (new_node == node)
+				goto out;
+			/* restore search_key */
+			hfs_bnode_read_key(node, fd->search_key, 14);
+		}
+	}
+
+	if (!rec && node->parent)
+		goto again;
+out:
+	fd->bnode = node;
+	return 0;
+}
+
+static int hfs_btree_inc_height(hfsplus_handle_t *hfsplus_handle, struct hfs_btree *tree)
+{
+	struct hfs_bnode *node, *new_node;
+	struct hfs_bnode_desc node_desc;
+	int key_size, rec;
+	__be32 cnid;
+
+	node = NULL;
+	if (tree->root) {
+		node = hfs_bnode_find(hfsplus_handle, tree, tree->root);
+		if (IS_ERR(node))
+			return PTR_ERR(node);
+	}
+	new_node = hfs_bmap_alloc(hfsplus_handle, tree);
+	if (IS_ERR(new_node)) {
+		hfs_bnode_put(hfsplus_handle, node);
+		return PTR_ERR(new_node);
+	}
+
+	tree->root = new_node->this;
+	if (!tree->depth) {
+		tree->leaf_head = tree->leaf_tail = new_node->this;
+		new_node->type = HFS_NODE_LEAF;
+		new_node->num_recs = 0;
+	} else {
+		new_node->type = HFS_NODE_INDEX;
+		new_node->num_recs = 1;
+	}
+	new_node->parent = 0;
+	new_node->next = 0;
+	new_node->prev = 0;
+	new_node->height = ++tree->depth;
+
+	node_desc.next = cpu_to_be32(new_node->next);
+	node_desc.prev = cpu_to_be32(new_node->prev);
+	node_desc.type = new_node->type;
+	node_desc.height = new_node->height;
+	node_desc.num_recs = cpu_to_be16(new_node->num_recs);
+	node_desc.reserved = 0;
+	hfs_bnode_write(hfsplus_handle, new_node, &node_desc, 0, sizeof(node_desc));
+
+	rec = tree->node_size - 2;
+	hfs_bnode_write_u16(hfsplus_handle, new_node, rec, 14);
+
+	if (node) {
+		/* insert old root idx into new root */
+		node->parent = tree->root;
+		if (node->type == HFS_NODE_LEAF ||
+		    tree->attributes & HFS_TREE_VARIDXKEYS)
+			key_size = hfs_bnode_read_u16(node, 14) + 2;
+		else
+			key_size = tree->max_key_len + 2;
+		hfs_bnode_copy(hfsplus_handle, new_node, 14, node, 14, key_size);
+
+		if (!(tree->attributes & HFS_TREE_VARIDXKEYS)) {
+			key_size = tree->max_key_len + 2;
+			hfs_bnode_write_u16(hfsplus_handle, new_node, 14, tree->max_key_len);
+		}
+		cnid = cpu_to_be32(node->this);
+		hfs_bnode_write(hfsplus_handle, new_node, &cnid, 14 + key_size, 4);
+
+		rec -= 2;
+		hfs_bnode_write_u16(hfsplus_handle, new_node, rec, 14 + key_size + 4);
+
+		hfs_bnode_put(hfsplus_handle, node);
+	}
+	hfs_bnode_put(hfsplus_handle, new_node);
+	if (hfsplus_journalled_mark_inode_dirty(__FUNCTION__, hfsplus_handle, tree->inode))
+		return -1;
+
+	return 0;
+}
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/btree.c linux-2.6.32/fs/hfsplus_journal/btree.c
--- linux-2.6.32-old//fs/hfsplus_journal/btree.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/btree.c	2011-11-17 09:00:40.778818402 -0500
@@ -0,0 +1,337 @@
+/*
+ *  linux/fs/hfsplus/btree.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handle opening/closing btree
+ */
+
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/log2.h>
+
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+
+/* Get a reference to a B*Tree and do some initial checks */
+struct hfs_btree *hfs_btree_open(struct super_block *sb, u32 id)
+{
+	struct hfs_btree *tree;
+	struct hfs_btree_header_rec *head;
+	struct address_space *mapping;
+	struct inode *inode;
+	struct page *page;
+	unsigned int size;
+
+	tree = kzalloc(sizeof(*tree), GFP_KERNEL);
+	if (!tree)
+		return NULL;
+
+	init_MUTEX(&tree->tree_lock);
+	spin_lock_init(&tree->hash_lock);
+	tree->sb = sb;
+	tree->cnid = id;
+	inode = hfsplus_iget(sb, id);
+	if (IS_ERR(inode)){
+		printk("HFS+-fs: B*Tree inode is NULL\n");
+		goto free_tree;
+	}
+	tree->inode = inode;
+
+	mapping = tree->inode->i_mapping;
+	page = read_mapping_page(mapping, 0, NULL);
+	if (IS_ERR(page)){
+		printk("HFS+-fs: Error in reading page of B*Tree\n");
+		goto free_tree;
+	}
+
+	/* Load the header */
+	head = (struct hfs_btree_header_rec *)(kmap(page) + sizeof(struct hfs_bnode_desc));
+	tree->root = be32_to_cpu(head->root);
+	tree->leaf_count = be32_to_cpu(head->leaf_count);
+	tree->leaf_head = be32_to_cpu(head->leaf_head);
+	tree->leaf_tail = be32_to_cpu(head->leaf_tail);
+	tree->node_count = be32_to_cpu(head->node_count);
+	tree->free_nodes = be32_to_cpu(head->free_nodes);
+	tree->attributes = be32_to_cpu(head->attributes);
+	tree->node_size = be16_to_cpu(head->node_size);
+	tree->max_key_len = be16_to_cpu(head->max_key_len);
+	tree->depth = be16_to_cpu(head->depth);
+
+	/* Set the correct compare function */
+	if (id == HFSPLUS_EXT_CNID) {
+		tree->keycmp = hfsplus_ext_cmp_key;
+	} else if (id == HFSPLUS_CAT_CNID) {
+		if ((HFSPLUS_SB(sb).flags & HFSPLUS_SB_HFSX) &&
+		    (head->key_type == HFSPLUS_KEY_BINARY))
+			tree->keycmp = hfsplus_cat_bin_cmp_key;
+		else {
+			tree->keycmp = hfsplus_cat_case_cmp_key;
+			HFSPLUS_SB(sb).flags |= HFSPLUS_SB_CASEFOLD;
+		}
+	} else {
+		printk(KERN_ERR "hfs: unknown B*Tree requested\n");
+		goto fail_page;
+	}
+
+	size = tree->node_size;
+	if (!is_power_of_2(size)){
+		printk("HFS+-fs: Error in B*Tree node sise\n");
+		goto fail_page;
+	}
+	if (!tree->node_count){
+		printk("HFS+-fs: Error in B*Tree node count zero\n");
+		goto fail_page;
+	}
+	tree->node_size_shift = ffs(size) - 1;
+
+	tree->pages_per_bnode = (tree->node_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
+
+	kunmap(page);
+	page_cache_release(page);
+	return tree;
+
+ fail_page:
+	tree->inode->i_mapping->a_ops = &hfsplus_aops;
+	page_cache_release(page);
+ free_tree:
+	iput(tree->inode);
+	kfree(tree);
+	return NULL;
+}
+
+/* Release resources used by a btree */
+void hfs_btree_close(struct hfs_btree *tree)
+{
+	struct hfs_bnode *node;
+	int i;
+
+	if (!tree)
+		return;
+
+	for (i = 0; i < NODE_HASH_SIZE; i++) {
+		while ((node = tree->node_hash[i])) {
+			tree->node_hash[i] = node->next_hash;
+			if (atomic_read(&node->refcnt))
+				printk(KERN_CRIT "hfs: node %d:%d still has %d user(s)!\n",
+					node->tree->cnid, node->this, atomic_read(&node->refcnt));
+			hfs_bnode_free(node);
+			tree->node_hash_cnt--;
+		}
+	}
+	iput(tree->inode);
+	kfree(tree);
+}
+
+void hfs_btree_write(hfsplus_handle_t *hfsplus_handle, struct hfs_btree *tree)
+{
+	struct hfs_btree_header_rec *head;
+	struct hfs_bnode *node;
+	struct page *page;
+
+	node = hfs_bnode_find(hfsplus_handle, tree, 0);
+	if (IS_ERR(node))
+		/* panic? */
+		return;
+	/* Load the header */
+	page = node->page[0];
+	head = (struct hfs_btree_header_rec *)(kmap(page) + sizeof(struct hfs_bnode_desc));
+
+	head->root = cpu_to_be32(tree->root);
+	head->leaf_count = cpu_to_be32(tree->leaf_count);
+	head->leaf_head = cpu_to_be32(tree->leaf_head);
+	head->leaf_tail = cpu_to_be32(tree->leaf_tail);
+	head->node_count = cpu_to_be32(tree->node_count);
+	head->free_nodes = cpu_to_be32(tree->free_nodes);
+	head->attributes = cpu_to_be32(tree->attributes);
+	head->depth = cpu_to_be16(tree->depth);
+
+	kunmap(page);
+	hfsplus_journalled_set_page_dirty(hfsplus_handle, page);
+	hfs_bnode_put(hfsplus_handle, node);
+}
+
+static struct hfs_bnode *hfs_bmap_new_bmap(hfsplus_handle_t *hfsplus_handle, struct hfs_bnode *prev, u32 idx)
+{
+	struct hfs_btree *tree = prev->tree;
+	struct hfs_bnode *node;
+	struct hfs_bnode_desc desc;
+	__be32 cnid;
+
+	node = hfs_bnode_create(hfsplus_handle, tree, idx);
+	if (IS_ERR(node))
+		return node;
+
+	tree->free_nodes--;
+	prev->next = idx;
+	cnid = cpu_to_be32(idx);
+	hfs_bnode_write(hfsplus_handle, prev, &cnid, offsetof(struct hfs_bnode_desc, next), 4);
+
+	node->type = HFS_NODE_MAP;
+	node->num_recs = 1;
+	hfs_bnode_clear(hfsplus_handle, node, 0, tree->node_size);
+	desc.next = 0;
+	desc.prev = 0;
+	desc.type = HFS_NODE_MAP;
+	desc.height = 0;
+	desc.num_recs = cpu_to_be16(1);
+	desc.reserved = 0;
+	hfs_bnode_write(hfsplus_handle, node, &desc, 0, sizeof(desc));
+	hfs_bnode_write_u16(hfsplus_handle, node, 14, 0x8000);
+	hfs_bnode_write_u16(hfsplus_handle, node, tree->node_size - 2, 14);
+	hfs_bnode_write_u16(hfsplus_handle, node, tree->node_size - 4, tree->node_size - 6);
+
+	return node;
+}
+
+struct hfs_bnode *hfs_bmap_alloc(hfsplus_handle_t *hfsplus_handle, struct hfs_btree *tree)
+{
+	struct hfs_bnode *node, *next_node;
+	struct page **pagep;
+	u32 nidx, idx;
+	unsigned off;
+	u16 off16;
+	u16 len;
+	u8 *data, byte, m;
+	int i;
+
+	while (!tree->free_nodes) {
+		struct inode *inode = tree->inode;
+		u32 count;
+		int res;
+
+		res = hfsplus_file_extend(hfsplus_handle, inode);
+		if (res)
+			return ERR_PTR(res);
+		HFSPLUS_I(inode).phys_size = inode->i_size =
+				(loff_t)HFSPLUS_I(inode).alloc_blocks <<
+				HFSPLUS_SB(tree->sb).alloc_blksz_shift;
+		HFSPLUS_I(inode).fs_blocks = HFSPLUS_I(inode).alloc_blocks <<
+					     HFSPLUS_SB(tree->sb).fs_shift;
+		inode_set_bytes(inode, inode->i_size);
+		count = inode->i_size >> tree->node_size_shift;
+		tree->free_nodes = count - tree->node_count;
+		tree->node_count = count;
+	}
+
+	nidx = 0;
+	node = hfs_bnode_find(hfsplus_handle, tree, nidx);
+	if (IS_ERR(node))
+		return node;
+	len = hfs_brec_lenoff(node, 2, &off16);
+	off = off16;
+
+	off += node->page_offset;
+	pagep = node->page + (off >> PAGE_CACHE_SHIFT);
+	data = kmap(*pagep);
+	off &= ~PAGE_CACHE_MASK;
+	idx = 0;
+
+	for (;;) {
+		while (len) {
+			byte = data[off];
+			if (byte != 0xff) {
+				for (m = 0x80, i = 0; i < 8; m >>= 1, i++) {
+					if (!(byte & m)) {
+						idx += i;
+						data[off] |= m;
+						hfsplus_journalled_set_page_dirty(hfsplus_handle, *pagep);
+						kunmap(*pagep);
+						tree->free_nodes--;
+						if (hfsplus_journalled_mark_inode_dirty(__FUNCTION__, hfsplus_handle, tree->inode))
+							return NULL;
+						hfs_bnode_put(hfsplus_handle, node);
+						return hfs_bnode_create(hfsplus_handle, tree, idx);
+					}
+				}
+			}
+			if (++off >= PAGE_CACHE_SIZE) {
+				kunmap(*pagep);
+				data = kmap(*++pagep);
+				off = 0;
+			}
+			idx += 8;
+			len--;
+		}
+		kunmap(*pagep);
+		nidx = node->next;
+		if (!nidx) {
+			printk(KERN_DEBUG "hfs: create new bmap node...\n");
+			next_node = hfs_bmap_new_bmap(hfsplus_handle, node, idx);
+		} else
+			next_node = hfs_bnode_find(hfsplus_handle, tree, nidx);
+		hfs_bnode_put(hfsplus_handle, node);
+		if (IS_ERR(next_node))
+			return next_node;
+		node = next_node;
+
+		len = hfs_brec_lenoff(node, 0, &off16);
+		off = off16;
+		off += node->page_offset;
+		pagep = node->page + (off >> PAGE_CACHE_SHIFT);
+		data = kmap(*pagep);
+		off &= ~PAGE_CACHE_MASK;
+	}
+}
+
+void hfs_bmap_free(hfsplus_handle_t *hfsplus_handle, struct hfs_bnode *node)
+{
+	struct hfs_btree *tree;
+	struct page *page;
+	u16 off, len;
+	u32 nidx;
+	u8 *data, byte, m;
+
+	dprint(DBG_BNODE_MOD, "btree_free_node: %u\n", node->this);
+	BUG_ON(!node->this);
+	tree = node->tree;
+	nidx = node->this;
+	node = hfs_bnode_find(hfsplus_handle, tree, 0);
+	if (IS_ERR(node))
+		return;
+	len = hfs_brec_lenoff(node, 2, &off);
+	while (nidx >= len * 8) {
+		u32 i;
+
+		nidx -= len * 8;
+		i = node->next;
+		hfs_bnode_put(hfsplus_handle, node);
+		if (!i) {
+			/* panic */;
+			printk(KERN_CRIT "hfs: unable to free bnode %u. bmap not found!\n", node->this);
+			return;
+		}
+		node = hfs_bnode_find(hfsplus_handle, tree, i);
+		if (IS_ERR(node))
+			return;
+		if (node->type != HFS_NODE_MAP) {
+			/* panic */;
+			printk(KERN_CRIT "hfs: invalid bmap found! (%u,%d)\n", node->this, node->type);
+			hfs_bnode_put(hfsplus_handle, node);
+			return;
+		}
+		len = hfs_brec_lenoff(node, 0, &off);
+	}
+	off += node->page_offset + nidx / 8;
+	page = node->page[off >> PAGE_CACHE_SHIFT];
+	data = kmap(page);
+	off &= ~PAGE_CACHE_MASK;
+	m = 1 << (~nidx & 7);
+	byte = data[off];
+	if (!(byte & m)) {
+		printk(KERN_CRIT "hfs: trying to free free bnode %u(%d)\n", node->this, node->type);
+		kunmap(page);
+		hfs_bnode_put(hfsplus_handle, node);
+		return;
+	}
+	data[off] = byte & ~m;
+	hfsplus_journalled_set_page_dirty(hfsplus_handle, page);
+	kunmap(page);
+	hfs_bnode_put(hfsplus_handle, node);
+	tree->free_nodes++;
+	if (hfsplus_journalled_mark_inode_dirty(__FUNCTION__, hfsplus_handle, tree->inode))
+		return;
+}
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/catalog.c linux-2.6.32/fs/hfsplus_journal/catalog.c
--- linux-2.6.32-old//fs/hfsplus_journal/catalog.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/catalog.c	2011-11-17 09:00:40.778818402 -0500
@@ -0,0 +1,398 @@
+/*
+ *  linux/fs/hfsplus/catalog.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handling of catalog records
+ */
+
+#include <linux/sched.h>
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+int hfsplus_cat_case_cmp_key(const hfsplus_btree_key *k1,
+			     const hfsplus_btree_key *k2)
+{
+	__be32 k1p, k2p;
+
+	k1p = k1->cat.parent;
+	k2p = k2->cat.parent;
+	if (k1p != k2p)
+		return be32_to_cpu(k1p) < be32_to_cpu(k2p) ? -1 : 1;
+
+	return hfsplus_strcasecmp(&k1->cat.name, &k2->cat.name);
+}
+
+int hfsplus_cat_bin_cmp_key(const hfsplus_btree_key *k1,
+			    const hfsplus_btree_key *k2)
+{
+	__be32 k1p, k2p;
+
+	k1p = k1->cat.parent;
+	k2p = k2->cat.parent;
+	if (k1p != k2p)
+		return be32_to_cpu(k1p) < be32_to_cpu(k2p) ? -1 : 1;
+
+	return hfsplus_strcmp(&k1->cat.name, &k2->cat.name);
+}
+
+void hfsplus_cat_build_key(struct super_block *sb, hfsplus_btree_key *key,
+			   u32 parent, struct qstr *str)
+{
+	int len;
+
+	key->cat.parent = cpu_to_be32(parent);
+	if (str) {
+		hfsplus_asc2uni(sb, &key->cat.name, str->name, str->len);
+		len = be16_to_cpu(key->cat.name.length);
+	} else {
+		key->cat.name.length = 0;
+		len = 0;
+	}
+	key->key_len = cpu_to_be16(6 + 2 * len);
+}
+
+static void hfsplus_cat_build_key_uni(hfsplus_btree_key *key, u32 parent,
+				      struct hfsplus_unistr *name)
+{
+	int ustrlen;
+
+	ustrlen = be16_to_cpu(name->length);
+	key->cat.parent = cpu_to_be32(parent);
+	key->cat.name.length = cpu_to_be16(ustrlen);
+	ustrlen *= 2;
+	memcpy(key->cat.name.unicode, name->unicode, ustrlen);
+	key->key_len = cpu_to_be16(6 + ustrlen);
+}
+
+static void hfsplus_set_perms(struct inode *inode, struct hfsplus_perm *perms)
+{
+	if (inode->i_flags & S_IMMUTABLE)
+		perms->rootflags |= HFSPLUS_FLG_IMMUTABLE;
+	else
+		perms->rootflags &= ~HFSPLUS_FLG_IMMUTABLE;
+	if (inode->i_flags & S_APPEND)
+		perms->rootflags |= HFSPLUS_FLG_APPEND;
+	else
+		perms->rootflags &= ~HFSPLUS_FLG_APPEND;
+	HFSPLUS_I(inode).rootflags = perms->rootflags;
+	HFSPLUS_I(inode).userflags = perms->userflags;
+	perms->mode = cpu_to_be16(inode->i_mode);
+	perms->owner = cpu_to_be32(inode->i_uid);
+	perms->group = cpu_to_be32(inode->i_gid);
+}
+
+static int hfsplus_cat_build_record(hfsplus_cat_entry *entry, u32 cnid, struct inode *inode)
+{
+	if (S_ISDIR(inode->i_mode)) {
+		struct hfsplus_cat_folder *folder;
+
+		folder = &entry->folder;
+		memset(folder, 0, sizeof(*folder));
+		folder->type = cpu_to_be16(HFSPLUS_FOLDER);
+		folder->id = cpu_to_be32(inode->i_ino);
+		HFSPLUS_I(inode).create_date =
+			folder->create_date =
+			folder->content_mod_date =
+			folder->attribute_mod_date =
+			folder->access_date = hfsp_now2mt();
+		hfsplus_set_perms(inode, &folder->permissions);
+		if (inode == HFSPLUS_SB(inode->i_sb).hidden_dir)
+			/* invisible and namelocked */
+			folder->user_info.frFlags = cpu_to_be16(0x5000);
+		return sizeof(*folder);
+	} else {
+		struct hfsplus_cat_file *file;
+
+		file = &entry->file;
+		memset(file, 0, sizeof(*file));
+		file->type = cpu_to_be16(HFSPLUS_FILE);
+		file->flags = cpu_to_be16(HFSPLUS_FILE_THREAD_EXISTS);
+		file->id = cpu_to_be32(cnid);
+		HFSPLUS_I(inode).create_date =
+			file->create_date =
+			file->content_mod_date =
+			file->attribute_mod_date =
+			file->access_date = hfsp_now2mt();
+		if (cnid == inode->i_ino) {
+			hfsplus_set_perms(inode, &file->permissions);
+			if (S_ISLNK(inode->i_mode)) {
+				file->user_info.fdType = cpu_to_be32(HFSP_SYMLINK_TYPE);
+				file->user_info.fdCreator = cpu_to_be32(HFSP_SYMLINK_CREATOR);
+			} else {
+				file->user_info.fdType = cpu_to_be32(HFSPLUS_SB(inode->i_sb).type);
+				file->user_info.fdCreator = cpu_to_be32(HFSPLUS_SB(inode->i_sb).creator);
+			}
+			if ((file->permissions.rootflags | file->permissions.userflags) & HFSPLUS_FLG_IMMUTABLE)
+				file->flags |= cpu_to_be16(HFSPLUS_FILE_LOCKED);
+		} else {
+			file->user_info.fdType = cpu_to_be32(HFSP_HARDLINK_TYPE);
+			file->user_info.fdCreator = cpu_to_be32(HFSP_HFSPLUS_CREATOR);
+			file->user_info.fdFlags = cpu_to_be16(0x100);
+			file->create_date = HFSPLUS_I(HFSPLUS_SB(inode->i_sb).hidden_dir).create_date;
+			file->permissions.dev = cpu_to_be32(HFSPLUS_I(inode).dev);
+		}
+		return sizeof(*file);
+	}
+}
+
+static int hfsplus_fill_cat_thread(struct super_block *sb,
+				   hfsplus_cat_entry *entry, int type,
+				   u32 parentid, struct qstr *str)
+{
+	entry->type = cpu_to_be16(type);
+	entry->thread.reserved = 0;
+	entry->thread.parentID = cpu_to_be32(parentid);
+	hfsplus_asc2uni(sb, &entry->thread.nodeName, str->name, str->len);
+	return 10 + be16_to_cpu(entry->thread.nodeName.length) * 2;
+}
+
+/* Try to get a catalog entry for given catalog id */
+int hfsplus_find_cat(hfsplus_handle_t *hfsplus_handle, struct super_block *sb, u32 cnid,
+		     struct hfs_find_data *fd)
+{
+	hfsplus_cat_entry tmp;
+	int err;
+	u16 type;
+
+	hfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);
+	err = hfs_brec_read(hfsplus_handle, fd, &tmp, sizeof(hfsplus_cat_entry));
+	if (err)
+		return err;
+
+	type = be16_to_cpu(tmp.type);
+	if (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {
+		printk(KERN_ERR "hfs: found bad thread record in catalog\n");
+		return -EIO;
+	}
+
+	if (be16_to_cpu(tmp.thread.nodeName.length) > 255) {
+		printk(KERN_ERR "hfs: catalog name length corrupted\n");
+		return -EIO;
+	}
+
+	hfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),
+				 &tmp.thread.nodeName);
+	return hfs_brec_find(hfsplus_handle, fd);
+}
+
+int hfsplus_create_cat(hfsplus_handle_t *hfsplus_handle, u32 cnid, struct inode *dir, struct qstr *str, struct inode *inode)
+{
+	struct hfs_find_data fd;
+	struct super_block *sb;
+	hfsplus_cat_entry entry;
+	int entry_size;
+	int err;
+
+	dprint(DBG_CAT_MOD, "create_cat: %s,%u(%d)\n", str->name, cnid, inode->i_nlink);
+	sb = dir->i_sb;
+	hfs_find_init(HFSPLUS_SB(sb).cat_tree, &fd);
+
+	hfsplus_cat_build_key(sb, fd.search_key, cnid, NULL);
+	entry_size = hfsplus_fill_cat_thread(sb, &entry, S_ISDIR(inode->i_mode) ?
+			HFSPLUS_FOLDER_THREAD : HFSPLUS_FILE_THREAD,
+			dir->i_ino, str);
+	err = hfs_brec_find(hfsplus_handle, &fd);
+	if (err != -ENOENT) {
+		if (!err)
+			err = -EEXIST;
+		goto err2;
+	}
+	err = hfs_brec_insert(hfsplus_handle, &fd, &entry, entry_size);
+	if (err)
+		goto err2;
+
+	hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);
+	entry_size = hfsplus_cat_build_record(&entry, cnid, inode);
+	err = hfs_brec_find(hfsplus_handle, &fd);
+	if (err != -ENOENT) {
+		/* panic? */
+		if (!err)
+			err = -EEXIST;
+		goto err1;
+	}
+	err = hfs_brec_insert(hfsplus_handle, &fd, &entry, entry_size);
+	if (err)
+		goto err1;
+
+	dir->i_size++;
+	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
+	if (hfsplus_journalled_mark_inode_dirty(__FUNCTION__, hfsplus_handle, dir)) {
+		err = -1;
+		goto err2;
+	}
+	hfs_find_exit(hfsplus_handle, &fd);
+	return 0;
+
+err1:
+	hfsplus_cat_build_key(sb, fd.search_key, cnid, NULL);
+	if (!hfs_brec_find(hfsplus_handle, &fd))
+		hfs_brec_remove(hfsplus_handle, &fd);
+err2:
+	hfs_find_exit(hfsplus_handle, &fd);
+	return err;
+}
+
+int hfsplus_delete_cat(hfsplus_handle_t *hfsplus_handle, u32 cnid, struct inode *dir, struct qstr *str)
+{
+	struct super_block *sb;
+	struct hfs_find_data fd;
+	struct hfsplus_fork_raw fork;
+	struct list_head *pos;
+	int err, off;
+	u16 type;
+
+	dprint(DBG_CAT_MOD, "delete_cat: %s,%u\n", str ? str->name : NULL, cnid);
+	sb = dir->i_sb;
+	hfs_find_init(HFSPLUS_SB(sb).cat_tree, &fd);
+
+	if (!str) {
+		int len;
+
+		hfsplus_cat_build_key(sb, fd.search_key, cnid, NULL);
+		err = hfs_brec_find(hfsplus_handle, &fd);
+		if (err)
+			goto out;
+
+		off = fd.entryoffset + offsetof(struct hfsplus_cat_thread, nodeName);
+		fd.search_key->cat.parent = cpu_to_be32(dir->i_ino);
+		hfs_bnode_read(fd.bnode, &fd.search_key->cat.name.length, off, 2);
+		len = be16_to_cpu(fd.search_key->cat.name.length) * 2;
+		hfs_bnode_read(fd.bnode, &fd.search_key->cat.name.unicode, off + 2, len);
+		fd.search_key->key_len = cpu_to_be16(6 + len);
+	} else
+		hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);
+
+	err = hfs_brec_find(hfsplus_handle, &fd);
+	if (err)
+		goto out;
+
+	type = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);
+	if (type == HFSPLUS_FILE) {
+#if 0
+		off = fd.entryoffset + offsetof(hfsplus_cat_file, data_fork);
+		hfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));
+		hfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_DATA);
+#endif
+
+		off = fd.entryoffset + offsetof(struct hfsplus_cat_file, rsrc_fork);
+		hfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));
+		hfsplus_free_fork(hfsplus_handle, sb, cnid, &fork, HFSPLUS_TYPE_RSRC);
+	}
+
+	list_for_each(pos, &HFSPLUS_I(dir).open_dir_list) {
+		struct hfsplus_readdir_data *rd =
+			list_entry(pos, struct hfsplus_readdir_data, list);
+		if (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)
+			rd->file->f_pos--;
+	}
+
+	err = hfs_brec_remove(hfsplus_handle, &fd);
+	if (err)
+		goto out;
+
+	hfsplus_cat_build_key(sb, fd.search_key, cnid, NULL);
+	err = hfs_brec_find(hfsplus_handle, &fd);
+	if (err)
+		goto out;
+
+	err = hfs_brec_remove(hfsplus_handle, &fd);
+	if (err)
+		goto out;
+
+	dir->i_size--;
+	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
+	if (hfsplus_journalled_mark_inode_dirty(__FUNCTION__, hfsplus_handle, dir))
+		err = -1;
+out:
+	hfs_find_exit(hfsplus_handle, &fd);
+
+	return err;
+}
+
+int hfsplus_rename_cat(hfsplus_handle_t *hfsplus_handle, u32 cnid,
+		       struct inode *src_dir, struct qstr *src_name,
+		       struct inode *dst_dir, struct qstr *dst_name)
+{
+	struct super_block *sb;
+	struct hfs_find_data src_fd, dst_fd;
+	hfsplus_cat_entry entry;
+	int entry_size, type;
+	int err = 0;
+
+	dprint(DBG_CAT_MOD, "rename_cat: %u - %lu,%s - %lu,%s\n", cnid, src_dir->i_ino, src_name->name,
+		dst_dir->i_ino, dst_name->name);
+	sb = src_dir->i_sb;
+	hfs_find_init(HFSPLUS_SB(sb).cat_tree, &src_fd);
+	dst_fd = src_fd;
+
+	/* find the old dir entry and read the data */
+	hfsplus_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);
+	err = hfs_brec_find(hfsplus_handle, &src_fd);
+	if (err)
+		goto out;
+
+	hfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,
+				src_fd.entrylength);
+
+	/* create new dir entry with the data from the old entry */
+	hfsplus_cat_build_key(sb, dst_fd.search_key, dst_dir->i_ino, dst_name);
+	err = hfs_brec_find(hfsplus_handle, &dst_fd);
+	if (err != -ENOENT) {
+		if (!err)
+			err = -EEXIST;
+		goto out;
+	}
+
+	err = hfs_brec_insert(hfsplus_handle, &dst_fd, &entry, src_fd.entrylength);
+	if (err)
+		goto out;
+	dst_dir->i_size++;
+	dst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;
+	if (hfsplus_journalled_mark_inode_dirty(__FUNCTION__, hfsplus_handle, dst_dir)) {
+		err = -1;
+		goto out;
+	}
+
+	/* finally remove the old entry */
+	hfsplus_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);
+	err = hfs_brec_find(hfsplus_handle, &src_fd);
+	if (err)
+		goto out;
+	err = hfs_brec_remove(hfsplus_handle, &src_fd);
+	if (err)
+		goto out;
+	src_dir->i_size--;
+	src_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;
+	if (hfsplus_journalled_mark_inode_dirty(__FUNCTION__, hfsplus_handle, src_dir)) {
+		err = -1;
+		goto out;
+	}
+
+	/* remove old thread entry */
+	hfsplus_cat_build_key(sb, src_fd.search_key, cnid, NULL);
+	err = hfs_brec_find(hfsplus_handle, &src_fd);
+	if (err)
+		goto out;
+	type = hfs_bnode_read_u16(src_fd.bnode, src_fd.entryoffset);
+	err = hfs_brec_remove(hfsplus_handle, &src_fd);
+	if (err)
+		goto out;
+
+	/* create new thread entry */
+	hfsplus_cat_build_key(sb, dst_fd.search_key, cnid, NULL);
+	entry_size = hfsplus_fill_cat_thread(sb, &entry, type, dst_dir->i_ino, dst_name);
+	err = hfs_brec_find(hfsplus_handle, &dst_fd);
+	if (err != -ENOENT) {
+		if (!err)
+			err = -EEXIST;
+		goto out;
+	}
+	err = hfs_brec_insert(hfsplus_handle, &dst_fd, &entry, entry_size);
+out:
+	hfs_bnode_put(hfsplus_handle, dst_fd.bnode);
+	hfs_find_exit(hfsplus_handle, &src_fd);
+	return err;
+}
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/checkpoint.c linux-2.6.32/fs/hfsplus_journal/checkpoint.c
--- linux-2.6.32-old//fs/hfsplus_journal/checkpoint.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/checkpoint.c	2011-11-17 09:00:40.778818402 -0500
@@ -0,0 +1,758 @@
+/*
+ * linux/fs/checkpoint.c
+ * 
+ * Written by Stephen C. Tweedie <sct@redhat.com>, 1999
+ *
+ * Copyright 1999 Red Hat Software --- All Rights Reserved
+ *
+ * This file is part of the Linux kernel and is made available under
+ * the terms of the GNU General Public License, version 2, or at your
+ * option, any later version, incorporated herein by reference.
+ *
+ * Checkpoint routines for the generic filesystem journaling code.  
+ * Part of the ext2fs journaling system.  
+ *
+ * Checkpointing is the process of ensuring that a section of the log is
+ * committed fully to disk, so that that portion of the log can be
+ * reused.
+ */
+
+#include <linux/time.h>
+#include <linux/fs.h>
+#include "hfsplus_jbd.h"
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include "hfsplus_fs.h"
+
+/*
+ * Unlink a buffer from a transaction checkpoint list.
+ *
+ * Called with j_list_lock held.
+ */
+static inline void __buffer_unlink_first(struct hfsplus_jbd_head *jh)
+{
+	hfsplus_transaction_t *transaction = jh->b_cp_transaction;
+
+	jh->b_cpnext->b_cpprev = jh->b_cpprev;
+	jh->b_cpprev->b_cpnext = jh->b_cpnext;
+	if (transaction->t_checkpoint_list == jh) {
+		transaction->t_checkpoint_list = jh->b_cpnext;
+		if (transaction->t_checkpoint_list == jh)
+			transaction->t_checkpoint_list = NULL;
+	}
+}
+
+/*
+ * Unlink a buffer from a transaction checkpoint(io) list.
+ *
+ * Called with j_list_lock held.
+ */
+static inline void __buffer_unlink(struct hfsplus_jbd_head *jh)
+{
+	hfsplus_transaction_t *transaction = jh->b_cp_transaction;
+
+	__buffer_unlink_first(jh);
+	if (transaction->t_checkpoint_io_list == jh) {
+		transaction->t_checkpoint_io_list = jh->b_cpnext;
+		if (transaction->t_checkpoint_io_list == jh)
+			transaction->t_checkpoint_io_list = NULL;
+	}
+}
+
+/*
+ * Move a buffer from the checkpoint list to the checkpoint io list
+ *
+ * Called with j_list_lock held
+ */
+static inline void __buffer_relink_io(struct hfsplus_jbd_head *jh)
+{
+	hfsplus_transaction_t *transaction = jh->b_cp_transaction;
+
+	__buffer_unlink_first(jh);
+
+	if (!transaction->t_checkpoint_io_list) {
+		jh->b_cpnext = jh->b_cpprev = jh;
+	} else {
+		jh->b_cpnext = transaction->t_checkpoint_io_list;
+		jh->b_cpprev = transaction->t_checkpoint_io_list->b_cpprev;
+		jh->b_cpprev->b_cpnext = jh;
+		jh->b_cpnext->b_cpprev = jh;
+	}
+	transaction->t_checkpoint_io_list = jh;
+}
+
+/*
+ * Try to release a checkpointed buffer from its transaction.
+ * Returns 1 if we released it and 2 if we also released the
+ * whole transaction.
+ *
+ * Requires j_list_lock
+ * Called under hfsplus_jbd_lock_bh_state(hfsplus_jh2bh(jh)), and drops it
+ */
+static int __try_to_free_cp_buf(struct hfsplus_jbd_head *jh)
+{
+	int ret = 0;
+	struct buffer_head *bh = hfsplus_jh2bh(jh);
+
+	if (jh->b_jlist == HFSPLUS_BJ_None && !buffer_locked(bh) &&
+	    !buffer_dirty(bh) && !buffer_write_io_error(bh)) {
+		HFSPLUS_JBUFFER_TRACE(jh, "remove from checkpoint list");
+		ret = __hfsplus_jbd_remove_checkpoint(jh) + 1;
+		hfsplus_jbd_unlock_bh_state(bh);
+		hfsplus_jbd_remove_journal_head(bh);
+		HFSPLUS_BUFFER_TRACE(bh, "release");
+		__brelse(bh);
+	} else {
+		hfsplus_jbd_unlock_bh_state(bh);
+	}
+	return ret;
+}
+
+/*
+ * __hfsplus__log_wait_for_space: wait until there is space in the journal.
+ *
+ * Called under j-state_lock *only*.  It will be unlocked if we have to wait
+ * for a checkpoint to free up some space in the log.
+ */
+void __hfsplus__log_wait_for_space(hfsplus_jbd_t *journal)
+{
+	int nblocks, space_left;
+	assert_spin_locked(&journal->j_state_lock);
+
+	nblocks = hfsplus_jbd_space_needed(journal);
+	while (__hfsplus__log_space_left(journal) < nblocks) {
+		if (journal->j_flags & JFS_ABORT)
+			return;
+		spin_unlock(&journal->j_state_lock);
+		mutex_lock(&journal->j_checkpoint_mutex);
+
+		/*
+		 * Test again, another process may have checkpointed while we
+		 * were waiting for the checkpoint lock. If there are no
+		 * transactions ready to be checkpointed, try to recover
+		 * journal space by calling cleanup_hfsplus_jbd_tail(), and if
+		 * that doesn't work, by waiting for the currently committing
+		 * transaction to complete.  If there is absolutely no way
+		 * to make progress, this is either a BUG or corrupted
+		 * filesystem, so abort the journal and leave a stack
+		 * trace for forensic evidence.
+		 */
+		spin_lock(&journal->j_state_lock);
+		spin_lock(&journal->j_list_lock);
+		nblocks = hfsplus_jbd_space_needed(journal);
+		space_left = __hfsplus__log_space_left(journal);
+		if (space_left < nblocks) {
+			int chkpt = journal->j_checkpoint_transactions != NULL;
+			hfsplus_jbd_tid_t tid = 0;
+
+			if (journal->j_committing_transaction)
+				tid = journal->j_committing_transaction->t_tid;
+			spin_unlock(&journal->j_list_lock);
+			spin_unlock(&journal->j_state_lock);
+			if (chkpt) {
+				hfsplus_jbd_log_do_checkpoint(journal);
+			} else if (cleanup_hfsplus_jbd_tail(journal) == 0) {
+				/* We were able to recover space; yay! */
+				;
+			} else if (tid) {
+				hfsplus_jbd_log_wait_commit(journal, tid);
+			} else {
+				printk(KERN_ERR "%s: needed %d blocks and "
+				       "only had %d space available\n",
+				       __func__, nblocks, space_left);
+				printk(KERN_ERR "%s: no way to get more "
+				       "journal space\n", __func__);
+				WARN_ON(1);
+				hfsplus_jbd_abort(journal, 0);
+			}
+			spin_lock(&journal->j_state_lock);
+		} else {
+			spin_unlock(&journal->j_list_lock);
+		}
+		mutex_unlock(&journal->j_checkpoint_mutex);
+	}
+}
+
+/*
+ * We were unable to perform hfsplus_jbd_trylock_bh_state() inside j_list_lock.
+ * The caller must restart a list walk.  Wait for someone else to run
+ * hfsplus_jbd_unlock_bh_state().
+ */
+static void jbd_sync_bh(hfsplus_jbd_t *journal, struct buffer_head *bh)
+	__releases(journal->j_list_lock)
+{
+	get_bh(bh);
+	spin_unlock(&journal->j_list_lock);
+	hfsplus_jbd_lock_bh_state(bh);
+	hfsplus_jbd_unlock_bh_state(bh);
+	put_bh(bh);
+}
+
+/*
+ * Clean up transaction's list of buffers submitted for io.
+ * We wait for any pending IO to complete and remove any clean
+ * buffers. Note that we take the buffers in the opposite ordering
+ * from the one in which they were submitted for IO.
+ *
+ * Return 0 on success, and return <0 if some buffers have failed
+ * to be written out.
+ *
+ * Called with j_list_lock held.
+ */
+static int __wait_cp_io(hfsplus_jbd_t *journal, hfsplus_transaction_t *transaction)
+{
+	struct hfsplus_jbd_head *jh;
+	struct buffer_head *bh;
+	hfsplus_jbd_tid_t this_tid;
+	int released = 0;
+	int ret = 0;
+
+	this_tid = transaction->t_tid;
+restart:
+	/* Did somebody clean up the transaction in the meanwhile? */
+	if (journal->j_checkpoint_transactions != transaction ||
+			transaction->t_tid != this_tid)
+		return ret;
+	while (!released && transaction->t_checkpoint_io_list) {
+		jh = transaction->t_checkpoint_io_list;
+		bh = hfsplus_jh2bh(jh);
+		if (!hfsplus_jbd_trylock_bh_state(bh)) {
+			jbd_sync_bh(journal, bh);
+			spin_lock(&journal->j_list_lock);
+			goto restart;
+		}
+		if (buffer_locked(bh)) {
+			atomic_inc(&bh->b_count);
+			spin_unlock(&journal->j_list_lock);
+			hfsplus_jbd_unlock_bh_state(bh);
+			wait_on_buffer(bh);
+			/* the hfsplus_jbd_head may have gone by now */
+			HFSPLUS_BUFFER_TRACE(bh, "brelse");
+			__brelse(bh);
+			spin_lock(&journal->j_list_lock);
+			goto restart;
+		}
+		if (unlikely(buffer_write_io_error(bh)))
+			ret = -EIO;
+
+		/*
+		 * Now in whatever state the buffer currently is, we know that
+		 * it has been written out and so we can drop it from the list
+		 */
+		released = __hfsplus_jbd_remove_checkpoint(jh);
+		hfsplus_jbd_unlock_bh_state(bh);
+		hfsplus_jbd_remove_journal_head(bh);
+		__brelse(bh);
+	}
+
+	return ret;
+}
+
+#define NR_BATCH	64
+
+static void
+__flush_batch(hfsplus_jbd_t *journal, struct buffer_head **bhs, int *batch_count)
+{
+	int i;
+
+	ll_rw_block(SWRITE, *batch_count, bhs);
+	for (i = 0; i < *batch_count; i++) {
+		struct buffer_head *bh = bhs[i];
+		clear_buffer_hfsplus_jbd_jwrite(bh);
+		HFSPLUS_BUFFER_TRACE(bh, "brelse");
+		__brelse(bh);
+	}
+	*batch_count = 0;
+}
+
+/*
+ * Try to flush one buffer from the checkpoint list to disk.
+ *
+ * Return 1 if something happened which requires us to abort the current
+ * scan of the checkpoint list.  Return <0 if the buffer has failed to
+ * be written out.
+ *
+ * Called with j_list_lock held and drops it if 1 is returned
+ * Called under hfsplus_jbd_lock_bh_state(hfsplus_jh2bh(jh)), and drops it
+ */
+static int __process_buffer(hfsplus_jbd_t *journal, struct hfsplus_jbd_head *jh, struct buffer_head **bhs, int *batch_count)
+{
+	struct buffer_head *bh = hfsplus_jh2bh(jh);
+	int ret = 0;
+
+	if (buffer_locked(bh)) {
+		atomic_inc(&bh->b_count);
+		spin_unlock(&journal->j_list_lock);
+		hfsplus_jbd_unlock_bh_state(bh);
+		wait_on_buffer(bh);
+		/* the journal_head may have gone by now */
+		HFSPLUS_BUFFER_TRACE(bh, "brelse");
+		__brelse(bh);
+		ret = 1;
+	} else if (jh->b_transaction != NULL) {
+		hfsplus_transaction_t *t = jh->b_transaction;
+		hfsplus_jbd_tid_t tid = t->t_tid;
+
+		spin_unlock(&journal->j_list_lock);
+		hfsplus_jbd_unlock_bh_state(bh);
+		hfsplus_log_start_commit(journal, tid);
+		hfsplus_jbd_log_wait_commit(journal, tid);
+		ret = 1;
+	} else if (!buffer_dirty(bh)) {
+		ret = 1;
+		if (unlikely(buffer_write_io_error(bh)))
+			ret = -EIO;
+		HFSPLUS_J_ASSERT_JH(jh, !buffer_hfsplus_jbddirty(bh));
+		HFSPLUS_BUFFER_TRACE(bh, "remove from checkpoint");
+		__hfsplus_jbd_remove_checkpoint(jh);
+		spin_unlock(&journal->j_list_lock);
+		hfsplus_jbd_unlock_bh_state(bh);
+		hfsplus_jbd_remove_journal_head(bh);
+		__brelse(bh);
+	} else {
+		/*
+		 * Important: we are about to write the buffer, and
+		 * possibly block, while still holding the journal lock.
+		 * We cannot afford to let the transaction logic start
+		 * messing around with this buffer before we write it to
+		 * disk, as that would break recoverability.  
+		 */
+		HFSPLUS_BUFFER_TRACE(bh, "queue");
+		get_bh(bh);
+		HFSPLUS_J_ASSERT_BH(bh, !buffer_hfsplus_jbd_jwrite(bh));
+		set_buffer_hfsplus_jbd_jwrite(bh);
+		bhs[*batch_count] = bh;
+		__buffer_relink_io(jh);
+		hfsplus_jbd_unlock_bh_state(bh);
+		(*batch_count)++;
+		if (*batch_count == NR_BATCH) {
+			spin_unlock(&journal->j_list_lock);
+			__flush_batch(journal, bhs, batch_count);
+			ret = 1;
+		}
+	}
+	return ret;
+}
+
+/*
+ * Perform an actual checkpoint. We take the first transaction on the
+ * list of transactions to be checkpointed and send all its buffers
+ * to disk. We submit larger chunks of data at once.
+ *
+ * The journal should be locked before calling this function.
+ * Called with j_checkpoint_mutex held.
+ */
+int hfsplus_jbd_log_do_checkpoint(hfsplus_jbd_t *journal)
+{
+	hfsplus_transaction_t *transaction;
+	hfsplus_jbd_tid_t this_tid;
+	int result;
+
+	dprint(DBG_JCHKPT, "Start checkpoint\n");
+
+	/*
+	 * First thing: if there are any transactions in the log which
+	 * don't need checkpointing, just eliminate them from the
+	 * journal straight away.  
+	 */
+	result = cleanup_hfsplus_jbd_tail(journal);
+	dprint(DBG_JCHKPT, "cleanup_hfsplus_jbd_tail returned %d\n", result);
+	if (result <= 0)
+		return result;
+
+	/*
+	 * OK, we need to start writing disk blocks.  Take one transaction
+	 * and write it.
+	 */
+	result = 0;
+	spin_lock(&journal->j_list_lock);
+	if (!journal->j_checkpoint_transactions)
+		goto out;
+	transaction = journal->j_checkpoint_transactions;
+	this_tid = transaction->t_tid;
+restart:
+	/*
+	 * If someone cleaned up this transaction while we slept, we're
+	 * done (maybe it's a new transaction, but it fell at the same
+	 * address).
+	 */
+	if (journal->j_checkpoint_transactions == transaction &&
+			transaction->t_tid == this_tid) {
+		int batch_count = 0;
+		struct buffer_head *bhs[NR_BATCH];
+		struct hfsplus_jbd_head *jh;
+		int retry = 0, err;
+
+		while (!retry && transaction->t_checkpoint_list) {
+			struct buffer_head *bh;
+
+			jh = transaction->t_checkpoint_list;
+			bh = hfsplus_jh2bh(jh);
+			if (!hfsplus_jbd_trylock_bh_state(bh)) {
+				jbd_sync_bh(journal, bh);
+				retry = 1;
+				break;
+			}
+			retry = __process_buffer(journal, jh, bhs,&batch_count);
+			if (retry < 0 && !result)
+				result = retry;
+			if (!retry && (need_resched() ||
+				spin_needbreak(&journal->j_list_lock))) {
+				spin_unlock(&journal->j_list_lock);
+				retry = 1;
+				break;
+			}
+		}
+
+		if (batch_count) {
+			if (!retry) {
+				spin_unlock(&journal->j_list_lock);
+				retry = 1;
+			}
+			__flush_batch(journal, bhs, &batch_count);
+		}
+
+		if (retry) {
+			spin_lock(&journal->j_list_lock);
+			goto restart;
+		}
+		/*
+		 * Now we have cleaned up the first transaction's checkpoint
+		 * list. Let's clean up the second one
+		 */
+		err = __wait_cp_io(journal, transaction);
+		if (!result)
+			result = err;
+	}
+out:
+	spin_unlock(&journal->j_list_lock);
+	if (result < 0)
+		hfsplus_jbd_abort(journal, result);
+	else
+		result = cleanup_hfsplus_jbd_tail(journal);
+
+	return (result < 0) ? result : 0;
+}
+
+/*
+ * Check the list of checkpoint transactions for the journal to see if
+ * we have already got rid of any since the last update of the log tail
+ * in the journal superblock.  If so, we can instantly roll the
+ * superblock forward to remove those transactions from the log.
+ * 
+ * Return <0 on error, 0 on success, 1 if there was nothing to clean up.
+ * 
+ * Called with the journal lock held.
+ *
+ * This is the only part of the journaling code which really needs to be
+ * aware of transaction aborts.  Checkpointing involves writing to the
+ * main filesystem area rather than to the journal, so it can proceed
+ * even in abort state, but we must not update the journal superblock if
+ * checkpointing may have failed.  Otherwise, we would lose some metadata
+ * buffers which should be written-back to the filesystem.
+ */
+
+int cleanup_hfsplus_jbd_tail(hfsplus_jbd_t *journal)
+{
+	hfsplus_transaction_t * transaction;
+	hfsplus_jbd_tid_t		first_tid;
+	unsigned int	blocknr, freed;
+
+	if (is_hfsplus_jbd_aborted(journal))
+		return 1;
+
+	/* OK, work out the oldest transaction remaining in the log, and
+	 * the log block it starts at.
+	 *
+	 * If the log is now empty, we need to work out which is the
+	 * next transaction ID we will write, and where it will
+	 * start. */
+
+	spin_lock(&journal->j_state_lock);
+	spin_lock(&journal->j_list_lock);
+	transaction = journal->j_checkpoint_transactions;
+	if (transaction) {
+		first_tid = transaction->t_tid;
+		blocknr = transaction->t_log_start;
+	} else if ((transaction = journal->j_committing_transaction) != NULL) {
+		first_tid = transaction->t_tid;
+		blocknr = transaction->t_log_start;
+	} else if ((transaction = journal->j_running_transaction) != NULL) {
+		first_tid = transaction->t_tid;
+		blocknr = journal->j_head;
+	} else {
+		first_tid = journal->j_transaction_sequence;
+		blocknr = journal->j_head;
+	}
+	spin_unlock(&journal->j_list_lock);
+	HFSPLUS_J_ASSERT(blocknr != 0);
+
+	/* If the oldest pinned transaction is at the tail of the log
+           already then there's not much we can do right now. */
+	if (journal->j_tail_sequence == first_tid) {
+		spin_unlock(&journal->j_state_lock);
+		return 1;
+	}
+
+	/* OK, update the superblock to recover the freed space.
+	 * Physical blocks come first: have we wrapped beyond the end of
+	 * the log?  */
+	freed = blocknr - journal->j_tail;
+	if (blocknr < journal->j_tail)
+		freed = freed + journal->j_last - journal->j_first;
+
+#ifdef HFSPLUS_JOURNAL_MAC_COMPATIBLE
+	hfsplus_journal_header_start_update(journal, freed);
+#endif
+	dprint(DBG_JCHKPT,
+		  "Cleaning journal tail from %d to %d (offset %u), "
+		  "freeing %u\n",
+		  journal->j_tail_sequence, first_tid, blocknr, freed);
+
+	journal->j_free += freed;
+	journal->j_tail_sequence = first_tid;
+	journal->j_tail = blocknr;
+	spin_unlock(&journal->j_state_lock);
+	if (!(journal->j_flags & JFS_ABORT))
+		hfsplus_jbd_update_superblock(journal, 1);
+	return 0;
+}
+
+
+/* Checkpoint list management */
+
+/*
+ * hfsplus_jbd_clean_checkpoint_list
+ *
+ * Find all the written-back checkpoint buffers in the journal and release them.
+ *
+ * Called with the journal locked.
+ * Called with j_list_lock held.
+ * Returns number of bufers reaped (for debug)
+ */
+
+static int journal_clean_one_cp_list(struct hfsplus_jbd_head *jh, int *released)
+{
+	struct hfsplus_jbd_head *last_jh;
+	struct hfsplus_jbd_head *next_jh = jh;
+	int ret, freed = 0;
+
+	*released = 0;
+	if (!jh)
+		return 0;
+
+	last_jh = jh->b_cpprev;
+	do {
+		jh = next_jh;
+		next_jh = jh->b_cpnext;
+		/* Use trylock because of the ranking */
+		if (hfsplus_jbd_trylock_bh_state(hfsplus_jh2bh(jh))) {
+			ret = __try_to_free_cp_buf(jh);
+			if (ret) {
+				freed++;
+				if (ret == 2) {
+					*released = 1;
+					return freed;
+				}
+			}
+		}
+		/*
+		 * This function only frees up some memory
+		 * if possible so we dont have an obligation
+		 * to finish processing. Bail out if preemption
+		 * requested:
+		 */
+		if (need_resched())
+			return freed;
+	} while (jh != last_jh);
+
+	return freed;
+}
+
+/*
+ * journal_clean_checkpoint_list
+ *
+ * Find all the written-back checkpoint buffers in the journal and release them.
+ *
+ * Called with the journal locked.
+ * Called with j_list_lock held.
+ * Returns number of buffers reaped (for debug)
+ */
+
+int __hfsplus_jbd_clean_checkpoint_list(hfsplus_jbd_t *journal)
+{
+	hfsplus_transaction_t *transaction, *last_transaction, *next_transaction;
+	int ret = 0;
+	int released;
+
+	transaction = journal->j_checkpoint_transactions;
+	if (!transaction)
+		goto out;
+
+	last_transaction = transaction->t_cpprev;
+	next_transaction = transaction;
+	do {
+		transaction = next_transaction;
+		next_transaction = transaction->t_cpnext;
+		ret += journal_clean_one_cp_list(transaction->
+				t_checkpoint_list, &released);
+		/*
+		 * This function only frees up some memory if possible so we
+		 * dont have an obligation to finish processing. Bail out if
+		 * preemption requested:
+		 */
+		if (need_resched())
+			goto out;
+		if (released)
+			continue;
+		/*
+		 * It is essential that we are as careful as in the case of
+		 * t_checkpoint_list with removing the buffer from the list as
+		 * we can possibly see not yet submitted buffers on io_list
+		 */
+		ret += journal_clean_one_cp_list(transaction->
+				t_checkpoint_io_list, &released);
+		if (need_resched())
+			goto out;
+	} while (transaction != last_transaction);
+out:
+	return ret;
+}
+
+/* 
+ * hfsplus_jbd_remove_checkpoint: called after a buffer has been committed
+ * to disk (either by being write-back flushed to disk, or being
+ * committed to the log).
+ *
+ * We cannot safely clean a transaction out of the log until all of the
+ * buffer updates committed in that transaction have safely been stored
+ * elsewhere on disk.  To achieve this, all of the buffers in a
+ * transaction need to be maintained on the transaction's checkpoint
+ * list until they have been rewritten, at which point this function is
+ * called to remove the buffer from the existing transaction's
+ * checkpoint list.  
+ *
+ * The function returns 1 if it frees the transaction, 0 otherwise.
+ *
+ * This function is called with the journal locked.
+ * This function is called with j_list_lock held.
+ * This function is called with jbd_lock_bh_state(jh2bh(jh))
+ */
+
+int __hfsplus_jbd_remove_checkpoint(struct hfsplus_jbd_head *jh)
+{
+	hfsplus_transaction_t *transaction;
+	hfsplus_jbd_t *journal;
+	int ret = 0;
+
+	HFSPLUS_JBUFFER_TRACE(jh, "entry");
+
+	if ((transaction = jh->b_cp_transaction) == NULL) {
+		HFSPLUS_JBUFFER_TRACE(jh, "not on transaction");
+		goto out;
+	}
+	journal = transaction->t_journal;
+
+	__buffer_unlink(jh);
+	jh->b_cp_transaction = NULL;
+
+	if (transaction->t_checkpoint_list != NULL ||
+	    transaction->t_checkpoint_io_list != NULL)
+		goto out;
+	HFSPLUS_JBUFFER_TRACE(jh, "transaction has no more buffers");
+
+	/*
+	 * There is one special case to worry about: if we have just pulled the
+	 * buffer off a running or committing transaction's checkpoing list,
+	 * then even if the checkpoint list is empty, the transaction obviously
+	 * cannot be dropped!
+	 *
+	 * The locking here around t_state is a bit sleazy.
+	 * See the comment at the end of journal_commit_transaction().
+	 */
+	if (transaction->t_state != HFSPLUS_T_FINISHED) {
+		HFSPLUS_JBUFFER_TRACE(jh, "belongs to committing transaction");
+		goto out;
+	}
+
+	/* OK, that was the last buffer for the transaction: we can now
+	   safely remove this transaction from the log */
+
+	__hfsplus_jbd_drop_transaction(journal, transaction);
+
+	/* Just in case anybody was waiting for more transactions to be
+           checkpointed... */
+	wake_up(&journal->j_wait_logspace);
+	ret = 1;
+out:
+	HFSPLUS_JBUFFER_TRACE(jh, "exit");
+	return ret;
+}
+
+/*
+ * hfsplus_jbd_insert_checkpoint: put a committed buffer onto a checkpoint
+ * list so that we know when it is safe to clean the transaction out of
+ * the log.
+ *
+ * Called with the journal locked.
+ * Called with j_list_lock held.
+ */
+void __hfsplus_jbd_insert_checkpoint(struct hfsplus_jbd_head *jh, 
+			       hfsplus_transaction_t *transaction)
+{
+	HFSPLUS_JBUFFER_TRACE(jh, "entry");
+	HFSPLUS_J_ASSERT_JH(jh, buffer_dirty(hfsplus_jh2bh(jh)) || buffer_hfsplus_jbddirty(hfsplus_jh2bh(jh)));
+	HFSPLUS_J_ASSERT_JH(jh, jh->b_cp_transaction == NULL);
+
+	jh->b_cp_transaction = transaction;
+
+	if (!transaction->t_checkpoint_list) {
+		jh->b_cpnext = jh->b_cpprev = jh;
+	} else {
+		jh->b_cpnext = transaction->t_checkpoint_list;
+		jh->b_cpprev = transaction->t_checkpoint_list->b_cpprev;
+		jh->b_cpprev->b_cpnext = jh;
+		jh->b_cpnext->b_cpprev = jh;
+	}
+	transaction->t_checkpoint_list = jh;
+}
+
+/*
+ * We've finished with this transaction structure: adios...
+ * 
+ * The transaction must have no links except for the checkpoint by this
+ * point.
+ *
+ * Called with the journal locked.
+ * Called with j_list_lock held.
+ */
+
+void __hfsplus_jbd_drop_transaction(hfsplus_jbd_t *journal, hfsplus_transaction_t *transaction)
+{
+	assert_spin_locked(&journal->j_list_lock);
+	if (transaction->t_cpnext) {
+		transaction->t_cpnext->t_cpprev = transaction->t_cpprev;
+		transaction->t_cpprev->t_cpnext = transaction->t_cpnext;
+		if (journal->j_checkpoint_transactions == transaction)
+			journal->j_checkpoint_transactions =
+				transaction->t_cpnext;
+		if (journal->j_checkpoint_transactions == transaction)
+			journal->j_checkpoint_transactions = NULL;
+	}
+
+	HFSPLUS_J_ASSERT(transaction->t_state == HFSPLUS_T_FINISHED);
+	HFSPLUS_J_ASSERT(transaction->t_buffers == NULL);
+	HFSPLUS_J_ASSERT(transaction->t_sync_datalist == NULL);
+	HFSPLUS_J_ASSERT(transaction->t_forget == NULL);
+	HFSPLUS_J_ASSERT(transaction->t_iobuf_list == NULL);
+	HFSPLUS_J_ASSERT(transaction->t_shadow_list == NULL);
+	HFSPLUS_J_ASSERT(transaction->t_log_list == NULL);
+	HFSPLUS_J_ASSERT(transaction->t_checkpoint_list == NULL);
+	HFSPLUS_J_ASSERT(transaction->t_checkpoint_io_list == NULL);
+	HFSPLUS_J_ASSERT(transaction->t_updates == 0);
+	HFSPLUS_J_ASSERT(journal->j_committing_transaction != transaction);
+	HFSPLUS_J_ASSERT(journal->j_running_transaction != transaction);
+
+	dprint(DBG_JCHKPT, "Dropping transaction %d, all done\n", transaction->t_tid);
+	kfree(transaction);
+}
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/commit.c linux-2.6.32/fs/hfsplus_journal/commit.c
--- linux-2.6.32-old//fs/hfsplus_journal/commit.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/commit.c	2011-11-17 09:00:40.778818402 -0500
@@ -0,0 +1,1041 @@
+/*
+ * linux/fs/commit.c
+ *
+ * Written by Stephen C. Tweedie <sct@redhat.com>, 1998
+ *
+ * Copyright 1998 Red Hat corp --- All Rights Reserved
+ *
+ * This file is part of the Linux kernel and is made available under
+ * the terms of the GNU General Public License, version 2, or at your
+ * option, any later version, incorporated herein by reference.
+ *
+ * Journal commit routines for the generic filesystem journaling code;
+ * part of the ext2fs journaling system.
+ */
+
+#include <linux/time.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/bio.h>
+#include <linux/smp_lock.h>
+#include "hfsplus_jbd.h"
+#include "hfsplus_fs.h"
+
+/*
+ * Default IO end handler for temporary HFSPLUS_BJ_IO buffer_heads.
+ */
+static void hfsplus_jbd_end_buffer_io_sync(struct buffer_head *bh, int uptodate)
+{
+	HFSPLUS_BUFFER_TRACE(bh, "");
+	if (uptodate)
+		set_buffer_uptodate(bh);
+	else
+		clear_buffer_uptodate(bh);
+	unlock_buffer(bh);
+}
+
+/*
+ * When an ext3-ordered file is truncated, it is possible that many pages are
+ * not successfully freed, because they are attached to a committing transaction.
+ * After the transaction commits, these pages are left on the LRU, with no
+ * ->mapping, and with attached buffers.  These pages are trivially reclaimable
+ * by the VM, but their apparent absence upsets the VM accounting, and it makes
+ * the numbers in /proc/meminfo look odd.
+ *
+ * So here, we have a buffer which has just come off the forget list.  Look to
+ * see if we can strip all buffers from the backing page.
+ *
+ * Called under journal->j_list_lock.  The caller provided us with a ref
+ * against the buffer, and we drop that here.
+ */
+static void release_buffer_page(struct buffer_head *bh)
+{
+	struct page *page;
+
+	if (buffer_dirty(bh))
+		goto nope;
+	if (atomic_read(&bh->b_count) != 1)
+		goto nope;
+	page = bh->b_page;
+	if (!page)
+		goto nope;
+	if (page->mapping)
+		goto nope;
+
+	/* OK, it's a truncated page */
+	if (!trylock_page(page))
+		goto nope;
+
+	page_cache_get(page);
+	__brelse(bh);
+	try_to_free_buffers(page);
+	unlock_page(page);
+	page_cache_release(page);
+	return;
+
+nope:
+	__brelse(bh);
+}
+
+/*
+ * Decrement reference counter for data buffer. If it has been marked
+ * 'BH_Freed', release it and the page to which it belongs if possible.
+ */
+static void release_data_buffer(struct buffer_head *bh)
+{
+	if (buffer_hfsplus_jbd_freed(bh)) {
+		clear_buffer_hfsplus_jbd_freed(bh);
+		release_buffer_page(bh);
+	} else
+		put_bh(bh);
+}
+
+/*
+ * Try to acquire jbd_lock_bh_state() against the buffer, when j_list_lock is
+ * held.  For ranking reasons we must trylock.  If we lose, schedule away and
+ * return 0.  j_list_lock is dropped in this case.
+ */
+static int inverted_lock(hfsplus_jbd_t *journal, struct buffer_head *bh)
+{
+	if (!hfsplus_jbd_trylock_bh_state(bh)) {
+		spin_unlock(&journal->j_list_lock);
+		schedule();
+		return 0;
+	}
+	return 1;
+}
+
+/* Done it all: now write the commit record.  We should have
+ * cleaned up our previous buffers by now, so if we are in abort
+ * mode we can now just skip the rest of the journal write
+ * entirely.
+ *
+ * Returns 1 if the journal needs to be aborted or 0 on success
+ */
+static int hfsplus_jbd_write_commit_record(hfsplus_jbd_t *journal,
+					hfsplus_transaction_t *commit_transaction)
+{
+	struct hfsplus_jbd_head *descriptor;
+	struct buffer_head *bh;
+	hfsplus_jbd_header_t *header;
+	int ret;
+	int barrier_done = 0;
+
+#ifdef HFSPLUS_JOURNAL_MAC_COMPATIBLE
+	dprint(DBG_JCOMMIT, "Skip writing commit block into the disk\n");
+	return 0;
+#endif
+
+	if (is_hfsplus_jbd_aborted(journal))
+		return 0;
+
+	descriptor = hfsplus_jbd_get_descriptor_buffer(journal);
+	if (!descriptor)
+		return 1;
+
+	bh = hfsplus_jh2bh(descriptor);
+
+	header = (hfsplus_jbd_header_t *)(bh->b_data);
+	header->h_magic = cpu_to_be32(JFS_MAGIC_NUMBER);
+	header->h_blocktype = cpu_to_be32(JFS_COMMIT_BLOCK);
+	header->h_sequence = cpu_to_be32(commit_transaction->t_tid);
+
+	HFSPLUS_JBUFFER_TRACE(descriptor, "write commit block");
+	set_buffer_dirty(bh);
+	if (journal->j_flags & JFS_BARRIER) {
+		set_buffer_ordered(bh);
+		barrier_done = 1;
+	}
+	ret = sync_dirty_buffer(bh);
+	if (barrier_done)
+		clear_buffer_ordered(bh);
+	/* is it possible for another commit to fail at roughly
+	 * the same time as this one?  If so, we don't want to
+	 * trust the barrier flag in the super, but instead want
+	 * to remember if we sent a barrier request
+	 */
+	if (ret == -EOPNOTSUPP && barrier_done) {
+		char b[BDEVNAME_SIZE];
+
+		printk(KERN_WARNING
+			"JBD: barrier-based sync failed on %s - "
+			"disabling barriers\n",
+			bdevname(journal->j_dev, b));
+		spin_lock(&journal->j_state_lock);
+		journal->j_flags &= ~JFS_BARRIER;
+		spin_unlock(&journal->j_state_lock);
+
+		/* And try again, without the barrier */
+		set_buffer_uptodate(bh);
+		set_buffer_dirty(bh);
+		ret = sync_dirty_buffer(bh);
+	}
+	put_bh(bh);		/* One for getblk() */
+	hfsplus_jbd_put_journal_head(descriptor);
+
+	return (ret == -EIO);
+}
+
+static void journal_do_submit_data(struct buffer_head **wbuf, int bufs,
+				   int write_op)
+{
+	int i;
+
+	for (i = 0; i < bufs; i++) {
+		wbuf[i]->b_end_io = end_buffer_write_sync;
+		/* We use-up our safety reference in submit_bh() */
+		submit_bh(write_op, wbuf[i]);
+	}
+}
+
+/*
+ *  Submit all the data buffers to disk
+ */
+static int journal_submit_data_buffers(hfsplus_jbd_t *journal,
+				       hfsplus_transaction_t *commit_transaction,
+				       int write_op)
+{
+	struct hfsplus_jbd_head *jh;
+	struct buffer_head *bh;
+	int locked;
+	int bufs = 0;
+	struct buffer_head **wbuf = journal->j_wbuf;
+	int err = 0;
+
+	/*
+	 * Whenever we unlock the journal and sleep, things can get added
+	 * onto ->t_sync_datalist, so we have to keep looping back to
+	 * write_out_data until we *know* that the list is empty.
+	 *
+	 * Cleanup any flushed data buffers from the data list.  Even in
+	 * abort mode, we want to flush this out as soon as possible.
+	 */
+write_out_data:
+	cond_resched();
+	spin_lock(&journal->j_list_lock);
+
+	while (commit_transaction->t_sync_datalist) {
+		jh = commit_transaction->t_sync_datalist;
+		bh = hfsplus_jh2bh(jh);
+		locked = 0;
+
+		/* Get reference just to make sure buffer does not disappear
+		 * when we are forced to drop various locks */
+		get_bh(bh);
+		/* If the buffer is dirty, we need to submit IO and hence
+		 * we need the buffer lock. We try to lock the buffer without
+		 * blocking. If we fail, we need to drop j_list_lock and do
+		 * blocking lock_buffer().
+		 */
+		if (buffer_dirty(bh)) {
+			if (!trylock_buffer(bh)) {
+				HFSPLUS_BUFFER_TRACE(bh, "needs blocking lock");
+				spin_unlock(&journal->j_list_lock);
+				/* Write out all data to prevent deadlocks */
+				journal_do_submit_data(wbuf, bufs, write_op);
+				bufs = 0;
+				lock_buffer(bh);
+				spin_lock(&journal->j_list_lock);
+			}
+			locked = 1;
+		}
+		/* We have to get bh_state lock. Again out of order, sigh. */
+		if (!inverted_lock(journal, bh)) {
+			hfsplus_jbd_lock_bh_state(bh);
+			spin_lock(&journal->j_list_lock);
+		}
+		/* Someone already cleaned up the buffer? */
+		if (!buffer_hfsplus_jbd(bh) || hfsplus_bh2jh(bh) != jh
+			|| jh->b_transaction != commit_transaction
+			|| jh->b_jlist != HFSPLUS_BJ_SyncData) {
+			hfsplus_jbd_unlock_bh_state(bh);
+			if (locked)
+				unlock_buffer(bh);
+			HFSPLUS_BUFFER_TRACE(bh, "already cleaned up");
+			release_data_buffer(bh);
+			continue;
+		}
+		if (locked && test_clear_buffer_dirty(bh)) {
+			HFSPLUS_BUFFER_TRACE(bh, "needs writeout, adding to array");
+			wbuf[bufs++] = bh;
+			__hfsplus_jbd_file_buffer(jh, commit_transaction,
+						HFSPLUS_BJ_Locked);
+			hfsplus_jbd_unlock_bh_state(bh);
+			if (bufs == journal->j_wbufsize) {
+				spin_unlock(&journal->j_list_lock);
+				journal_do_submit_data(wbuf, bufs, write_op);
+				bufs = 0;
+				goto write_out_data;
+			}
+		} else if (!locked && buffer_locked(bh)) {
+			__hfsplus_jbd_file_buffer(jh, commit_transaction,
+						HFSPLUS_BJ_Locked);
+			hfsplus_jbd_unlock_bh_state(bh);
+			put_bh(bh);
+		} else {
+			HFSPLUS_BUFFER_TRACE(bh, "writeout complete: unfile");
+			if (unlikely(!buffer_uptodate(bh)))
+				err = -EIO;
+			__hfsplus_jbd_unfile_buffer(jh);
+			hfsplus_jbd_unlock_bh_state(bh);
+			if (locked)
+				unlock_buffer(bh);
+			hfsplus_jbd_remove_journal_head(bh);
+			/* One for our safety reference, other for
+			 * hfsplus_jbd_remove_journal_head() */
+			put_bh(bh);
+			release_data_buffer(bh);
+		}
+
+		if (need_resched() || spin_needbreak(&journal->j_list_lock)) {
+			spin_unlock(&journal->j_list_lock);
+			goto write_out_data;
+		}
+	}
+	spin_unlock(&journal->j_list_lock);
+	journal_do_submit_data(wbuf, bufs, write_op);
+
+	return err;
+}
+
+#ifdef HFSPLUS_JOURNAL_MAC_COMPATIBLE
+static void hfsplus_journaled_swap_blhdr(hfsplus_blhdr_t *blhdr)
+{
+	int i;
+
+	blhdr->bytes_used = cpu_to_be32(blhdr->bytes_used);
+	blhdr->checksum = cpu_to_be32(blhdr->checksum);
+
+	for (i=1; i<blhdr->num_blocks; i++) {
+		blhdr->binfo[i].bnum = cpu_to_be64(blhdr->binfo[i].bnum);
+		blhdr->binfo[i].bsize = cpu_to_be32(blhdr->binfo[i].bsize);
+	}
+
+	blhdr->num_blocks = cpu_to_be16(blhdr->num_blocks);
+}
+#endif
+
+/*
+ * hfsplus_jbd_commit_transaction
+ *
+ * The primary function for committing a transaction to the log.  This
+ * function is called by the journal thread to begin a complete commit.
+ */
+void hfsplus_jbd_commit_transaction(hfsplus_jbd_t *journal)
+{
+	hfsplus_transaction_t *commit_transaction;
+	struct hfsplus_jbd_head *jh, *new_jh, *descriptor;
+	struct buffer_head **wbuf = journal->j_wbuf;
+	int bufs;
+	int flags;
+	int err;
+	unsigned int blocknr;
+	ktime_t start_time;
+	u64 commit_time;
+#ifdef HFSPLUS_JOURNAL_MAC_COMPATIBLE
+	hfsplus_blhdr_t *blhdr = NULL;
+	struct super_block *sb = NULL;
+	struct hfsplus_journal *jnl = NULL; 
+#else
+	char *tagp = NULL;
+	hfsplus_jbd_header_t *header;
+	hfsplus_jbd_block_tag_t *tag = NULL;
+	int space_left = 0;
+	int first_tag = 0;
+	int tag_flag;
+#endif
+	int i;
+	int write_op = WRITE;
+
+	/*
+	 * First job: lock down the current transaction and wait for
+	 * all outstanding updates to complete.
+	 */
+
+#ifdef COMMIT_STATS
+	spin_lock(&journal->j_list_lock);
+	summarise_hfsplus_jbd_usage(journal);
+	spin_unlock(&journal->j_list_lock);
+#endif
+
+	/* Do we need to erase the effects of a prior hfsplus_jbd_flush? */
+	if (journal->j_flags & JFS_FLUSHED) {
+		dprint(DBG_JCOMMIT, "super block updated\n");
+		hfsplus_jbd_update_superblock(journal, 1);
+	} else {
+		dprint(DBG_JCOMMIT, "superblock not updated\n");
+	}
+
+	HFSPLUS_J_ASSERT(journal->j_running_transaction != NULL);
+	HFSPLUS_J_ASSERT(journal->j_committing_transaction == NULL);
+
+	commit_transaction = journal->j_running_transaction;
+	HFSPLUS_J_ASSERT(commit_transaction->t_state == HFSPLUS_T_RUNNING);
+
+	dprint(DBG_JCOMMIT, "JBD: starting commit of transaction %d\n", commit_transaction->t_tid);
+
+	spin_lock(&journal->j_state_lock);
+	commit_transaction->t_state = HFSPLUS_T_LOCKED;
+
+	/*
+	 * Use plugged writes here, since we want to submit several before
+	 * we unplug the device. We don't do explicit unplugging in here,
+	 * instead we rely on sync_buffer() doing the unplug for us.
+	 */
+	if (commit_transaction->t_synchronous_commit)
+		write_op = WRITE_SYNC_PLUG;
+	spin_lock(&commit_transaction->t_handle_lock);
+	while (commit_transaction->t_updates) {
+		DEFINE_WAIT(wait);
+
+		prepare_to_wait(&journal->j_wait_updates, &wait,
+					TASK_UNINTERRUPTIBLE);
+		if (commit_transaction->t_updates) {
+			spin_unlock(&commit_transaction->t_handle_lock);
+			spin_unlock(&journal->j_state_lock);
+			schedule();
+			spin_lock(&journal->j_state_lock);
+			spin_lock(&commit_transaction->t_handle_lock);
+		}
+		finish_wait(&journal->j_wait_updates, &wait);
+	}
+	spin_unlock(&commit_transaction->t_handle_lock);
+
+	HFSPLUS_J_ASSERT (commit_transaction->t_outstanding_credits <=
+			journal->j_max_transaction_buffers);
+
+	/*
+	 * First thing we are allowed to do is to discard any remaining
+	 * HFSPLUS_BJ_Reserved buffers.  Note, it is _not_ permissible to assume
+	 * that there are no such buffers: if a large filesystem
+	 * operation like a truncate needs to split itself over multiple
+	 * transactions, then it may try to do a hfsplus_jbd_restart() while
+	 * there are still HFSPLUS_BJ_Reserved buffers outstanding.  These must
+	 * be released cleanly from the current transaction.
+	 *
+	 * In this case, the filesystem must still reserve write access
+	 * again before modifying the buffer in the new transaction, but
+	 * we do not require it to remember exactly which old buffers it
+	 * has reserved.  This is consistent with the existing behaviour
+	 * that multiple hfsplus_jbd_get_write_access() calls to the same
+	 * buffer are perfectly permissable.
+	 */
+	while (commit_transaction->t_reserved_list) {
+		jh = commit_transaction->t_reserved_list;
+		HFSPLUS_JBUFFER_TRACE(jh, "reserved, unused: refile");
+		/*
+		 * A hfsplus_jbd_get_undo_access()+hfsplus_jbd_release_buffer() may
+		 * leave undo-committed data.
+		 */
+		if (jh->b_committed_data) {
+			struct buffer_head *bh = hfsplus_jh2bh(jh);
+
+			hfsplus_jbd_lock_bh_state(bh);
+			hfsplus_jbd_free(jh->b_committed_data, bh->b_size);
+			jh->b_committed_data = NULL;
+			hfsplus_jbd_unlock_bh_state(bh);
+		}
+		hfsplus_jbd_refile_buffer(journal, jh);
+	}
+
+	/*
+	 * Now try to drop any written-back buffers from the journal's
+	 * checkpoint lists.  We do this *before* commit because it potentially
+	 * frees some memory
+	 */
+	spin_lock(&journal->j_list_lock);
+	__hfsplus_jbd_clean_checkpoint_list(journal);
+	spin_unlock(&journal->j_list_lock);
+
+	dprint(DBG_JCOMMIT, "JBD: commit phase 1\n");
+
+	/*
+	 * Switch to a new revoke table.
+	 */
+	hfsplus_jbd_switch_revoke_table(journal);
+
+	commit_transaction->t_state = HFSPLUS_T_FLUSH;
+	journal->j_committing_transaction = commit_transaction;
+	journal->j_running_transaction = NULL;
+	start_time = ktime_get();
+	commit_transaction->t_log_start = journal->j_head;
+	wake_up(&journal->j_wait_transaction_locked);
+	spin_unlock(&journal->j_state_lock);
+
+	dprint(DBG_JCOMMIT, "JBD: commit phase 2\n");
+
+	/*
+	 * Now start flushing things to disk, in the order they appear
+	 * on the transaction lists.  Data blocks go first.
+	 */
+	err = journal_submit_data_buffers(journal, commit_transaction,
+					  write_op);
+
+	/*
+	 * Wait for all previously submitted IO to complete.
+	 */
+	spin_lock(&journal->j_list_lock);
+	while (commit_transaction->t_locked_list) {
+		struct buffer_head *bh;
+
+		jh = commit_transaction->t_locked_list->b_tprev;
+		bh = hfsplus_jh2bh(jh);
+		get_bh(bh);
+		if (buffer_locked(bh)) {
+			spin_unlock(&journal->j_list_lock);
+			wait_on_buffer(bh);
+			spin_lock(&journal->j_list_lock);
+		}
+		if (unlikely(!buffer_uptodate(bh))) {
+			if (!trylock_page(bh->b_page)) {
+				spin_unlock(&journal->j_list_lock);
+				lock_page(bh->b_page);
+				spin_lock(&journal->j_list_lock);
+			}
+			if (bh->b_page->mapping)
+				set_bit(AS_EIO, &bh->b_page->mapping->flags);
+
+			unlock_page(bh->b_page);
+			SetPageError(bh->b_page);
+			err = -EIO;
+		}
+		if (!inverted_lock(journal, bh)) {
+			put_bh(bh);
+			spin_lock(&journal->j_list_lock);
+			continue;
+		}
+		if (buffer_hfsplus_jbd(bh) && hfsplus_bh2jh(bh) == jh &&
+		    jh->b_transaction == commit_transaction &&
+		    jh->b_jlist == HFSPLUS_BJ_Locked) {
+			__hfsplus_jbd_unfile_buffer(jh);
+			hfsplus_jbd_unlock_bh_state(bh);
+			hfsplus_jbd_remove_journal_head(bh);
+			put_bh(bh);
+		} else {
+			hfsplus_jbd_unlock_bh_state(bh);
+		}
+		release_data_buffer(bh);
+		cond_resched_lock(&journal->j_list_lock);
+	}
+	spin_unlock(&journal->j_list_lock);
+
+	if (err) {
+		char b[BDEVNAME_SIZE];
+
+		printk(KERN_WARNING
+			"JBD: Detected IO errors while flushing file data "
+			"on %s\n", bdevname(journal->j_fs_dev, b));
+		if (journal->j_flags & JFS_ABORT_ON_SYNCDATA_ERR)
+			hfsplus_jbd_abort(journal, err);
+		err = 0;
+	}
+
+	hfsplus_jbd_write_revoke_records(journal, commit_transaction, write_op);
+
+	/*
+	 * If we found any dirty or locked buffers, then we should have
+	 * looped back up to the write_out_data label.  If there weren't
+	 * any then hfsplus_jbd_clean_data_list should have wiped the list
+	 * clean by now, so check that it is in fact empty.
+	 */
+	HFSPLUS_J_ASSERT (commit_transaction->t_sync_datalist == NULL);
+
+	dprint(DBG_JCOMMIT, "JBD: commit phase 3\n");
+
+	/*
+	 * Way to go: we have now written out all of the data for a
+	 * transaction!  Now comes the tricky part: we need to write out
+	 * metadata.  Loop over the transaction's entire buffer list:
+	 */
+	spin_lock(&journal->j_state_lock);
+	commit_transaction->t_state = HFSPLUS_T_COMMIT;
+	spin_unlock(&journal->j_state_lock);
+
+	HFSPLUS_J_ASSERT(commit_transaction->t_nr_buffers <=
+		 commit_transaction->t_outstanding_credits);
+
+	descriptor = NULL;
+#ifdef HFSPLUS_JOURNAL_MAC_COMPATIBLE
+	sb = (struct super_block *)journal->j_private;
+	jnl = &(HFSPLUS_SB(sb).jnl);
+#endif
+	bufs = 0;
+	while (commit_transaction->t_buffers) {
+
+		/* Find the next buffer to be journaled... */
+
+		jh = commit_transaction->t_buffers;
+
+		/* If we're in abort mode, we just un-journal the buffer and
+		   release it. */
+
+		if (is_hfsplus_jbd_aborted(journal)) {
+			clear_buffer_hfsplus_jbddirty(hfsplus_jh2bh(jh));
+			HFSPLUS_JBUFFER_TRACE(jh, "journal is aborting: refile");
+			hfsplus_jbd_refile_buffer(journal, jh);
+			/* If that was the last one, we need to clean up
+			 * any descriptor buffers which may have been
+			 * already allocated, even if we are now
+			 * aborting. */
+			if (!commit_transaction->t_buffers)
+				goto start_hfsplus_jbd_io;
+			continue;
+		}
+
+		/* Make sure we have a descriptor block in which to
+		   record the metadata buffer. */
+
+		if (!descriptor) {
+			struct buffer_head *bh;
+
+			HFSPLUS_J_ASSERT (bufs == 0);
+
+			dprint(DBG_JCOMMIT, "JBD: get descriptor\n");
+
+			descriptor = hfsplus_jbd_get_descriptor_buffer(journal);
+			if (!descriptor) {
+				hfsplus_jbd_abort(journal, -EIO);
+				continue;
+			}
+
+			bh = hfsplus_jh2bh(descriptor);
+			dprint(DBG_JCOMMIT, "JBD: got buffer %llu (%p)\n", (unsigned long long)bh->b_blocknr, bh->b_data);
+#ifdef HFSPLUS_JOURNAL_MAC_COMPATIBLE
+			/* Populate block list header */
+			blhdr = (hfsplus_blhdr_t *)bh->b_data;
+			blhdr->max_blocks = (jnl->jhdr->blhdr_size / sizeof(struct hfsplus_block_info)) - 1;
+			blhdr->num_blocks = 1; /* One is for header */
+			blhdr->bytes_used = jnl->jhdr->blhdr_size; 
+			blhdr->binfo[0].next = 0; /* Only one Mac transaction */
+			hfsplus_journal_header_end_update(journal, jnl->jhdr);
+#else
+			header = (hfsplus_jbd_header_t *)&bh->b_data[0];
+			header->h_magic     = cpu_to_be32(JFS_MAGIC_NUMBER);
+			header->h_blocktype = cpu_to_be32(JFS_DESCRIPTOR_BLOCK);
+			header->h_sequence  = cpu_to_be32(commit_transaction->t_tid);
+
+			tagp = &bh->b_data[sizeof(hfsplus_jbd_header_t)];
+			space_left = bh->b_size - sizeof(hfsplus_jbd_header_t);
+			first_tag = 1;
+#endif
+			set_buffer_hfsplus_jbd_jwrite(bh);
+			set_buffer_dirty(bh);
+			wbuf[bufs++] = bh;
+
+			/* Record it so that we can wait for IO
+                           completion later */
+			HFSPLUS_BUFFER_TRACE(bh, "ph3: file as descriptor");
+			hfsplus_jbd_file_buffer(descriptor, commit_transaction,
+					HFSPLUS_BJ_LogCtl);
+		}
+
+		/* Where is the buffer to be written? */
+
+		err = hfsplus_jbd_next_log_block(journal, &blocknr);
+		/* If the block mapping failed, just abandon the buffer
+		   and repeat this loop: we'll fall into the
+		   refile-on-abort condition above. */
+		if (err) {
+			hfsplus_jbd_abort(journal, err);
+			continue;
+		}
+
+		/*
+		 * start_this_handle() uses t_outstanding_credits to determine
+		 * the free space in the log, but this counter is changed
+		 * by hfsplus_jbd_next_log_block() also.
+		 */
+		commit_transaction->t_outstanding_credits--;
+
+		/* Bump b_count to prevent truncate from stumbling over
+                   the shadowed buffer!  @@@ This can go if we ever get
+                   rid of the HFSPLUS_BJ_IO/HFSPLUS_BJ_Shadow pairing of buffers. */
+		atomic_inc(&hfsplus_jh2bh(jh)->b_count);
+
+		/* Make a temporary IO buffer with which to write it out
+                   (this will requeue both the metadata buffer and the
+                   temporary IO buffer). new_bh goes on HFSPLUS_BJ_IO*/
+
+		set_bit(BH_HFSPLUS_JWrite, &hfsplus_jh2bh(jh)->b_state);
+		/*
+		 * akpm: hfsplus_jbd_write_metadata_buffer() sets
+		 * new_bh->b_transaction to commit_transaction.
+		 * We need to clean this up before we release new_bh
+		 * (which is of type HFSPLUS_BJ_IO)
+		 */
+		HFSPLUS_JBUFFER_TRACE(jh, "ph3: write metadata");
+		flags = hfsplus_jbd_write_metadata_buffer(commit_transaction,
+						      jh, &new_jh, blocknr);
+		set_bit(BH_HFSPLUS_JWrite, &hfsplus_jh2bh(new_jh)->b_state);
+#ifdef HFSPLUS_JOURNAL_MAC_COMPATIBLE
+		blhdr->binfo[bufs].bnum = (hfsplus_jh2bh(jh)->b_blocknr * sb->s_blocksize) >> HFSPLUS_SECTOR_SHIFT;
+		blhdr->binfo[bufs].bsize = hfsplus_jh2bh(jh)->b_size; 
+		blhdr->binfo[bufs].next = 0;
+		blhdr->bytes_used += blhdr->binfo[bufs].bsize;
+		blhdr->num_blocks++;
+		hfsplus_journal_header_end_update(journal, jnl->jhdr);
+#endif
+		wbuf[bufs++] = hfsplus_jh2bh(new_jh);
+
+#ifndef HFSPLUS_JOURNAL_MAC_COMPATIBLE
+		/* Record the new block's tag in the current descriptor
+                   buffer */
+		tag_flag = 0;
+		if (flags & 1)
+			tag_flag |= JFS_FLAG_ESCAPE;
+		if (!first_tag)
+			tag_flag |= JFS_FLAG_SAME_UUID;
+
+		tag = (hfsplus_jbd_block_tag_t *) tagp;
+		tag->t_blocknr = cpu_to_be32(hfsplus_jh2bh(jh)->b_blocknr);
+		tag->t_flags = cpu_to_be32(tag_flag);
+		tagp += sizeof(hfsplus_jbd_block_tag_t);
+		space_left -= sizeof(hfsplus_jbd_block_tag_t);
+
+		if (first_tag) {
+			memcpy (tagp, journal->j_uuid, 16);
+			tagp += 16;
+			space_left -= 16;
+			first_tag = 0;
+		}
+#endif
+
+		/* If there's no more to do, or if the descriptor is full,
+		   let the IO rip! */
+
+#ifdef HFSPLUS_JOURNAL_MAC_COMPATIBLE
+		if (bufs == journal->j_wbufsize ||
+				commit_transaction->t_buffers == NULL ||
+				bufs == blhdr->max_blocks)
+#else
+		if (bufs == journal->j_wbufsize ||
+		    commit_transaction->t_buffers == NULL ||
+		    space_left < sizeof(hfsplus_jbd_block_tag_t) + 16) 
+#endif
+		{
+
+#ifdef HFSPLUS_JOURNAL_MAC_COMPATIBLE
+			dprint(DBG_JCOMMIT, "start: %llx, end: %llx, num_blocks: %#x, bytes_used: %#x, j_head: %#x, j_first: %#x\n", jnl->jhdr->start, jnl->jhdr->end, blhdr->num_blocks, blhdr->bytes_used, journal->j_head, journal->j_first);
+			blhdr->max_blocks = HFSPLUS_JBD_MAGIC_NUMBER;
+			if (jnl->flags == HFSPLUS_JOURNAL_SWAP)
+				hfsplus_journaled_swap_blhdr(blhdr);
+#endif
+
+			dprint(DBG_JCOMMIT, "JBD: Submit %d IOs\n", bufs);
+
+			/* Write an end-of-descriptor marker before
+                           submitting the IOs.  "tag" still points to
+                           the last tag we set up. */
+
+#ifndef HFSPLUS_JOURNAL_MAC_COMPATIBLE
+			tag->t_flags |= cpu_to_be32(JFS_FLAG_LAST_TAG);
+#endif
+
+start_hfsplus_jbd_io:
+			for (i = 0; i < bufs; i++) {
+				struct buffer_head *bh = wbuf[i];
+				lock_buffer(bh);
+				clear_buffer_dirty(bh);
+				set_buffer_uptodate(bh);
+				bh->b_end_io = hfsplus_jbd_end_buffer_io_sync;
+				submit_bh(write_op, bh);
+			}
+#ifdef HFSPLUS_JOURNAL_MAC_COMPATIBLE
+			//hfsplus_test_block_list_header(__FUNCTION__, jnl->jhdr, jnl);
+#endif
+			cond_resched();
+
+			/* Force a new descriptor to be generated next
+                           time round the loop. */
+			descriptor = NULL;
+			bufs = 0;
+		}
+	}
+
+	/* Lo and behold: we have just managed to send a transaction to
+           the log.  Before we can commit it, wait for the IO so far to
+           complete.  Control buffers being written are on the
+           transaction's t_log_list queue, and metadata buffers are on
+           the t_iobuf_list queue.
+
+	   Wait for the buffers in reverse order.  That way we are
+	   less likely to be woken up until all IOs have completed, and
+	   so we incur less scheduling load.
+	*/
+
+	dprint(DBG_JCOMMIT, "JBD: commit phase 4\n");
+
+	/*
+	 * akpm: these are HFSPLUS_BJ_IO, and j_list_lock is not needed.
+	 * See __hfsplus_jbd_try_to_free_buffer.
+	 */
+wait_for_iobuf:
+	while (commit_transaction->t_iobuf_list != NULL) {
+		struct buffer_head *bh;
+
+		jh = commit_transaction->t_iobuf_list->b_tprev;
+		bh = hfsplus_jh2bh(jh);
+		if (buffer_locked(bh)) {
+			wait_on_buffer(bh);
+			goto wait_for_iobuf;
+		}
+		if (cond_resched())
+			goto wait_for_iobuf;
+
+		if (unlikely(!buffer_uptodate(bh)))
+			err = -EIO;
+
+		clear_buffer_hfsplus_jbd_jwrite(bh);
+
+		HFSPLUS_JBUFFER_TRACE(jh, "ph4: unfile after journal write");
+		hfsplus_jbd_unfile_buffer(journal, jh);
+
+		/*
+		 * ->t_iobuf_list should contain only dummy buffer_heads
+		 * which were created by hfsplus_jbd_write_metadata_buffer().
+		 */
+		HFSPLUS_BUFFER_TRACE(bh, "dumping temporary bh");
+		hfsplus_jbd_put_journal_head(jh);
+		__brelse(bh);
+		HFSPLUS_J_ASSERT_BH(bh, atomic_read(&bh->b_count) == 0);
+		free_buffer_head(bh);
+
+		/* We also have to unlock and free the corresponding
+                   shadowed buffer */
+		jh = commit_transaction->t_shadow_list->b_tprev;
+		bh = hfsplus_jh2bh(jh);
+		clear_bit(BH_HFSPLUS_JWrite, &bh->b_state);
+		HFSPLUS_J_ASSERT_BH(bh, buffer_hfsplus_jbddirty(bh));
+
+		/* The metadata is now released for reuse, but we need
+                   to remember it against this transaction so that when
+                   we finally commit, we can do any checkpointing
+                   required. */
+		HFSPLUS_JBUFFER_TRACE(jh, "file as HFSPLUS_BJ_Forget");
+		hfsplus_jbd_file_buffer(jh, commit_transaction, HFSPLUS_BJ_Forget);
+		/* Wake up any transactions which were waiting for this
+		   IO to complete */
+		wake_up_bit(&bh->b_state, BH_HFSPLUS_Unshadow);
+		HFSPLUS_JBUFFER_TRACE(jh, "brelse shadowed buffer");
+		__brelse(bh);
+	}
+
+	HFSPLUS_J_ASSERT (commit_transaction->t_shadow_list == NULL);
+
+	dprint(DBG_JCOMMIT, "JBD: commit phase 5\n");
+
+	/* Here we wait for the revoke record and descriptor record buffers */
+ wait_for_ctlbuf:
+	while (commit_transaction->t_log_list != NULL) {
+		struct buffer_head *bh;
+
+		jh = commit_transaction->t_log_list->b_tprev;
+		bh = hfsplus_jh2bh(jh);
+		if (buffer_locked(bh)) {
+			wait_on_buffer(bh);
+			goto wait_for_ctlbuf;
+		}
+		if (cond_resched())
+			goto wait_for_ctlbuf;
+
+		if (unlikely(!buffer_uptodate(bh)))
+			err = -EIO;
+
+		HFSPLUS_BUFFER_TRACE(bh, "ph5: control buffer writeout done: unfile");
+		clear_buffer_hfsplus_jbd_jwrite(bh);
+		hfsplus_jbd_unfile_buffer(journal, jh);
+		hfsplus_jbd_put_journal_head(jh);
+		__brelse(bh);		/* One for getblk */
+		/* AKPM: bforget here */
+	}
+
+	if (err)
+		hfsplus_jbd_abort(journal, err);
+
+	dprint(DBG_JCOMMIT, "JBD: commit phase 6\n");
+
+	if (hfsplus_jbd_write_commit_record(journal, commit_transaction))
+		err = -EIO;
+
+	if (err)
+		hfsplus_jbd_abort(journal, err);
+
+	/* End of a transaction!  Finally, we can do checkpoint
+           processing: any buffers committed as a result of this
+           transaction can be removed from any checkpoint list it was on
+           before. */
+
+	dprint(DBG_JCOMMIT, "JBD: commit phase 7\n");
+
+	HFSPLUS_J_ASSERT(commit_transaction->t_sync_datalist == NULL);
+	HFSPLUS_J_ASSERT(commit_transaction->t_buffers == NULL);
+	HFSPLUS_J_ASSERT(commit_transaction->t_checkpoint_list == NULL);
+	HFSPLUS_J_ASSERT(commit_transaction->t_iobuf_list == NULL);
+	HFSPLUS_J_ASSERT(commit_transaction->t_shadow_list == NULL);
+	HFSPLUS_J_ASSERT(commit_transaction->t_log_list == NULL);
+
+restart_loop:
+	/*
+	 * As there are other places (hfsplus_jbd_unmap_buffer()) adding buffers
+	 * to this list we have to be careful and hold the j_list_lock.
+	 */
+	spin_lock(&journal->j_list_lock);
+	while (commit_transaction->t_forget) {
+		hfsplus_transaction_t *cp_transaction;
+		struct buffer_head *bh;
+
+		jh = commit_transaction->t_forget;
+		spin_unlock(&journal->j_list_lock);
+		bh = hfsplus_jh2bh(jh);
+		hfsplus_jbd_lock_bh_state(bh);
+		HFSPLUS_J_ASSERT_JH(jh,	jh->b_transaction == commit_transaction ||
+			jh->b_transaction == journal->j_running_transaction);
+
+		/*
+		 * If there is undo-protected committed data against
+		 * this buffer, then we can remove it now.  If it is a
+		 * buffer needing such protection, the old frozen_data
+		 * field now points to a committed version of the
+		 * buffer, so rotate that field to the new committed
+		 * data.
+		 *
+		 * Otherwise, we can just throw away the frozen data now.
+		 */
+		if (jh->b_committed_data) {
+			hfsplus_jbd_free(jh->b_committed_data, bh->b_size);
+			jh->b_committed_data = NULL;
+			if (jh->b_frozen_data) {
+				jh->b_committed_data = jh->b_frozen_data;
+				jh->b_frozen_data = NULL;
+			}
+		} else if (jh->b_frozen_data) {
+			hfsplus_jbd_free(jh->b_frozen_data, bh->b_size);
+			jh->b_frozen_data = NULL;
+		}
+
+		spin_lock(&journal->j_list_lock);
+		cp_transaction = jh->b_cp_transaction;
+		if (cp_transaction) {
+			HFSPLUS_JBUFFER_TRACE(jh, "remove from old cp transaction");
+			__hfsplus_jbd_remove_checkpoint(jh);
+		}
+
+		/* Only re-checkpoint the buffer_head if it is marked
+		 * dirty.  If the buffer was added to the HFSPLUS_BJ_Forget list
+		 * by hfsplus_jbd_forget, it may no longer be dirty and
+		 * there's no point in keeping a checkpoint record for
+		 * it. */
+
+		/* A buffer which has been freed while still being
+		 * journaled by a previous transaction may end up still
+		 * being dirty here, but we want to avoid writing back
+		 * that buffer in the future now that the last use has
+		 * been committed.  That's not only a performance gain,
+		 * it also stops aliasing problems if the buffer is left
+		 * behind for writeback and gets reallocated for another
+		 * use in a different page. */
+		if (buffer_hfsplus_jbd_freed(bh)) {
+			clear_buffer_hfsplus_jbd_freed(bh);
+			clear_buffer_hfsplus_jbddirty(bh);
+		}
+
+		if (buffer_hfsplus_jbddirty(bh)) {
+			HFSPLUS_JBUFFER_TRACE(jh, "add to new checkpointing trans");
+			__hfsplus_jbd_insert_checkpoint(jh, commit_transaction);
+			if (is_hfsplus_jbd_aborted(journal))
+				clear_buffer_hfsplus_jbddirty(bh);
+			HFSPLUS_JBUFFER_TRACE(jh, "refile for checkpoint writeback");
+			__hfsplus_jbd_refile_buffer(jh);
+			hfsplus_jbd_unlock_bh_state(bh);
+		} else {
+			HFSPLUS_J_ASSERT_BH(bh, !buffer_dirty(bh));
+			/* The buffer on BJ_Forget list and not jbddirty means
+			 * it has been freed by this transaction and hence it
+			 * could not have been reallocated until this
+			 * transaction has committed. *BUT* it could be
+			 * reallocated once we have written all the data to
+			 * disk and before we process the buffer on BJ_Forget
+			 * list. */
+			HFSPLUS_JBUFFER_TRACE(jh, "refile or unfile freed buffer");
+			__hfsplus_jbd_refile_buffer(jh);
+			if (!jh->b_transaction) {
+				hfsplus_jbd_unlock_bh_state(bh);
+				 /* needs a brelse */
+				hfsplus_jbd_remove_journal_head(bh);
+				release_buffer_page(bh);
+			} else
+				hfsplus_jbd_unlock_bh_state(bh);
+		}
+		cond_resched_lock(&journal->j_list_lock);
+	}
+	spin_unlock(&journal->j_list_lock);
+	/*
+	 * This is a bit sleazy.  We use j_list_lock to protect transition
+	 * of a transaction into T_FINISHED state and calling
+	 * __journal_drop_transaction(). Otherwise we could race with
+	 * other checkpointing code processing the transaction...
+	 */
+	spin_lock(&journal->j_state_lock);
+	spin_lock(&journal->j_list_lock);
+	/*
+	 * Now recheck if some buffers did not get attached to the transaction
+	 * while the lock was dropped...
+	 */
+	if (commit_transaction->t_forget) {
+		spin_unlock(&journal->j_list_lock);
+		spin_unlock(&journal->j_state_lock);
+		goto restart_loop;
+	}
+
+	/* Done with this transaction! */
+
+	dprint(DBG_JCOMMIT, "JBD: commit phase 8\n");
+
+	HFSPLUS_J_ASSERT(commit_transaction->t_state == HFSPLUS_T_COMMIT);
+
+	commit_transaction->t_state = HFSPLUS_T_FINISHED;
+	HFSPLUS_J_ASSERT(commit_transaction == journal->j_committing_transaction);
+	journal->j_commit_sequence = commit_transaction->t_tid;
+	journal->j_committing_transaction = NULL;
+	commit_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));
+
+	/*
+	 * weight the commit time higher than the average time so we don't
+	 * react too strongly to vast changes in commit time
+	 */
+	if (likely(journal->j_average_commit_time))
+		journal->j_average_commit_time = (commit_time*3 +
+				journal->j_average_commit_time) / 4;
+	else
+		journal->j_average_commit_time = commit_time;
+
+	spin_unlock(&journal->j_state_lock);
+
+	if (commit_transaction->t_checkpoint_list == NULL &&
+	    commit_transaction->t_checkpoint_io_list == NULL) {
+		__hfsplus_jbd_drop_transaction(journal, commit_transaction);
+	} else {
+		if (journal->j_checkpoint_transactions == NULL) {
+			journal->j_checkpoint_transactions = commit_transaction;
+			commit_transaction->t_cpnext = commit_transaction;
+			commit_transaction->t_cpprev = commit_transaction;
+		} else {
+			commit_transaction->t_cpnext =
+				journal->j_checkpoint_transactions;
+			commit_transaction->t_cpprev =
+				commit_transaction->t_cpnext->t_cpprev;
+			commit_transaction->t_cpnext->t_cpprev =
+				commit_transaction;
+			commit_transaction->t_cpprev->t_cpnext =
+				commit_transaction;
+		}
+	}
+	spin_unlock(&journal->j_list_lock);
+
+	dprint(DBG_JCOMMIT, "JBD: commit %d complete, head %d\n", journal->j_commit_sequence, journal->j_tail_sequence);
+
+	wake_up(&journal->j_wait_done_commit);
+}
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/dir.c linux-2.6.32/fs/hfsplus_journal/dir.c
--- linux-2.6.32-old//fs/hfsplus_journal/dir.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/dir.c	2011-11-17 09:00:40.778818402 -0500
@@ -0,0 +1,578 @@
+/*
+ *  linux/fs/hfsplus/dir.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handling of directories
+ */
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+static inline void hfsplus_instantiate(struct dentry *dentry,
+				       struct inode *inode, u32 cnid)
+{
+	dentry->d_fsdata = (void *)(unsigned long)cnid;
+	d_instantiate(dentry, inode);
+}
+
+/* Find the entry inside dir named dentry->d_name */
+static struct dentry *hfsplus_lookup(struct inode *dir, struct dentry *dentry,
+				     struct nameidata *nd)
+{
+	struct inode *inode = NULL;
+	struct hfs_find_data fd;
+	struct super_block *sb;
+	hfsplus_handle_t hfsplus_handle;
+	hfsplus_cat_entry entry;
+	int err;
+	u32 cnid, linkid = 0;
+	u16 type;
+
+	if (hfsplus_journal_start(__FUNCTION__, dir->i_sb, &hfsplus_handle))
+		return NULL;
+	sb = dir->i_sb;
+
+	dentry->d_op = &hfsplus_dentry_operations;
+	dentry->d_fsdata = NULL;
+	hfs_find_init(HFSPLUS_SB(sb).cat_tree, &fd);
+	hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, &dentry->d_name);
+again:
+	err = hfs_brec_read(&hfsplus_handle, &fd, &entry, sizeof(entry));
+	if (err) {
+		if (err == -ENOENT) {
+			hfs_find_exit(&hfsplus_handle, &fd);
+			/* No such entry */
+			inode = NULL;
+			goto out;
+		}
+		goto fail;
+	}
+	type = be16_to_cpu(entry.type);
+	if (type == HFSPLUS_FOLDER) {
+		if (fd.entrylength < sizeof(struct hfsplus_cat_folder)) {
+			err = -EIO;
+			goto fail;
+		}
+		cnid = be32_to_cpu(entry.folder.id);
+		dentry->d_fsdata = (void *)(unsigned long)cnid;
+	} else if (type == HFSPLUS_FILE) {
+		if (fd.entrylength < sizeof(struct hfsplus_cat_file)) {
+			err = -EIO;
+			goto fail;
+		}
+		cnid = be32_to_cpu(entry.file.id);
+		if (entry.file.user_info.fdType == cpu_to_be32(HFSP_HARDLINK_TYPE) &&
+		    entry.file.user_info.fdCreator == cpu_to_be32(HFSP_HFSPLUS_CREATOR) &&
+		    (entry.file.create_date == HFSPLUS_I(HFSPLUS_SB(sb).hidden_dir).create_date ||
+		     entry.file.create_date == HFSPLUS_I(sb->s_root->d_inode).create_date) &&
+		    HFSPLUS_SB(sb).hidden_dir) {
+			struct qstr str;
+			char name[32];
+
+			if (dentry->d_fsdata) {
+				/*
+				 * We found a link pointing to another link,
+				 * so ignore it and treat it as regular file.
+				 */
+				cnid = (unsigned long)dentry->d_fsdata;
+				linkid = 0;
+			} else {
+				dentry->d_fsdata = (void *)(unsigned long)cnid;
+				linkid = be32_to_cpu(entry.file.permissions.dev);
+				str.len = sprintf(name, "iNode%d", linkid);
+				str.name = name;
+				hfsplus_cat_build_key(sb, fd.search_key, HFSPLUS_SB(sb).hidden_dir->i_ino, &str);
+				goto again;
+			}
+		} else if (!dentry->d_fsdata)
+			dentry->d_fsdata = (void *)(unsigned long)cnid;
+	} else {
+		printk(KERN_ERR "hfs: invalid catalog entry type in lookup\n");
+		err = -EIO;
+		goto fail;
+	}
+	hfs_find_exit(&hfsplus_handle, &fd);
+	inode = hfsplus_iget(dir->i_sb, cnid);
+	if (IS_ERR(inode))
+		return ERR_CAST(inode);
+	if (S_ISREG(inode->i_mode))
+		HFSPLUS_I(inode).dev = linkid;
+out:
+	d_add(dentry, inode);
+	hfsplus_journal_stop(&hfsplus_handle);
+	return NULL;
+fail:
+	hfs_find_exit(&hfsplus_handle, &fd);
+	hfsplus_journal_stop(&hfsplus_handle);
+	return ERR_PTR(err);
+}
+
+static int hfsplus_readdir(struct file *filp, void *dirent, filldir_t filldir)
+{
+	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct super_block *sb = inode->i_sb;
+	int len, err;
+	char strbuf[HFSPLUS_MAX_STRLEN + 1];
+	hfsplus_cat_entry entry;
+	struct hfs_find_data fd;
+	struct hfsplus_readdir_data *rd;
+	hfsplus_handle_t hfsplus_handle;
+	u16 type;
+
+	if (filp->f_pos >= inode->i_size)
+		return 0;
+
+	if ((err = hfsplus_journal_start(__FUNCTION__, sb, &hfsplus_handle)))
+		return err;
+	hfs_find_init(HFSPLUS_SB(sb).cat_tree, &fd);
+	hfsplus_cat_build_key(sb, fd.search_key, inode->i_ino, NULL);
+	err = hfs_brec_find(&hfsplus_handle, &fd);
+	if (err)
+		goto out;
+
+	switch ((u32)filp->f_pos) {
+	case 0:
+		/* This is completely artificial... */
+		if (filldir(dirent, ".", 1, 0, inode->i_ino, DT_DIR))
+			goto out;
+		filp->f_pos++;
+		/* fall through */
+	case 1:
+		hfs_bnode_read(fd.bnode, &entry, fd.entryoffset, fd.entrylength);
+		if (be16_to_cpu(entry.type) != HFSPLUS_FOLDER_THREAD) {
+			printk(KERN_ERR "hfs: bad catalog folder thread\n");
+			err = -EIO;
+			goto out;
+		}
+		if (fd.entrylength < HFSPLUS_MIN_THREAD_SZ) {
+			printk(KERN_ERR "hfs: truncated catalog thread\n");
+			err = -EIO;
+			goto out;
+		}
+		if (filldir(dirent, "..", 2, 1,
+			    be32_to_cpu(entry.thread.parentID), DT_DIR))
+			goto out;
+		filp->f_pos++;
+		/* fall through */
+	default:
+		if (filp->f_pos >= inode->i_size)
+			goto out;
+		err = hfs_brec_goto(&hfsplus_handle, &fd, filp->f_pos - 1);
+		if (err)
+			goto out;
+	}
+
+	for (;;) {
+		if (be32_to_cpu(fd.key->cat.parent) != inode->i_ino) {
+			printk(KERN_ERR "hfs: walked past end of dir\n");
+			err = -EIO;
+			goto out;
+		}
+		hfs_bnode_read(fd.bnode, &entry, fd.entryoffset, fd.entrylength);
+		type = be16_to_cpu(entry.type);
+		len = HFSPLUS_MAX_STRLEN;
+		err = hfsplus_uni2asc(sb, &fd.key->cat.name, strbuf, &len);
+		if (err)
+			goto out;
+		if (type == HFSPLUS_FOLDER) {
+			if (fd.entrylength < sizeof(struct hfsplus_cat_folder)) {
+				printk(KERN_ERR "hfs: small dir entry\n");
+				err = -EIO;
+				goto out;
+			}
+			if (HFSPLUS_SB(sb).hidden_dir &&
+			    HFSPLUS_SB(sb).hidden_dir->i_ino == be32_to_cpu(entry.folder.id))
+				goto next;
+			if (filldir(dirent, strbuf, len, filp->f_pos,
+				    be32_to_cpu(entry.folder.id), DT_DIR))
+				break;
+		} else if (type == HFSPLUS_FILE) {
+			if (fd.entrylength < sizeof(struct hfsplus_cat_file)) {
+				printk(KERN_ERR "hfs: small file entry\n");
+				err = -EIO;
+				goto out;
+			}
+			if (filldir(dirent, strbuf, len, filp->f_pos,
+				    be32_to_cpu(entry.file.id), DT_REG))
+				break;
+		} else {
+			printk(KERN_ERR "hfs: bad catalog entry type\n");
+			err = -EIO;
+			goto out;
+		}
+	next:
+		filp->f_pos++;
+		if (filp->f_pos >= inode->i_size)
+			goto out;
+		err = hfs_brec_goto(&hfsplus_handle, &fd, 1);
+		if (err)
+			goto out;
+	}
+	rd = filp->private_data;
+	if (!rd) {
+		rd = kmalloc(sizeof(struct hfsplus_readdir_data), GFP_KERNEL);
+		if (!rd) {
+			err = -ENOMEM;
+			goto out;
+		}
+		filp->private_data = rd;
+		rd->file = filp;
+		list_add(&rd->list, &HFSPLUS_I(inode).open_dir_list);
+	}
+	memcpy(&rd->key, fd.key, sizeof(struct hfsplus_cat_key));
+out:
+	hfs_find_exit(&hfsplus_handle, &fd);
+	hfsplus_journal_stop(&hfsplus_handle);
+	return err;
+}
+
+static int hfsplus_dir_release(struct inode *inode, struct file *file)
+{
+	struct hfsplus_readdir_data *rd = file->private_data;
+	if (rd) {
+		list_del(&rd->list);
+		kfree(rd);
+	}
+	return 0;
+}
+
+static int hfsplus_create(struct inode *dir, struct dentry *dentry, int mode,
+			  struct nameidata *nd)
+{
+	struct inode *inode;
+	int res;
+	hfsplus_handle_t hfsplus_handle;
+
+	if ((res = hfsplus_journal_start(__FUNCTION__, dir->i_sb, &hfsplus_handle)))
+		return res;
+
+	inode = hfsplus_new_inode(&hfsplus_handle, dir->i_sb, mode);
+	if (!inode) {
+		hfsplus_journal_stop(&hfsplus_handle);
+		return -ENOSPC;
+	}
+
+	res = hfsplus_create_cat(&hfsplus_handle, inode->i_ino, dir, &dentry->d_name, inode);
+	if (res) {
+		inode->i_nlink = 0;
+		hfsplus_delete_inode(&hfsplus_handle, inode);
+		iput(inode);
+		hfsplus_journal_stop(&hfsplus_handle);
+		return res;
+	}
+	hfsplus_instantiate(dentry, inode, inode->i_ino);
+	res = hfsplus_journalled_mark_inode_dirty(__FUNCTION__, &hfsplus_handle, inode);
+	hfsplus_journal_stop(&hfsplus_handle);
+	return res;
+}
+
+static int hfsplus_link(struct dentry *src_dentry, struct inode *dst_dir,
+			struct dentry *dst_dentry)
+{
+	struct super_block *sb = dst_dir->i_sb;
+	struct inode *inode = src_dentry->d_inode;
+	struct inode *src_dir = src_dentry->d_parent->d_inode;
+	hfsplus_handle_t hfsplus_handle;
+	struct qstr str;
+	char name[32];
+	u32 cnid, id;
+	int res;
+
+	if (HFSPLUS_IS_RSRC(inode))
+		return -EPERM;
+
+	if ((res = hfsplus_journal_start(__FUNCTION__, dst_dir->i_sb, &hfsplus_handle)))
+		return res;
+
+	if (inode->i_ino == (u32)(unsigned long)src_dentry->d_fsdata) {
+		for (;;) {
+			get_random_bytes(&id, sizeof(cnid));
+			id &= 0x3fffffff;
+			str.name = name;
+			str.len = sprintf(name, "iNode%d", id);
+			res = hfsplus_rename_cat(&hfsplus_handle, inode->i_ino,
+						 src_dir, &src_dentry->d_name,
+						 HFSPLUS_SB(sb).hidden_dir, &str);
+			if (!res)
+				break;
+			if (res != -EEXIST) {
+				hfsplus_journal_stop(&hfsplus_handle);
+				return res;
+			}
+		}
+		HFSPLUS_I(inode).dev = id;
+		cnid = HFSPLUS_SB(sb).next_cnid++;
+		src_dentry->d_fsdata = (void *)(unsigned long)cnid;
+		res = hfsplus_create_cat(&hfsplus_handle, cnid, src_dir, &src_dentry->d_name, inode);
+		if (res) {
+			/* panic? */
+			hfsplus_journal_stop(&hfsplus_handle);
+			return res;
+		}
+		HFSPLUS_SB(sb).file_count++;
+	}
+	cnid = HFSPLUS_SB(sb).next_cnid++;
+	res = hfsplus_create_cat(&hfsplus_handle, cnid, dst_dir, &dst_dentry->d_name, inode);
+	if (res) {
+		hfsplus_journal_stop(&hfsplus_handle);
+		return res;
+	}
+
+	inc_nlink(inode);
+	hfsplus_instantiate(dst_dentry, inode, cnid);
+	atomic_inc(&inode->i_count);
+	inode->i_ctime = CURRENT_TIME_SEC;
+	res = hfsplus_journalled_mark_inode_dirty(__FUNCTION__, &hfsplus_handle, inode);
+	HFSPLUS_SB(sb).file_count++;
+	sb->s_dirt = 1;
+
+	hfsplus_journal_stop(&hfsplus_handle);
+	return res;
+}
+
+static int hfsplus_unlink(struct inode *dir, struct dentry *dentry)
+{
+	struct super_block *sb = dir->i_sb;
+	struct inode *inode = dentry->d_inode;
+	struct qstr str;
+	char name[32];
+	u32 cnid;
+	int res;
+	hfsplus_handle_t hfsplus_handle;
+
+	if (HFSPLUS_IS_RSRC(inode))
+		return -EPERM;
+
+	if ((res = hfsplus_journal_start(__FUNCTION__, dir->i_sb, &hfsplus_handle)))
+		return res;
+
+	cnid = (u32)(unsigned long)dentry->d_fsdata;
+	if (inode->i_ino == cnid &&
+	    atomic_read(&HFSPLUS_I(inode).opencnt)) {
+		str.name = name;
+		str.len = sprintf(name, "temp%lu", inode->i_ino);
+		res = hfsplus_rename_cat(&hfsplus_handle, inode->i_ino,
+					 dir, &dentry->d_name,
+					 HFSPLUS_SB(sb).hidden_dir, &str);
+		if (!res)
+			inode->i_flags |= S_DEAD;
+		hfsplus_journal_stop(&hfsplus_handle);
+		return res;
+	}
+	res = hfsplus_delete_cat(&hfsplus_handle, cnid, dir, &dentry->d_name);
+	if (res) {
+		hfsplus_journal_stop(&hfsplus_handle);
+		return res;
+	}
+
+	if (inode->i_nlink > 0)
+		drop_nlink(inode);
+	if (inode->i_ino == cnid)
+		clear_nlink(inode);
+	if (!inode->i_nlink) {
+		if (inode->i_ino != cnid) {
+			HFSPLUS_SB(sb).file_count--;
+			if (!atomic_read(&HFSPLUS_I(inode).opencnt)) {
+				res = hfsplus_delete_cat(&hfsplus_handle, inode->i_ino,
+							 HFSPLUS_SB(sb).hidden_dir,
+							 NULL);
+				if (!res)
+					hfsplus_delete_inode(&hfsplus_handle, inode);
+			} else
+				inode->i_flags |= S_DEAD;
+		} else
+			hfsplus_delete_inode(&hfsplus_handle, inode);
+	} else
+		HFSPLUS_SB(sb).file_count--;
+	inode->i_ctime = CURRENT_TIME_SEC;
+	res = hfsplus_journalled_mark_inode_dirty(__FUNCTION__, &hfsplus_handle, inode);
+
+	hfsplus_journal_stop(&hfsplus_handle);
+
+	return res;
+}
+
+static int hfsplus_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	struct inode *inode;
+	hfsplus_handle_t hfsplus_handle;
+	int res;
+
+	if ((res = hfsplus_journal_start(__FUNCTION__, dir->i_sb, &hfsplus_handle)))
+		return res;
+
+	inode = hfsplus_new_inode(&hfsplus_handle, dir->i_sb, S_IFDIR | mode);
+	if (!inode) {
+		hfsplus_journal_stop(&hfsplus_handle);
+		return -ENOSPC;
+	}
+
+	res = hfsplus_create_cat(&hfsplus_handle, inode->i_ino, dir, &dentry->d_name, inode);
+	if (res) {
+		inode->i_nlink = 0;
+		hfsplus_delete_inode(&hfsplus_handle, inode);
+		iput(inode);
+		hfsplus_journal_stop(&hfsplus_handle);
+		return res;
+	}
+	hfsplus_instantiate(dentry, inode, inode->i_ino);
+	res = hfsplus_journalled_mark_inode_dirty(__FUNCTION__, &hfsplus_handle, inode);
+	hfsplus_journal_stop(&hfsplus_handle);
+	return res;
+}
+
+static int hfsplus_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	struct inode *inode;
+	hfsplus_handle_t hfsplus_handle;
+	int res;
+
+	inode = dentry->d_inode;
+	if (inode->i_size != 2)
+		return -ENOTEMPTY;
+	if ((res = hfsplus_journal_start(__FUNCTION__, dir->i_sb, &hfsplus_handle)))
+		return res;
+
+	res = hfsplus_delete_cat(&hfsplus_handle, inode->i_ino, dir, &dentry->d_name);
+	if (res) {
+		hfsplus_journal_stop(&hfsplus_handle);
+		return res;
+	}
+	clear_nlink(inode);
+	inode->i_ctime = CURRENT_TIME_SEC;
+	hfsplus_delete_inode(&hfsplus_handle, inode);
+	res = hfsplus_journalled_mark_inode_dirty(__FUNCTION__, &hfsplus_handle, inode);
+	hfsplus_journal_stop(&hfsplus_handle);
+	return res;
+}
+
+static int hfsplus_symlink(struct inode *dir, struct dentry *dentry,
+			   const char *symname)
+{
+	struct super_block *sb;
+	struct inode *inode;
+	hfsplus_handle_t hfsplus_handle;
+	int res;
+
+	if ((res = hfsplus_journal_start(__FUNCTION__, dir->i_sb, &hfsplus_handle)))
+		return res;
+
+	sb = dir->i_sb;
+	inode = hfsplus_new_inode(&hfsplus_handle, sb, S_IFLNK | S_IRWXUGO);
+	if (!inode) {
+		hfsplus_journal_stop(&hfsplus_handle);
+		return -ENOSPC;
+	}
+
+	res = page_symlink(inode, symname, strlen(symname) + 1);
+	if (res) {
+		inode->i_nlink = 0;
+		hfsplus_delete_inode(&hfsplus_handle, inode);
+		iput(inode);
+		hfsplus_journal_stop(&hfsplus_handle);
+		return res;
+	}
+
+	if ((res = hfsplus_journalled_mark_inode_dirty(__FUNCTION__, &hfsplus_handle, inode)))
+		goto symlink_out;
+	res = hfsplus_create_cat(&hfsplus_handle, inode->i_ino, dir, &dentry->d_name, inode);
+
+	if (!res) {
+		hfsplus_instantiate(dentry, inode, inode->i_ino);
+		res = hfsplus_journalled_mark_inode_dirty(__FUNCTION__, &hfsplus_handle, inode);
+	}
+
+symlink_out:
+	hfsplus_journal_stop(&hfsplus_handle);
+	return res;
+}
+
+static int hfsplus_mknod(struct inode *dir, struct dentry *dentry,
+			 int mode, dev_t rdev)
+{
+	struct super_block *sb;
+	struct inode *inode;
+	hfsplus_handle_t hfsplus_handle;
+	int res;
+
+	if ((res = hfsplus_journal_start(__FUNCTION__, dir->i_sb, &hfsplus_handle)))
+		return res;
+
+	sb = dir->i_sb;
+	inode = hfsplus_new_inode(&hfsplus_handle, sb, mode);
+	if (!inode) {
+		hfsplus_journal_stop(&hfsplus_handle);
+		return -ENOSPC;
+	}
+
+	res = hfsplus_create_cat(&hfsplus_handle, inode->i_ino, dir, &dentry->d_name, inode);
+	if (res) {
+		inode->i_nlink = 0;
+		hfsplus_delete_inode(&hfsplus_handle, inode);
+		iput(inode);
+		hfsplus_journal_stop(&hfsplus_handle);
+		return res;
+	}
+	init_special_inode(inode, mode, rdev);
+	hfsplus_instantiate(dentry, inode, inode->i_ino);
+	res = hfsplus_journalled_mark_inode_dirty(__FUNCTION__, &hfsplus_handle, inode);
+
+	hfsplus_journal_stop(&hfsplus_handle);
+
+	return 0;
+}
+
+static int hfsplus_rename(struct inode *old_dir, struct dentry *old_dentry,
+			  struct inode *new_dir, struct dentry *new_dentry)
+{
+	int res;
+	hfsplus_handle_t hfsplus_handle;
+
+	/* Unlink destination if it already exists */
+	if (new_dentry->d_inode) {
+		res = hfsplus_unlink(new_dir, new_dentry);
+		if (res)
+			return res;
+	}
+
+	if ((res = hfsplus_journal_start(__FUNCTION__, old_dir->i_sb, &hfsplus_handle)))
+		return res;
+
+	res = hfsplus_rename_cat(&hfsplus_handle, (u32)(unsigned long)old_dentry->d_fsdata,
+				 old_dir, &old_dentry->d_name,
+				 new_dir, &new_dentry->d_name);
+	if (!res)
+		new_dentry->d_fsdata = old_dentry->d_fsdata;
+
+	hfsplus_journal_stop(&hfsplus_handle);
+	return res;
+}
+
+const struct inode_operations hfsplus_dir_inode_operations = {
+	.lookup		= hfsplus_lookup,
+	.create		= hfsplus_create,
+	.link		= hfsplus_link,
+	.unlink		= hfsplus_unlink,
+	.mkdir		= hfsplus_mkdir,
+	.rmdir		= hfsplus_rmdir,
+	.symlink	= hfsplus_symlink,
+	.mknod		= hfsplus_mknod,
+	.rename		= hfsplus_rename,
+};
+
+const struct file_operations hfsplus_dir_operations = {
+	.read		= generic_read_dir,
+	.readdir	= hfsplus_readdir,
+	.ioctl          = hfsplus_ioctl,
+	.llseek		= generic_file_llseek,
+	.release	= hfsplus_dir_release,
+};
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/extents.c linux-2.6.32/fs/hfsplus_journal/extents.c
--- linux-2.6.32-old//fs/hfsplus_journal/extents.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/extents.c	2011-11-17 09:00:40.778818402 -0500
@@ -0,0 +1,541 @@
+/*
+ *  linux/fs/hfsplus/extents.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handling of Extents both in catalog and extents overflow trees
+ */
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+/* Compare two extents keys, returns 0 on same, pos/neg for difference */
+int hfsplus_ext_cmp_key(const hfsplus_btree_key *k1,
+			const hfsplus_btree_key *k2)
+{
+	__be32 k1id, k2id;
+	__be32 k1s, k2s;
+
+	k1id = k1->ext.cnid;
+	k2id = k2->ext.cnid;
+	if (k1id != k2id)
+		return be32_to_cpu(k1id) < be32_to_cpu(k2id) ? -1 : 1;
+
+	if (k1->ext.fork_type != k2->ext.fork_type)
+		return k1->ext.fork_type < k2->ext.fork_type ? -1 : 1;
+
+	k1s = k1->ext.start_block;
+	k2s = k2->ext.start_block;
+	if (k1s == k2s)
+		return 0;
+	return be32_to_cpu(k1s) < be32_to_cpu(k2s) ? -1 : 1;
+}
+
+static void hfsplus_ext_build_key(hfsplus_btree_key *key, u32 cnid,
+				  u32 block, u8 type)
+{
+	key->key_len = cpu_to_be16(HFSPLUS_EXT_KEYLEN - 2);
+	key->ext.cnid = cpu_to_be32(cnid);
+	key->ext.start_block = cpu_to_be32(block);
+	key->ext.fork_type = type;
+	key->ext.pad = 0;
+}
+
+static u32 hfsplus_ext_find_block(struct hfsplus_extent *ext, u32 off)
+{
+	int i;
+	u32 count;
+
+	for (i = 0; i < 8; ext++, i++) {
+		count = be32_to_cpu(ext->block_count);
+		if (off < count)
+			return be32_to_cpu(ext->start_block) + off;
+		off -= count;
+	}
+	/* panic? */
+	return 0;
+}
+
+static int hfsplus_ext_block_count(struct hfsplus_extent *ext)
+{
+	int i;
+	u32 count = 0;
+
+	for (i = 0; i < 8; ext++, i++)
+		count += be32_to_cpu(ext->block_count);
+	return count;
+}
+
+static u32 hfsplus_ext_lastblock(struct hfsplus_extent *ext)
+{
+	int i;
+
+	ext += 7;
+	for (i = 0; i < 7; ext--, i++)
+		if (ext->block_count)
+			break;
+	return be32_to_cpu(ext->start_block) + be32_to_cpu(ext->block_count);
+}
+
+static void __hfsplus_ext_write_extent(hfsplus_handle_t *hfsplus_handle, struct inode *inode, struct hfs_find_data *fd)
+{
+	int res;
+
+	hfsplus_ext_build_key(fd->search_key, inode->i_ino, HFSPLUS_I(inode).cached_start,
+			      HFSPLUS_IS_RSRC(inode) ?  HFSPLUS_TYPE_RSRC : HFSPLUS_TYPE_DATA);
+	res = hfs_brec_find(hfsplus_handle, fd);
+	if (HFSPLUS_I(inode).flags & HFSPLUS_FLG_EXT_NEW) {
+		if (res != -ENOENT)
+			return;
+		hfs_brec_insert(hfsplus_handle, fd, HFSPLUS_I(inode).cached_extents, sizeof(hfsplus_extent_rec));
+		HFSPLUS_I(inode).flags &= ~(HFSPLUS_FLG_EXT_DIRTY | HFSPLUS_FLG_EXT_NEW);
+	} else {
+		if (res)
+			return;
+		hfs_bnode_write(hfsplus_handle, fd->bnode, HFSPLUS_I(inode).cached_extents, fd->entryoffset, fd->entrylength);
+		HFSPLUS_I(inode).flags &= ~HFSPLUS_FLG_EXT_DIRTY;
+	}
+}
+
+void hfsplus_ext_write_extent(hfsplus_handle_t *hfsplus_handle, struct inode *inode)
+{
+	if (HFSPLUS_I(inode).flags & HFSPLUS_FLG_EXT_DIRTY) {
+		struct hfs_find_data fd;
+
+		hfs_find_init(HFSPLUS_SB(inode->i_sb).ext_tree, &fd);
+		__hfsplus_ext_write_extent(hfsplus_handle, inode, &fd);
+		hfs_find_exit(hfsplus_handle, &fd);
+	}
+}
+
+static inline int __hfsplus_ext_read_extent(hfsplus_handle_t *hfsplus_handle, struct hfs_find_data *fd,
+					    struct hfsplus_extent *extent,
+					    u32 cnid, u32 block, u8 type)
+{
+	int res;
+
+	hfsplus_ext_build_key(fd->search_key, cnid, block, type);
+	fd->key->ext.cnid = 0;
+	res = hfs_brec_find(hfsplus_handle, fd);
+	if (res && res != -ENOENT)
+		return res;
+	if (fd->key->ext.cnid != fd->search_key->ext.cnid ||
+	    fd->key->ext.fork_type != fd->search_key->ext.fork_type)
+		return -ENOENT;
+	if (fd->entrylength != sizeof(hfsplus_extent_rec))
+		return -EIO;
+	hfs_bnode_read(fd->bnode, extent, fd->entryoffset, sizeof(hfsplus_extent_rec));
+	return 0;
+}
+
+static inline int __hfsplus_ext_cache_extent(hfsplus_handle_t *hfsplus_handle, struct hfs_find_data *fd, struct inode *inode, u32 block)
+{
+	int res;
+
+	if (HFSPLUS_I(inode).flags & HFSPLUS_FLG_EXT_DIRTY)
+		__hfsplus_ext_write_extent(hfsplus_handle, inode, fd);
+
+	res = __hfsplus_ext_read_extent(hfsplus_handle, fd, HFSPLUS_I(inode).cached_extents, inode->i_ino,
+					block, HFSPLUS_IS_RSRC(inode) ? HFSPLUS_TYPE_RSRC : HFSPLUS_TYPE_DATA);
+	if (!res) {
+		HFSPLUS_I(inode).cached_start = be32_to_cpu(fd->key->ext.start_block);
+		HFSPLUS_I(inode).cached_blocks = hfsplus_ext_block_count(HFSPLUS_I(inode).cached_extents);
+	} else {
+		HFSPLUS_I(inode).cached_start = HFSPLUS_I(inode).cached_blocks = 0;
+		HFSPLUS_I(inode).flags &= ~(HFSPLUS_FLG_EXT_DIRTY | HFSPLUS_FLG_EXT_NEW);
+	}
+	return res;
+}
+
+static int hfsplus_ext_read_extent(hfsplus_handle_t *hfsplus_handle, struct inode *inode, u32 block)
+{
+	struct hfs_find_data fd;
+	int res;
+
+	if (block >= HFSPLUS_I(inode).cached_start &&
+	    block < HFSPLUS_I(inode).cached_start + HFSPLUS_I(inode).cached_blocks)
+		return 0;
+
+	hfs_find_init(HFSPLUS_SB(inode->i_sb).ext_tree, &fd);
+	res = __hfsplus_ext_cache_extent(hfsplus_handle, &fd, inode, block);
+	hfs_find_exit(hfsplus_handle, &fd);
+	return res;
+}
+
+/* Get a block at iblock for inode, possibly allocating if create */
+int hfsplus_get_block(struct inode *inode, sector_t iblock,
+		      struct buffer_head *bh_result, int create)
+{
+	struct super_block *sb;
+	int res = -EIO;
+	u32 ablock, dblock, mask;
+	int shift;
+	hfsplus_handle_t *hfsplus_handle, tmp_hfsplus_handle;
+
+	tmp_hfsplus_handle.journaled = !HFSPLUS_JOURNAL_PRESENT;
+	tmp_hfsplus_handle.handle = NULL;
+
+	sb = inode->i_sb;
+
+	/* Journal device */
+	if (HFSPLUS_SB(sb).jnl.journaled == HFSPLUS_JOURNAL_PRESENT) {
+		/* Write Metadata */
+		if (((inode->i_mapping->a_ops == &hfsplus_journalled_btree_aops) || 
+			(inode->i_mapping->a_ops == &hfsplus_journalled_aops)) && create) {
+			hfsplus_handle = hfsplus_jbd_current_handle();
+			if (hfsplus_handle == NULL) {
+				printk("hfsplus_handle is NULL\n");
+				hfsplus_handle = &tmp_hfsplus_handle; 
+			}
+		}
+		else { 
+			hfsplus_handle = &tmp_hfsplus_handle;
+		}
+	}
+	/* Non-journal device */ 
+	else {
+		hfsplus_handle = &tmp_hfsplus_handle;
+	}
+
+	/* Convert inode block to disk allocation block */
+	shift = HFSPLUS_SB(sb).alloc_blksz_shift - sb->s_blocksize_bits;
+	ablock = iblock >> HFSPLUS_SB(sb).fs_shift;
+
+	if (iblock >= HFSPLUS_I(inode).fs_blocks) {
+		if (iblock > HFSPLUS_I(inode).fs_blocks || !create)
+			return -EIO;
+		if (ablock >= HFSPLUS_I(inode).alloc_blocks) {
+			res = hfsplus_file_extend(hfsplus_handle, inode);
+			if (res)
+				return res;
+		}
+	} else
+		create = 0;
+
+	if (ablock < HFSPLUS_I(inode).first_blocks) {
+		dblock = hfsplus_ext_find_block(HFSPLUS_I(inode).first_extents, ablock);
+		goto done;
+	}
+
+	if (inode->i_ino == HFSPLUS_EXT_CNID)
+		return -EIO;
+
+	mutex_lock(&HFSPLUS_I(inode).extents_lock);
+	res = hfsplus_ext_read_extent(hfsplus_handle, inode, ablock);
+	if (!res) {
+		dblock = hfsplus_ext_find_block(HFSPLUS_I(inode).cached_extents, ablock -
+					     HFSPLUS_I(inode).cached_start);
+	} else {
+		mutex_unlock(&HFSPLUS_I(inode).extents_lock);
+		return -EIO;
+	}
+	mutex_unlock(&HFSPLUS_I(inode).extents_lock);
+
+done:
+	dprint(DBG_EXTENT, "get_block(%lu): %llu - %u\n", inode->i_ino, (long long)iblock, dblock);
+	mask = (1 << HFSPLUS_SB(sb).fs_shift) - 1;
+	map_bh(bh_result, sb, (dblock << HFSPLUS_SB(sb).fs_shift) + HFSPLUS_SB(sb).blockoffset + (iblock & mask));
+	if (create) {
+		set_buffer_new(bh_result);
+		HFSPLUS_I(inode).phys_size += sb->s_blocksize;
+		HFSPLUS_I(inode).fs_blocks++;
+		inode_add_bytes(inode, sb->s_blocksize);
+		if (hfsplus_journalled_mark_inode_dirty(__FUNCTION__, hfsplus_handle, inode)) {
+			printk("HFS+-fs: Error in %s()\n", __FUNCTION__);
+			return -1;
+		}
+	}
+	return 0;
+}
+
+static void hfsplus_dump_extent(struct hfsplus_extent *extent)
+{
+	int i;
+
+	dprint(DBG_EXTENT, "   ");
+	for (i = 0; i < 8; i++)
+		dprint(DBG_EXTENT, " %u:%u", be32_to_cpu(extent[i].start_block),
+				 be32_to_cpu(extent[i].block_count));
+	dprint(DBG_EXTENT, "\n");
+}
+
+static int hfsplus_add_extent(struct hfsplus_extent *extent, u32 offset,
+			      u32 alloc_block, u32 block_count)
+{
+	u32 count, start;
+	int i;
+
+	hfsplus_dump_extent(extent);
+	for (i = 0; i < 8; extent++, i++) {
+		count = be32_to_cpu(extent->block_count);
+		if (offset == count) {
+			start = be32_to_cpu(extent->start_block);
+			if (alloc_block != start + count) {
+				if (++i >= 8)
+					return -ENOSPC;
+				extent++;
+				extent->start_block = cpu_to_be32(alloc_block);
+			} else
+				block_count += count;
+			extent->block_count = cpu_to_be32(block_count);
+			return 0;
+		} else if (offset < count)
+			break;
+		offset -= count;
+	}
+	/* panic? */
+	return -EIO;
+}
+
+static int hfsplus_free_extents(hfsplus_handle_t *hfsplus_handle, struct super_block *sb,
+				struct hfsplus_extent *extent,
+				u32 offset, u32 block_nr)
+{
+	u32 count, start;
+	int i;
+
+	hfsplus_dump_extent(extent);
+	for (i = 0; i < 8; extent++, i++) {
+		count = be32_to_cpu(extent->block_count);
+		if (offset == count)
+			goto found;
+		else if (offset < count)
+			break;
+		offset -= count;
+	}
+	/* panic? */
+	return -EIO;
+found:
+	for (;;) {
+		start = be32_to_cpu(extent->start_block);
+		if (count <= block_nr) {
+			hfsplus_block_free(hfsplus_handle, sb, start, count);
+			extent->block_count = 0;
+			extent->start_block = 0;
+			block_nr -= count;
+		} else {
+			count -= block_nr;
+			hfsplus_block_free(hfsplus_handle, sb, start + count, block_nr);
+			extent->block_count = cpu_to_be32(count);
+			block_nr = 0;
+		}
+		if (!block_nr || !i)
+			return 0;
+		i--;
+		extent--;
+		count = be32_to_cpu(extent->block_count);
+	}
+}
+
+int hfsplus_free_fork(hfsplus_handle_t *hfsplus_handle, struct super_block *sb, u32 cnid, struct hfsplus_fork_raw *fork, int type)
+{
+	struct hfs_find_data fd;
+	hfsplus_extent_rec ext_entry;
+	u32 total_blocks, blocks, start;
+	int res, i;
+
+	total_blocks = be32_to_cpu(fork->total_blocks);
+	if (!total_blocks)
+		return 0;
+
+	blocks = 0;
+	for (i = 0; i < 8; i++)
+		blocks += be32_to_cpu(fork->extents[i].block_count);
+
+	res = hfsplus_free_extents(hfsplus_handle, sb, fork->extents, blocks, blocks);
+	if (res)
+		return res;
+	if (total_blocks == blocks)
+		return 0;
+
+	hfs_find_init(HFSPLUS_SB(sb).ext_tree, &fd);
+	do {
+		res = __hfsplus_ext_read_extent(hfsplus_handle, &fd, ext_entry, cnid,
+						total_blocks, type);
+		if (res)
+			break;
+		start = be32_to_cpu(fd.key->ext.start_block);
+		hfsplus_free_extents(hfsplus_handle, sb, ext_entry,
+				     total_blocks - start,
+				     total_blocks);
+		hfs_brec_remove(hfsplus_handle, &fd);
+		total_blocks = start;
+	} while (total_blocks > blocks);
+	hfs_find_exit(hfsplus_handle, &fd);
+
+	return res;
+}
+
+int hfsplus_file_extend(hfsplus_handle_t *hfsplus_handle, struct inode *inode)
+{
+	struct super_block *sb = inode->i_sb;
+	u32 start, len, goal;
+	int res;
+
+	if (HFSPLUS_SB(sb).alloc_file->i_size * 8 < HFSPLUS_SB(sb).total_blocks - HFSPLUS_SB(sb).free_blocks + 8) {
+		// extend alloc file
+		printk(KERN_ERR "hfs: extend alloc file! (%Lu,%u,%u)\n", HFSPLUS_SB(sb).alloc_file->i_size * 8,
+			HFSPLUS_SB(sb).total_blocks, HFSPLUS_SB(sb).free_blocks);
+		return -ENOSPC;
+	}
+
+	mutex_lock(&HFSPLUS_I(inode).extents_lock);
+	if (HFSPLUS_I(inode).alloc_blocks == HFSPLUS_I(inode).first_blocks)
+		goal = hfsplus_ext_lastblock(HFSPLUS_I(inode).first_extents);
+	else {
+		res = hfsplus_ext_read_extent(hfsplus_handle, inode, HFSPLUS_I(inode).alloc_blocks);
+		if (res)
+			goto out;
+		goal = hfsplus_ext_lastblock(HFSPLUS_I(inode).cached_extents);
+	}
+
+	len = HFSPLUS_I(inode).clump_blocks;
+	start = hfsplus_block_allocate(hfsplus_handle, sb, HFSPLUS_SB(sb).total_blocks, goal, &len);
+	if (start >= HFSPLUS_SB(sb).total_blocks) {
+		start = hfsplus_block_allocate(hfsplus_handle, sb, goal, 0, &len);
+		if (start >= goal) {
+			res = -ENOSPC;
+			goto out;
+		}
+	}
+
+	dprint(DBG_EXTENT, "extend %lu: %u,%u\n", inode->i_ino, start, len);
+	if (HFSPLUS_I(inode).alloc_blocks <= HFSPLUS_I(inode).first_blocks) {
+		if (!HFSPLUS_I(inode).first_blocks) {
+			dprint(DBG_EXTENT, "first extents\n");
+			/* no extents yet */
+			HFSPLUS_I(inode).first_extents[0].start_block = cpu_to_be32(start);
+			HFSPLUS_I(inode).first_extents[0].block_count = cpu_to_be32(len);
+			res = 0;
+		} else {
+			/* try to append to extents in inode */
+			res = hfsplus_add_extent(HFSPLUS_I(inode).first_extents,
+						 HFSPLUS_I(inode).alloc_blocks,
+						 start, len);
+			if (res == -ENOSPC)
+				goto insert_extent;
+		}
+		if (!res) {
+			hfsplus_dump_extent(HFSPLUS_I(inode).first_extents);
+			HFSPLUS_I(inode).first_blocks += len;
+		}
+	} else {
+		res = hfsplus_add_extent(HFSPLUS_I(inode).cached_extents,
+					 HFSPLUS_I(inode).alloc_blocks -
+					 HFSPLUS_I(inode).cached_start,
+					 start, len);
+		if (!res) {
+			hfsplus_dump_extent(HFSPLUS_I(inode).cached_extents);
+			HFSPLUS_I(inode).flags |= HFSPLUS_FLG_EXT_DIRTY;
+			HFSPLUS_I(inode).cached_blocks += len;
+		} else if (res == -ENOSPC)
+			goto insert_extent;
+	}
+out:
+	mutex_unlock(&HFSPLUS_I(inode).extents_lock);
+	if (!res) {
+		HFSPLUS_I(inode).alloc_blocks += len;
+		res = hfsplus_journalled_mark_inode_dirty(__FUNCTION__, hfsplus_handle, inode);
+	}
+	return res;
+
+insert_extent:
+	dprint(DBG_EXTENT, "insert new extent\n");
+	hfsplus_ext_write_extent(hfsplus_handle, inode);
+
+	memset(HFSPLUS_I(inode).cached_extents, 0, sizeof(hfsplus_extent_rec));
+	HFSPLUS_I(inode).cached_extents[0].start_block = cpu_to_be32(start);
+	HFSPLUS_I(inode).cached_extents[0].block_count = cpu_to_be32(len);
+	hfsplus_dump_extent(HFSPLUS_I(inode).cached_extents);
+	HFSPLUS_I(inode).flags |= HFSPLUS_FLG_EXT_DIRTY | HFSPLUS_FLG_EXT_NEW;
+	HFSPLUS_I(inode).cached_start = HFSPLUS_I(inode).alloc_blocks;
+	HFSPLUS_I(inode).cached_blocks = len;
+
+	res = 0;
+	goto out;
+}
+
+void hfsplus_file_truncate(struct inode *inode)
+{
+	struct super_block *sb = inode->i_sb;
+	struct hfs_find_data fd;
+	u32 alloc_cnt, blk_cnt, start;
+	int res;
+	hfsplus_handle_t hfsplus_handle;
+
+	dprint(DBG_INODE, "truncate: %lu, %Lu -> %Lu\n", inode->i_ino,
+	       (long long)HFSPLUS_I(inode).phys_size, inode->i_size);
+	if (inode->i_size > HFSPLUS_I(inode).phys_size) {
+		struct address_space *mapping = inode->i_mapping;
+		struct page *page;
+		void *fsdata;
+		u32 size = inode->i_size;
+		int res;
+
+		res = pagecache_write_begin(NULL, mapping, size, 0,
+						AOP_FLAG_UNINTERRUPTIBLE,
+						&page, &fsdata);
+		if (res)
+			return;
+		res = pagecache_write_end(NULL, mapping, size, 0, 0, page, fsdata);
+		if (res < 0)
+			return;
+		if (hfsplus_journal_start(__FUNCTION__, sb, &hfsplus_handle))
+			return;
+		hfsplus_journalled_mark_inode_dirty(__FUNCTION__, &hfsplus_handle, inode);
+		hfsplus_journal_stop(&hfsplus_handle);
+		return;
+	} else if (inode->i_size == HFSPLUS_I(inode).phys_size)
+		return;
+
+	if (hfsplus_journal_start(__FUNCTION__, sb, &hfsplus_handle))
+		return;
+
+	blk_cnt = (inode->i_size + HFSPLUS_SB(sb).alloc_blksz - 1) >> HFSPLUS_SB(sb).alloc_blksz_shift;
+	alloc_cnt = HFSPLUS_I(inode).alloc_blocks;
+	if (blk_cnt == alloc_cnt)
+		goto out;
+
+	mutex_lock(&HFSPLUS_I(inode).extents_lock);
+	hfs_find_init(HFSPLUS_SB(sb).ext_tree, &fd);
+	while (1) {
+		if (alloc_cnt == HFSPLUS_I(inode).first_blocks) {
+			hfsplus_free_extents(&hfsplus_handle, sb, HFSPLUS_I(inode).first_extents,
+					     alloc_cnt, alloc_cnt - blk_cnt);
+			hfsplus_dump_extent(HFSPLUS_I(inode).first_extents);
+			HFSPLUS_I(inode).first_blocks = blk_cnt;
+			break;
+		}
+		res = __hfsplus_ext_cache_extent(&hfsplus_handle, &fd, inode, alloc_cnt);
+		if (res)
+			break;
+		start = HFSPLUS_I(inode).cached_start;
+		hfsplus_free_extents(&hfsplus_handle, sb, HFSPLUS_I(inode).cached_extents,
+				     alloc_cnt - start, alloc_cnt - blk_cnt);
+		hfsplus_dump_extent(HFSPLUS_I(inode).cached_extents);
+		if (blk_cnt > start) {
+			HFSPLUS_I(inode).flags |= HFSPLUS_FLG_EXT_DIRTY;
+			break;
+		}
+		alloc_cnt = start;
+		HFSPLUS_I(inode).cached_start = HFSPLUS_I(inode).cached_blocks = 0;
+		HFSPLUS_I(inode).flags &= ~(HFSPLUS_FLG_EXT_DIRTY | HFSPLUS_FLG_EXT_NEW);
+		hfs_brec_remove(&hfsplus_handle, &fd);
+	}
+	hfs_find_exit(&hfsplus_handle, &fd);
+	mutex_unlock(&HFSPLUS_I(inode).extents_lock);
+
+	HFSPLUS_I(inode).alloc_blocks = blk_cnt;
+out:
+	HFSPLUS_I(inode).phys_size = inode->i_size;
+	HFSPLUS_I(inode).fs_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;
+	inode_set_bytes(inode, HFSPLUS_I(inode).fs_blocks << sb->s_blocksize_bits);
+	hfsplus_journalled_mark_inode_dirty(__FUNCTION__, &hfsplus_handle, inode);
+	hfsplus_journal_stop(&hfsplus_handle);
+}
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/hfsplus_fs.h linux-2.6.32/fs/hfsplus_journal/hfsplus_fs.h
--- linux-2.6.32-old//fs/hfsplus_journal/hfsplus_fs.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/hfsplus_fs.h	2011-11-17 09:00:40.778818402 -0500
@@ -0,0 +1,500 @@
+/*
+ *  linux/include/linux/hfsplus_fs.h
+ *
+ * Copyright (C) 1999
+ * Brad Boyer (flar@pants.nu)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ */
+
+#ifndef _LINUX_HFSPLUS_FS_H
+#define _LINUX_HFSPLUS_FS_H
+
+#include <linux/fs.h>
+#include <linux/mutex.h>
+#include <linux/buffer_head.h>
+#include "hfsplus_jbd.h"
+#include "hfsplus_raw.h"
+
+#define DBG_BNODE_REFS	0x00000001
+#define DBG_BNODE_MOD	0x00000002
+#define DBG_CAT_MOD	0x00000004
+#define DBG_INODE	0x00000008
+#define DBG_SUPER	0x00000010
+#define DBG_EXTENT	0x00000020
+#define DBG_BITMAP	0x00000040
+#define DBG_JOURNAL	0x00000080
+#define DBG_JREPLAY	0x00000100
+#define DBG_JTRANS	0x00000200
+#define DBG_JCOMMIT	0x00000400
+#define DBG_JCHKPT	0x00000800
+
+//#define DBG_MASK	(DBG_EXTENT|DBG_INODE|DBG_BNODE_MOD)
+//#define DBG_MASK	(DBG_BNODE_MOD|DBG_CAT_MOD|DBG_INODE)
+//#define DBG_MASK	(DBG_CAT_MOD|DBG_BNODE_REFS|DBG_INODE|DBG_EXTENT)
+//#define DBG_MASK	(0)
+#define DBG_MASK		(DBG_JOURNAL|DBG_JREPLAY)
+
+#define HFSPLUS_JOURNAL_PRESENT			1
+#define HFSPLUS_JOURNAL_CONSISTENT		0
+#define HFSPLUS_JOURNAL_INCONSISTENT	1
+#define HFSPLUS_JOURNAL_UIBYTE			0x5A /* Unimportant byte value */
+#define HFSPLUS_JOURNAL_SUCCESS			0
+#define HFSPLUS_JOURNAL_FAIL				1
+#define HFSPLUS_JOURNAL_SWAP				1
+
+#define dprint(flg, fmt, args...) \
+	if (flg & DBG_MASK) printk(fmt , ## args)
+
+/* Runtime config options */
+#define HFSPLUS_DEF_CR_TYPE    0x3F3F3F3F  /* '????' */
+
+#define HFSPLUS_TYPE_DATA 0x00
+#define HFSPLUS_TYPE_RSRC 0xFF
+
+typedef int (*btree_keycmp)(const hfsplus_btree_key *, const hfsplus_btree_key *);
+
+#define NODE_HASH_SIZE	256
+
+/* An HFS+ BTree held in memory */
+struct hfs_btree {
+	struct super_block *sb;
+	struct inode *inode;
+	btree_keycmp keycmp;
+
+	u32 cnid;
+	u32 root;
+	u32 leaf_count;
+	u32 leaf_head;
+	u32 leaf_tail;
+	u32 node_count;
+	u32 free_nodes;
+	u32 attributes;
+
+	unsigned int node_size;
+	unsigned int node_size_shift;
+	unsigned int max_key_len;
+	unsigned int depth;
+
+	//unsigned int map1_size, map_size;
+	struct semaphore tree_lock;
+
+	unsigned int pages_per_bnode;
+	spinlock_t hash_lock;
+	struct hfs_bnode *node_hash[NODE_HASH_SIZE];
+	int node_hash_cnt;
+};
+
+struct page;
+
+/* An HFS+ BTree node in memory */
+struct hfs_bnode {
+	struct hfs_btree *tree;
+
+	u32 prev;
+	u32 this;
+	u32 next;
+	u32 parent;
+
+	u16 num_recs;
+	u8 type;
+	u8 height;
+
+	struct hfs_bnode *next_hash;
+	unsigned long flags;
+	wait_queue_head_t lock_wq;
+	atomic_t refcnt;
+	unsigned int page_offset;
+	struct page *page[0];
+};
+
+#define HFS_BNODE_LOCK		0
+#define HFS_BNODE_ERROR		1
+#define HFS_BNODE_NEW		2
+#define HFS_BNODE_DIRTY		3
+#define HFS_BNODE_DELETED	4
+
+/* An HFS+ Journal held in memory */
+struct hfsplus_journal {
+	struct semaphore jnl_lock;
+	u32 journaled;
+	u32 flags;
+
+	/* Journal info block specific */
+	struct buffer_head *jib_bh;
+	struct hfsplus_journal_info_block *jibhdr;
+	u64 jib_offset;
+
+	/* Journal header specific */
+	struct buffer_head *jh_bh;
+	u32 jh_bh_size;
+	u64 jh_offset;
+	struct hfsplus_journal_header *jhdr;
+
+	/* block number of meta-data */
+	u32 ext_block;
+	u32 alloc_block;
+	u32 catalog_block;
+	u32 attr_block;
+
+	/* Pointer of JBD */
+	struct hfsplus_jbd_s *s_journal;
+
+	/* Maximum number of blocks allowed in a single transaction */
+	u16 journal_maxblock;
+
+	struct super_block *sbp;
+};
+
+/*
+ * HFS+ superblock info (built from Volume Header on disk)
+ */
+
+struct hfsplus_vh;
+struct hfs_btree;
+
+struct hfsplus_sb_info {
+	struct buffer_head *s_vhbh;
+	struct hfsplus_vh *s_vhdr;
+	struct hfs_btree *ext_tree;
+	struct hfs_btree *cat_tree;
+	struct hfs_btree *attr_tree;
+	struct inode *alloc_file;
+	struct inode *hidden_dir;
+	struct nls_table *nls;
+
+	/* Runtime variables */
+	u32 blockoffset;
+	u32 sect_count;
+	int fs_shift;
+
+	/* Stuff in host order from Vol Header */
+	struct hfsplus_journal jnl;
+	u32 alloc_blksz;
+	int alloc_blksz_shift;
+	u32 total_blocks;
+	u32 free_blocks;
+	u32 next_alloc;
+	u32 next_cnid;
+	u32 file_count;
+	u32 folder_count;
+	u32 data_clump_blocks, rsrc_clump_blocks;
+
+	/* Config options */
+	u32 creator;
+	u32 type;
+
+	umode_t umask;
+	uid_t uid;
+	gid_t gid;
+
+	int part, session;
+
+	unsigned long flags;
+
+	struct hlist_head rsrc_inodes;
+};
+
+#define HFSPLUS_SB_WRITEBACKUP	0x0001
+#define HFSPLUS_SB_NODECOMPOSE	0x0002
+#define HFSPLUS_SB_FORCE	0x0004
+#define HFSPLUS_SB_HFSX		0x0008
+#define HFSPLUS_SB_CASEFOLD	0x0010
+
+
+struct hfsplus_inode_info {
+	struct mutex extents_lock;
+	u32 clump_blocks, alloc_blocks;
+	sector_t fs_blocks;
+	/* Allocation extents from catalog record or volume header */
+	hfsplus_extent_rec first_extents;
+	u32 first_blocks;
+	hfsplus_extent_rec cached_extents;
+	u32 cached_start, cached_blocks;
+	atomic_t opencnt;
+
+	struct inode *rsrc_inode;
+	unsigned long flags;
+
+	__be32 create_date;
+	/* Device number in hfsplus_permissions in catalog */
+	u32 dev;
+	/* BSD system and user file flags */
+	u8 rootflags;
+	u8 userflags;
+
+	struct list_head open_dir_list;
+	loff_t phys_size;
+	struct inode vfs_inode;
+};
+
+#define HFSPLUS_FLG_RSRC	0x0001
+#define HFSPLUS_FLG_EXT_DIRTY	0x0002
+#define HFSPLUS_FLG_EXT_NEW	0x0004
+
+#define HFSPLUS_IS_DATA(inode)   (!(HFSPLUS_I(inode).flags & HFSPLUS_FLG_RSRC))
+#define HFSPLUS_IS_RSRC(inode)   (HFSPLUS_I(inode).flags & HFSPLUS_FLG_RSRC)
+
+struct hfs_find_data {
+	/* filled by caller */
+	hfsplus_btree_key *search_key;
+	hfsplus_btree_key *key;
+	/* filled by find */
+	struct hfs_btree *tree;
+	struct hfs_bnode *bnode;
+	/* filled by findrec */
+	int record;
+	int keyoffset, keylength;
+	int entryoffset, entrylength;
+};
+
+struct hfsplus_readdir_data {
+	struct list_head list;
+	struct file *file;
+	struct hfsplus_cat_key key;
+};
+
+#define hfs_btree_open hfsplus_btree_open
+#define hfs_btree_close hfsplus_btree_close
+#define hfs_btree_write hfsplus_btree_write
+#define hfs_bmap_alloc hfsplus_bmap_alloc
+#define hfs_bmap_free hfsplus_bmap_free
+#define hfs_bnode_read hfsplus_bnode_read
+#define hfs_bnode_read_u16 hfsplus_bnode_read_u16
+#define hfs_bnode_read_u8 hfsplus_bnode_read_u8
+#define hfs_bnode_read_key hfsplus_bnode_read_key
+#define hfs_bnode_write hfsplus_bnode_write
+#define hfs_bnode_write_u16 hfsplus_bnode_write_u16
+#define hfs_bnode_clear hfsplus_bnode_clear
+#define hfs_bnode_copy hfsplus_bnode_copy
+#define hfs_bnode_move hfsplus_bnode_move
+#define hfs_bnode_dump hfsplus_bnode_dump
+#define hfs_bnode_unlink hfsplus_bnode_unlink
+#define hfs_bnode_findhash hfsplus_bnode_findhash
+#define hfs_bnode_find hfsplus_bnode_find
+#define hfs_bnode_unhash hfsplus_bnode_unhash
+#define hfs_bnode_free hfsplus_bnode_free
+#define hfs_bnode_create hfsplus_bnode_create
+#define hfs_bnode_get hfsplus_bnode_get
+#define hfs_bnode_put hfsplus_bnode_put
+#define hfs_brec_lenoff hfsplus_brec_lenoff
+#define hfs_brec_keylen hfsplus_brec_keylen
+#define hfs_brec_insert hfsplus_brec_insert
+#define hfs_brec_remove hfsplus_brec_remove
+#define hfs_find_init hfsplus_find_init
+#define hfs_find_exit hfsplus_find_exit
+#define __hfs_brec_find __hplusfs_brec_find
+#define hfs_brec_find hfsplus_brec_find
+#define hfs_brec_read hfsplus_brec_read
+#define hfs_brec_goto hfsplus_brec_goto
+#define hfs_part_find hfsplus_part_find
+
+/*
+ * definitions for ext2 flag ioctls (linux really needs a generic
+ * interface for this).
+ */
+
+/* ext2 ioctls (EXT2_IOC_GETFLAGS and EXT2_IOC_SETFLAGS) to support
+ * chattr/lsattr */
+#define HFSPLUS_IOC_EXT2_GETFLAGS	FS_IOC_GETFLAGS
+#define HFSPLUS_IOC_EXT2_SETFLAGS	FS_IOC_SETFLAGS
+
+
+/*
+ * Functions in any *.c used in other files
+ */
+
+/* bitmap.c */
+int hfsplus_block_allocate(hfsplus_handle_t *, struct super_block *, u32, u32, u32 *);
+int hfsplus_block_free(hfsplus_handle_t *, struct super_block *, u32, u32);
+
+/* btree.c */
+struct hfs_btree *hfs_btree_open(struct super_block *, u32);
+void hfs_btree_close(struct hfs_btree *);
+void hfs_btree_write(hfsplus_handle_t *, struct hfs_btree *);
+struct hfs_bnode *hfs_bmap_alloc(hfsplus_handle_t *, struct hfs_btree *);
+void hfs_bmap_free(hfsplus_handle_t *, struct hfs_bnode *);
+
+/* bnode.c */
+void hfs_bnode_read(struct hfs_bnode *, void *, int, int);
+u16 hfs_bnode_read_u16(struct hfs_bnode *, int);
+u8 hfs_bnode_read_u8(struct hfs_bnode *, int);
+void hfs_bnode_read_key(struct hfs_bnode *, void *, int);
+void hfs_bnode_write(hfsplus_handle_t *, struct hfs_bnode *, void *, int, int);
+void hfs_bnode_write_u16(hfsplus_handle_t *, struct hfs_bnode *, int, u16);
+void hfs_bnode_clear(hfsplus_handle_t *, struct hfs_bnode *, int, int);
+void hfs_bnode_copy(hfsplus_handle_t *, struct hfs_bnode *, int,
+		    struct hfs_bnode *, int, int);
+void hfs_bnode_move(hfsplus_handle_t *, struct hfs_bnode *, int, int, int);
+void hfs_bnode_dump(struct hfs_bnode *);
+void hfs_bnode_unlink(hfsplus_handle_t *, struct hfs_bnode *);
+struct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *, u32);
+struct hfs_bnode *hfs_bnode_find(hfsplus_handle_t *, struct hfs_btree *, u32);
+void hfs_bnode_unhash(struct hfs_bnode *);
+void hfs_bnode_free(struct hfs_bnode *);
+struct hfs_bnode *hfs_bnode_create(hfsplus_handle_t *, struct hfs_btree *, u32);
+void hfs_bnode_get(struct hfs_bnode *);
+void hfs_bnode_put(hfsplus_handle_t *, struct hfs_bnode *);
+
+/* brec.c */
+u16 hfs_brec_lenoff(struct hfs_bnode *, u16, u16 *);
+u16 hfs_brec_keylen(struct hfs_bnode *, u16);
+int hfs_brec_insert(hfsplus_handle_t *, struct hfs_find_data *, void *, int);
+int hfs_brec_remove(hfsplus_handle_t *, struct hfs_find_data *);
+
+/* bfind.c */
+int hfs_find_init(struct hfs_btree *, struct hfs_find_data *);
+void hfs_find_exit(hfsplus_handle_t *, struct hfs_find_data *);
+int hfsplus_journalled_find_init(struct hfs_btree *, struct hfs_find_data *);
+void hfsplus_journalled_find_exit(hfsplus_handle_t *, struct hfs_find_data *);
+int __hfs_brec_find(struct hfs_bnode *, struct hfs_find_data *);
+int hfs_brec_find(hfsplus_handle_t *, struct hfs_find_data *);
+int hfs_brec_read(hfsplus_handle_t *, struct hfs_find_data *, void *, int);
+int hfs_brec_goto(hfsplus_handle_t *, struct hfs_find_data *, int);
+
+/* catalog.c */
+int hfsplus_cat_case_cmp_key(const hfsplus_btree_key *, const hfsplus_btree_key *);
+int hfsplus_cat_bin_cmp_key(const hfsplus_btree_key *, const hfsplus_btree_key *);
+void hfsplus_cat_build_key(struct super_block *sb, hfsplus_btree_key *, u32, struct qstr *);
+int hfsplus_find_cat(hfsplus_handle_t *, struct super_block *, u32, struct hfs_find_data *);
+int hfsplus_create_cat(hfsplus_handle_t *, u32, struct inode *, struct qstr *, struct inode *);
+int hfsplus_delete_cat(hfsplus_handle_t *, u32, struct inode *, struct qstr *);
+int hfsplus_rename_cat(hfsplus_handle_t *, u32, struct inode *, struct qstr *,
+		       struct inode *, struct qstr *);
+
+/* dir.c */
+extern const struct inode_operations hfsplus_dir_inode_operations;
+extern const struct file_operations hfsplus_dir_operations;
+
+/* extents.c */
+int hfsplus_ext_cmp_key(const hfsplus_btree_key *, const hfsplus_btree_key *);
+void hfsplus_ext_write_extent(hfsplus_handle_t *, struct inode *);
+int hfsplus_get_block(struct inode *, sector_t, struct buffer_head *, int);
+int hfsplus_free_fork(hfsplus_handle_t *handle, struct super_block *, u32, struct hfsplus_fork_raw *, int);
+int hfsplus_file_extend(hfsplus_handle_t *, struct inode *);
+void hfsplus_file_truncate(struct inode *);
+
+/* inode.c */
+extern const struct address_space_operations hfsplus_aops;
+extern const struct address_space_operations hfsplus_btree_aops;
+extern const struct dentry_operations hfsplus_dentry_operations;
+extern const struct address_space_operations hfsplus_journalled_btree_aops;
+extern const struct address_space_operations hfsplus_journalled_aops;
+void hfsplus_inode_read_fork(struct inode *, struct hfsplus_fork_raw *);
+void hfsplus_inode_write_fork(struct inode *, struct hfsplus_fork_raw *);
+int hfsplus_cat_read_inode(struct inode *, struct hfs_find_data *);
+int hfsplus_cat_write_inode(hfsplus_handle_t *, struct inode *);
+struct inode *hfsplus_new_inode(hfsplus_handle_t *, struct super_block *, int);
+void hfsplus_delete_inode(hfsplus_handle_t *, struct inode *);
+int hfsplus_do_journal_get_write_access(hfsplus_handle_t *, struct buffer_head *);
+int hfsplus_commit_write_fn(hfsplus_handle_t *, struct buffer_head *);
+int hfsplus_walk_page_buffers(hfsplus_handle_t *, struct buffer_head *, unsigned ,
+				unsigned , int *, int (*fn)(hfsplus_handle_t *, struct buffer_head *));
+
+/* ioctl.c */
+int hfsplus_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg);
+int hfsplus_setxattr(struct dentry *dentry, const char *name,
+		     const void *value, size_t size, int flags);
+ssize_t hfsplus_getxattr(struct dentry *dentry, const char *name,
+			 void *value, size_t size);
+ssize_t hfsplus_listxattr(struct dentry *dentry, char *buffer, size_t size);
+
+/* options.c */
+int hfsplus_parse_options(char *, struct hfsplus_sb_info *);
+void hfsplus_fill_defaults(struct hfsplus_sb_info *);
+int hfsplus_show_options(struct seq_file *, struct vfsmount *);
+
+/* super.c */
+struct inode *hfsplus_iget(struct super_block *, unsigned long);
+
+/* tables.c */
+extern u16 hfsplus_case_fold_table[];
+extern u16 hfsplus_decompose_table[];
+extern u16 hfsplus_compose_table[];
+
+/* unicode.c */
+int hfsplus_strcasecmp(const struct hfsplus_unistr *, const struct hfsplus_unistr *);
+int hfsplus_strcmp(const struct hfsplus_unistr *, const struct hfsplus_unistr *);
+int hfsplus_uni2asc(struct super_block *, const struct hfsplus_unistr *, char *, int *);
+int hfsplus_asc2uni(struct super_block *, struct hfsplus_unistr *, const char *, int);
+int hfsplus_hash_dentry(struct dentry *dentry, struct qstr *str);
+int hfsplus_compare_dentry(struct dentry *dentry, struct qstr *s1, struct qstr *s2);
+
+/* wrapper.c */
+int hfsplus_read_wrapper(struct super_block *);
+
+int hfs_part_find(struct super_block *, sector_t *, sector_t *);
+
+/* journal.c */
+void hfsplus_journalled_init(struct super_block *, struct hfsplus_vh *);
+void hfsplus_journalled_deinit(struct super_block *);
+int hfsplus_journalled_create(struct super_block *);
+int hfsplus_journalled_check(struct super_block *);
+void print_volume_header(struct super_block *);
+void swap_block_list_header(struct hfsplus_blhdr *);
+hfsplus_jbd_t * hfsplus_get_dev_journal(struct super_block *);
+int hfsplus_journalled_mark_inode_dirty(const char *, hfsplus_handle_t *, struct inode *);
+int hfsplus_journalled_set_page_dirty(hfsplus_handle_t *, struct page *);
+int hfsplus_journal_start(const char *, struct super_block *sb, hfsplus_handle_t *hfsplus_handle);
+int hfsplus_journal_stop(hfsplus_handle_t *);
+int hfsplus_journal_get_write_access(const char *, hfsplus_handle_t *, struct buffer_head *);
+int hfsplus_journal_dirty_metadata(const char *, struct buffer_head *, hfsplus_handle_t *);
+int hfsplus_force_commit(struct super_block *);
+void hfsplus_jhdr_checksum_calculate(hfsplus_jbd_t *);
+void hfsplus_journal_header_start_update(hfsplus_jbd_t *, unsigned long);
+void hfsplus_journal_header_end_update(hfsplus_jbd_t *, struct hfsplus_journal_header *);
+void hfsplus_journal_mark_journal_empty(hfsplus_jbd_t *);
+void hfsplus_test_block_list_header(const char *, struct hfsplus_journal_header *, struct hfsplus_journal *);
+
+/* access macros */
+/*
+static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)
+{
+	return sb->s_fs_info;
+}
+static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)
+{
+	return list_entry(inode, struct hfsplus_inode_info, vfs_inode);
+}
+*/
+#define HFSPLUS_SB(super)	(*(struct hfsplus_sb_info *)(super)->s_fs_info)
+#define HFSPLUS_I(inode)	(*list_entry(inode, struct hfsplus_inode_info, vfs_inode))
+
+#if 1
+#define hfsplus_kmap(p)		({ struct page *__p = (p); kmap(__p); })
+#define hfsplus_kunmap(p)	({ struct page *__p = (p); kunmap(__p); __p; })
+#else
+#define hfsplus_kmap(p)		kmap(p)
+#define hfsplus_kunmap(p)	kunmap(p)
+#endif
+
+#define sb_bread512(sb, sec, data) ({			\
+	struct buffer_head *__bh;			\
+	sector_t __block;				\
+	loff_t __start;					\
+	int __offset;					\
+							\
+	__start = (loff_t)(sec) << HFSPLUS_SECTOR_SHIFT;\
+	__block = __start >> (sb)->s_blocksize_bits;	\
+	__offset = __start & ((sb)->s_blocksize - 1);	\
+	__bh = sb_bread((sb), __block);			\
+	if (likely(__bh != NULL))			\
+		data = (void *)(__bh->b_data + __offset);\
+	else						\
+		data = NULL;				\
+	__bh;						\
+})
+
+/* time macros */
+#define __hfsp_mt2ut(t)		(be32_to_cpu(t) - 2082844800U)
+#define __hfsp_ut2mt(t)		(cpu_to_be32(t + 2082844800U))
+
+/* compatibility */
+#define hfsp_mt2ut(t)		(struct timespec){ .tv_sec = __hfsp_mt2ut(t) }
+#define hfsp_ut2mt(t)		__hfsp_ut2mt((t).tv_sec)
+#define hfsp_now2mt()		__hfsp_ut2mt(get_seconds())
+
+#define kdev_t_to_nr(x)		(x)
+
+#endif
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/hfsplus_jbd.h linux-2.6.32/fs/hfsplus_journal/hfsplus_jbd.h
--- linux-2.6.32-old//fs/hfsplus_journal/hfsplus_jbd.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/hfsplus_jbd.h	2011-11-17 09:00:40.778818402 -0500
@@ -0,0 +1,1109 @@
+/*
+ * linux/include/linux/jbd.h
+ * 
+ * Written by Stephen C. Tweedie <sct@redhat.com>
+ *
+ * Copyright 1998-2000 Red Hat, Inc --- All Rights Reserved
+ *
+ * This file is part of the Linux kernel and is made available under
+ * the terms of the GNU General Public License, version 2, or at your
+ * option, any later version, incorporated herein by reference.
+ *
+ * Definitions for transaction data structures for the buffer cache
+ * filesystem journaling support.
+ */
+
+#ifndef _LINUX_HFSPLUS_JBD_H
+#define _LINUX_HFSPLUS_JBD_H
+
+#include <linux/types.h>
+#include <linux/buffer_head.h>
+#include "hfsplus_journal_head.h"
+#include <linux/stddef.h>
+#include <linux/bit_spinlock.h>
+#include <linux/mutex.h>
+#include <linux/timer.h>
+#include <linux/lockdep.h>
+#include "hfsplus_raw.h"
+#include <linux/freezer.h>
+#define hfsplus_jbd_oom_retry 1
+
+#define HFSPLUS_JOURNAL_MAC_COMPATIBLE
+#define HFSPLUS_JBD_MAGIC_NUMBER	0x9876
+
+/*
+ * Define JBD_PARANIOD_IOFAIL to cause a kernel BUG() if ext3 finds
+ * certain classes of error which can occur due to failed IOs.  Under
+ * normal use we want ext3 to continue after such errors, because
+ * hardware _can_ fail, but for debugging purposes when running tests on
+ * known-good hardware we may want to trap these errors.
+ */
+#undef JBD_PARANOID_IOFAIL
+
+/*
+ * The default maximum commit age, in seconds.
+ */
+#define HFSPLUS_JBD_DEFAULT_MAX_COMMIT_AGE 5
+
+#if 0
+#define hfsplus_jbd_debug(n, f, a...)	\
+			printk(KERN_INFO "(%s, %d):", __FUNCTION__, __LINE__); \
+			printk(f, ## a); 
+#else
+#define hfsplus_jbd_debug(f, a...)	
+#endif
+
+static inline void *hfsplus_jbd_alloc(size_t size, gfp_t flags)
+{
+	return (void *)__get_free_pages(flags, get_order(size));
+}
+
+static inline void hfsplus_jbd_free(void *ptr, size_t size)
+{
+	free_pages((unsigned long)ptr, get_order(size));
+};
+
+#define JFS_MIN_JOURNAL_BLOCKS 1024
+
+#ifdef __KERNEL__
+
+typedef struct hfsplus_handle    hfsplus_handle_t;
+/**
+ * typedef hfsplus_jbd_handle_t - The hfsplus_jbd_handle_t type represents a single atomic update being performed by some process.
+ *
+ * All filesystem modifications made by the process go
+ * through this handle.  Recursive operations (such as quota operations)
+ * are gathered into a single update.
+ *
+ * The buffer credits field is used to account for journaled buffers
+ * being modified by the running process.  To ensure that there is
+ * enough log space for all outstanding operations, we need to limit the
+ * number of outstanding buffers possible at any time.  When the
+ * operation completes, any buffer credits not used are credited back to
+ * the transaction, so that at all times we know how many buffers the
+ * outstanding updates on a transaction might possibly touch. 
+ * 
+ * This is an opaque datatype.
+ **/
+typedef struct hfsplus_jbd_handle_s		hfsplus_jbd_handle_t;	/* Atomic operation type */
+
+
+/**
+ * typedef hfsplus_jbd_t - The hfsplus_jbd_t maintains all of the journaling state information for a single filesystem.
+ *
+ * hfsplus_jbd_t is linked to from the fs superblock structure.
+ * 
+ * We use the hfsplus_jbd_t to keep track of all outstanding transaction
+ * activity on the filesystem, and to manage the state of the log
+ * writing process.
+ *
+ * This is an opaque datatype.
+ **/
+typedef struct hfsplus_jbd_s	hfsplus_jbd_t;	/* Journal control structure */
+#endif
+
+/*
+ * Internal structures used by the logging mechanism:
+ */
+
+#define JFS_MAGIC_NUMBER 0xc03b3998U /* The first 4 bytes of /dev/random! */
+
+/*
+ * On-disk structures
+ */
+
+/* 
+ * Descriptor block types:
+ */
+
+#define JFS_DESCRIPTOR_BLOCK	1
+#define JFS_COMMIT_BLOCK	2
+#define JFS_SUPERBLOCK_V1	3
+#define JFS_SUPERBLOCK_V2	4
+#define JFS_REVOKE_BLOCK	5
+
+/*
+ * Standard header for all descriptor blocks:
+ */
+typedef struct hfsplus_jbd_header_s
+{
+	__be32		h_magic;
+	__be32		h_blocktype;
+	__be32		h_sequence;
+} hfsplus_jbd_header_t;
+
+
+/* 
+ * The block tag: used to describe a single buffer in the journal 
+ */
+typedef struct hfsplus_jbd_block_tag_s
+{
+	__be32		t_blocknr;	/* The on-disk block number */
+	__be32		t_flags;	/* See below */
+} hfsplus_jbd_block_tag_t;
+
+/* 
+ * The revoke descriptor: used on disk to describe a series of blocks to
+ * be revoked from the log 
+ */
+typedef struct hfsplus_jbd_revoke_header_s
+{
+	hfsplus_jbd_header_t r_header;
+	__be32		 r_count;	/* Count of bytes used in the block */
+} hfsplus_jbd_revoke_header_t;
+
+
+/* Definitions for the journal tag flags word: */
+#define JFS_FLAG_ESCAPE		1	/* on-disk block is escaped */
+#define JFS_FLAG_SAME_UUID	2	/* block has same uuid as previous */
+#define JFS_FLAG_DELETED	4	/* block deleted by this transaction */
+#define JFS_FLAG_LAST_TAG	8	/* last tag in this descriptor block */
+
+
+/*
+ * The journal superblock.  All fields are in big-endian byte order.
+ */
+typedef struct hfsplus_jbd_superblock_s
+{
+	/* First sector contains Mac's journal header */
+/* 0x0000 */
+	struct hfsplus_journal_header mac_jh;
+
+	/* Insert padding for rest of the first sector */
+	__u8 mac_padding[HFSPLUS_SECTOR_SIZE - sizeof(struct hfsplus_journal_header)];
+
+/* 0x0200 */
+	hfsplus_jbd_header_t s_header;
+
+/* 0x020C */
+	/* Static information describing the journal */
+	__be32	s_blocksize;		/* journal device blocksize */
+	__be32	s_maxlen;		/* total blocks in journal file */
+	__be32	s_first;		/* first block of log information */
+
+/* 0x0218 */
+	/* Dynamic information describing the current state of the log */
+	__be32	s_sequence;		/* first commit ID expected in log */
+	__be32	s_start;		/* blocknr of start of log */
+
+/* 0x0220 */
+	/* Error value, as set by hfsplus_jbd_abort(). */
+	__be32	s_errno;
+
+/* 0x0224 */
+	/* Remaining fields are only valid in a version-2 superblock */
+	__be32	s_feature_compat; 	/* compatible feature set */
+	__be32	s_feature_incompat; 	/* incompatible feature set */
+	__be32	s_feature_ro_compat; 	/* readonly-compatible feature set */
+/* 0x0230 */
+	__u8	s_uuid[16];		/* 128-bit uuid for journal */
+
+/* 0x0240 */
+	__be32	s_nr_users;		/* Nr of filesystems sharing log */
+
+	__be32	s_dynsuper;		/* Blocknr of dynamic superblock copy*/
+
+/* 0x0248 */
+	__be32	s_max_transaction;	/* Limit of journal blocks per trans.*/
+	__be32	s_max_trans_data;	/* Limit of data blocks per trans. */
+
+/* 0x0250 */
+	__u32	s_padding[44];
+
+/* 0x0300 */
+	__u8	s_users[16*16];		/* ids of all fs'es sharing the log */
+/* 0x0400 */
+} hfsplus_jbd_superblock_t;
+
+#define JFS_HAS_COMPAT_FEATURE(j,mask)					\
+	((j)->j_format_version >= 2 &&					\
+	 ((j)->j_superblock->s_feature_compat & cpu_to_be32((mask))))
+#define JFS_HAS_RO_COMPAT_FEATURE(j,mask)				\
+	((j)->j_format_version >= 2 &&					\
+	 ((j)->j_superblock->s_feature_ro_compat & cpu_to_be32((mask))))
+#define JFS_HAS_INCOMPAT_FEATURE(j,mask)				\
+	((j)->j_format_version >= 2 &&					\
+	 ((j)->j_superblock->s_feature_incompat & cpu_to_be32((mask))))
+
+#define JFS_FEATURE_INCOMPAT_REVOKE	0x00000001
+
+/* Features known to this kernel version: */
+#define JFS_KNOWN_COMPAT_FEATURES	0
+#define JFS_KNOWN_ROCOMPAT_FEATURES	0
+#define JFS_KNOWN_INCOMPAT_FEATURES	JFS_FEATURE_INCOMPAT_REVOKE
+
+#ifdef __KERNEL__
+
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <asm/bug.h>
+
+#define HFSPLUS_J_ASSERT(assert)	BUG_ON(!(assert))
+
+#if defined(CONFIG_BUFFER_DEBUG)
+void buffer_assertion_failure(struct buffer_head *bh);
+#define HFSPLUS_J_ASSERT_BH(bh, expr)						\
+	do {								\
+		if (!(expr))						\
+			buffer_assertion_failure(bh);			\
+		HFSPLUS_J_ASSERT(expr);						\
+	} while (0)
+#define HFSPLUS_J_ASSERT_JH(jh, expr)	HFSPLUS_J_ASSERT_BH(hfsplus_jh2bh(jh), expr)
+#else
+#define HFSPLUS_J_ASSERT_BH(bh, expr)	HFSPLUS_J_ASSERT(expr)
+#define HFSPLUS_J_ASSERT_JH(jh, expr)	HFSPLUS_J_ASSERT(expr)
+#endif
+
+#if defined(HFSPLUS_JBD_PARANOID_IOFAIL)
+#define HFSPLUS_J_EXPECT(expr, why...)		HFSPLUS_J_ASSERT(expr)
+#define HFSPLUS_J_EXPECT_BH(bh, expr, why...)	HFSPLUS_J_ASSERT_BH(bh, expr)
+#define HFSPLUS_J_EXPECT_JH(jh, expr, why...)	HFSPLUS_J_ASSERT_JH(jh, expr)
+#else
+#define __hfsplus_jbd_expect(expr, why...)					     \
+	({								     \
+		int val = (expr);					     \
+		if (!val) {						     \
+			printk(KERN_ERR					     \
+				"EXT3-fs unexpected failure: %s;\n",# expr); \
+			printk(KERN_ERR why "\n");			     \
+		}							     \
+		val;							     \
+	})
+#define HFSPLUS_J_EXPECT(expr, why...)		__hfsplus_jbd_expect(expr, ## why)
+#define HFSPLUS_J_EXPECT_BH(bh, expr, why...)	__hfsplus_jbd_expect(expr, ## why)
+#define HFSPLUS_J_EXPECT_JH(jh, expr, why...)	__hfsplus_jbd_expect(expr, ## why)
+#endif
+
+enum hfsplus_jbd_state_bits {
+	BH_HFSPLUS_JBD			/* Has an attached ext3 hfsplus_jbd_head */
+	  = BH_PrivateStart,
+	BH_HFSPLUS_JWrite,		/* Being written to log (@@@ DEBUGGING) */
+	BH_HFSPLUS_Freed,		/* Has been freed (truncated) */
+	BH_HFSPLUS_Revoked,		/* Has been revoked from the log */
+	BH_HFSPLUS_RevokeValid,		/* Revoked flag is valid */
+	BH_HFSPLUS_JBDDirty,		/* Is dirty but journaled */
+	BH_HFSPLUS_State,		/* Pins most hfsplus_jbd_head state */
+	BH_HFSPLUS_JournalHead,		/* Pins bh->b_private and jh->b_bh */
+	BH_HFSPLUS_Unshadow,		/* Dummy bit, for HFSPLUS_BJ_Shadow wakeup filtering */
+};
+
+BUFFER_FNS(HFSPLUS_JBD, hfsplus_jbd)
+BUFFER_FNS(HFSPLUS_JWrite, hfsplus_jbd_jwrite)
+BUFFER_FNS(HFSPLUS_JBDDirty, hfsplus_jbddirty)
+TAS_BUFFER_FNS(HFSPLUS_JBDDirty, hfsplus_jbddirty)
+BUFFER_FNS(HFSPLUS_Revoked, hfsplus_jbd_revoked)
+TAS_BUFFER_FNS(HFSPLUS_Revoked, hfsplus_jbd_revoked)
+BUFFER_FNS(HFSPLUS_RevokeValid, hfsplus_jbd_revokevalid)
+TAS_BUFFER_FNS(HFSPLUS_RevokeValid, hfsplus_jbd_revokevalid)
+BUFFER_FNS(HFSPLUS_Freed, hfsplus_jbd_freed)
+
+static inline struct buffer_head *hfsplus_jh2bh(struct hfsplus_jbd_head *jh)
+{
+	return jh->b_bh;
+}
+
+static inline struct hfsplus_jbd_head *hfsplus_bh2jh(struct buffer_head *bh)
+{
+	return bh->b_private;
+}
+
+static inline void hfsplus_jbd_lock_bh_state(struct buffer_head *bh)
+{
+	bit_spin_lock(BH_HFSPLUS_State, &bh->b_state);
+}
+
+static inline int hfsplus_jbd_trylock_bh_state(struct buffer_head *bh)
+{
+	return bit_spin_trylock(BH_HFSPLUS_State, &bh->b_state);
+}
+
+static inline int hfsplus_jbd_is_locked_bh_state(struct buffer_head *bh)
+{
+	return bit_spin_is_locked(BH_HFSPLUS_State, &bh->b_state);
+}
+
+static inline void hfsplus_jbd_unlock_bh_state(struct buffer_head *bh)
+{
+	bit_spin_unlock(BH_HFSPLUS_State, &bh->b_state);
+}
+
+static inline void hfsplus_jbd_lock_bh_hfsplus_jbd_head(struct buffer_head *bh)
+{
+	bit_spin_lock(BH_HFSPLUS_JournalHead, &bh->b_state);
+}
+
+static inline void hfsplus_jbd_unlock_bh_hfsplus_jbd_head(struct buffer_head *bh)
+{
+	bit_spin_unlock(BH_HFSPLUS_JournalHead, &bh->b_state);
+}
+
+struct hfsplus_jbd_revoke_table_s;
+
+/**
+ * struct hfsplus_jbd_handle_s - this is the concrete type associated with handle_t.
+ * @h_transaction: Which compound transaction is this update a part of?
+ * @h_buffer_credits: Number of remaining buffers we are allowed to dirty.
+ * @h_ref: Reference count on this handle
+ * @h_err: Field for caller's use to track errors through large fs operations
+ * @h_sync: flag for sync-on-close
+ * @h_jdata: flag to force data journaling
+ * @h_aborted: flag indicating fatal error on handle
+ * @h_lockdep_map: lockdep info for debugging lock problems
+ */
+struct hfsplus_jbd_handle_s 
+{
+	/* Which compound transaction is this update a part of? */
+	hfsplus_transaction_t		*h_transaction;
+
+	/* Number of remaining buffers we are allowed to dirty: */
+	int			h_buffer_credits;
+
+	/* Reference count on this handle */
+	int			h_ref;
+
+	/* Field for caller's use to track errors through large fs */
+	/* operations */
+	int			h_err;
+
+	/* Flags [no locking] */
+	unsigned int	h_sync:		1;	/* sync-on-close */
+	unsigned int	h_jdata:	1;	/* force data journaling */
+	unsigned int	h_aborted:	1;	/* fatal error on handle */
+
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	struct lockdep_map	h_lockdep_map;
+#endif
+};
+
+struct hfsplus_handle {
+	hfsplus_jbd_handle_t *handle;
+	u16 hcnt; /* Count number of call of journal_dirty_metadata() */
+	u16 maxblock; 
+	u32 journaled;
+};
+/* The transaction_t type is the guts of the journaling mechanism.  It
+ * tracks a compound transaction through its various states:
+ *
+ * RUNNING:	accepting new updates
+ * LOCKED:	Updates still running but we don't accept new ones
+ * RUNDOWN:	Updates are tidying up but have finished requesting
+ *		new buffers to modify (state not used for now)
+ * FLUSH:       All updates complete, but we are still writing to disk
+ * COMMIT:      All data on disk, writing commit record
+ * FINISHED:	We still have to keep the transaction for checkpointing.
+ *
+ * The transaction keeps track of all of the buffers modified by a
+ * running transaction, and all of the buffers committed but not yet
+ * flushed to home for finished transactions.
+ */
+
+/*
+ * Lock ranking:
+ *
+ *    j_list_lock
+ *      ->hfsplus_jbd_lock_bh_hfsplus_jbd_head()	(This is "innermost")
+ *
+ *    j_state_lock
+ *    ->hfsplus_jbd_lock_bh_state()
+ *
+ *    hfsplus_jbd_lock_bh_state()
+ *    ->j_list_lock
+ *
+ *    j_state_lock
+ *    ->t_handle_lock
+ *
+ *    j_state_lock
+ *    ->j_list_lock			(hfsplus_jbd_unmap_buffer)
+ *
+ */
+
+struct hfsplus_transaction_s 
+{
+	/* Pointer to the journal for this transaction. [no locking] */
+	hfsplus_jbd_t		*t_journal;
+
+	/* Sequence number for this transaction [no locking] */
+	hfsplus_jbd_tid_t			t_tid;
+
+	/*
+	 * Transaction's current state
+	 * [no locking - only kjournald alters this]
+	 * [j_list_lock] guards transition of a transaction into T_FINISHED
+	 * state and subsequent call of __journal_drop_transaction()
+	 * FIXME: needs barriers
+	 * KLUDGE: [use j_state_lock]
+	 */
+	enum {
+		HFSPLUS_T_RUNNING,
+		HFSPLUS_T_LOCKED,
+		HFSPLUS_T_RUNDOWN,
+		HFSPLUS_T_FLUSH,
+		HFSPLUS_T_COMMIT,
+		HFSPLUS_T_FINISHED 
+	}			t_state;
+
+	/*
+	 * Where in the log does this transaction's commit start? [no locking]
+	 */
+	unsigned int		t_log_start;
+
+	/* Number of buffers on the t_buffers list [j_list_lock] */
+	int			t_nr_buffers;
+
+	/*
+	 * Doubly-linked circular list of all buffers reserved but not yet
+	 * modified by this transaction [j_list_lock]
+	 */
+	struct hfsplus_jbd_head	*t_reserved_list;
+
+	/*
+	 * Doubly-linked circular list of all buffers under writeout during
+	 * commit [j_list_lock]
+	 */
+	struct hfsplus_jbd_head	*t_locked_list;
+
+	/*
+	 * Doubly-linked circular list of all metadata buffers owned by this
+	 * transaction [j_list_lock]
+	 */
+	struct hfsplus_jbd_head	*t_buffers;
+
+	/*
+	 * Doubly-linked circular list of all data buffers still to be
+	 * flushed before this transaction can be committed [j_list_lock]
+	 */
+	struct hfsplus_jbd_head	*t_sync_datalist;
+
+	/*
+	 * Doubly-linked circular list of all forget buffers (superseded
+	 * buffers which we can un-checkpoint once this transaction commits)
+	 * [j_list_lock]
+	 */
+	struct hfsplus_jbd_head	*t_forget;
+
+	/*
+	 * Doubly-linked circular list of all buffers still to be flushed before
+	 * this transaction can be checkpointed. [j_list_lock]
+	 */
+	struct hfsplus_jbd_head	*t_checkpoint_list;
+
+	/*
+	 * Doubly-linked circular list of all buffers submitted for IO while
+	 * checkpointing. [j_list_lock]
+	 */
+	struct hfsplus_jbd_head	*t_checkpoint_io_list;
+
+	/*
+	 * Doubly-linked circular list of temporary buffers currently undergoing
+	 * IO in the log [j_list_lock]
+	 */
+	struct hfsplus_jbd_head	*t_iobuf_list;
+
+	/*
+	 * Doubly-linked circular list of metadata buffers being shadowed by log
+	 * IO.  The IO buffers on the iobuf list and the shadow buffers on this
+	 * list match each other one for one at all times. [j_list_lock]
+	 */
+	struct hfsplus_jbd_head	*t_shadow_list;
+
+	/*
+	 * Doubly-linked circular list of control buffers being written to the
+	 * log. [j_list_lock]
+	 */
+	struct hfsplus_jbd_head	*t_log_list;
+
+	/*
+	 * Protects info related to handles
+	 */
+	spinlock_t		t_handle_lock;
+
+	/*
+	 * Number of outstanding updates running on this transaction
+	 * [t_handle_lock]
+	 */
+	int			t_updates;
+
+	/*
+	 * Number of buffers reserved for use by all handles in this transaction
+	 * handle but not yet modified. [t_handle_lock]
+	 */
+	int			t_outstanding_credits;
+
+	/*
+	 * Forward and backward links for the circular list of all transactions
+	 * awaiting checkpoint. [j_list_lock]
+	 */
+	hfsplus_transaction_t		*t_cpnext, *t_cpprev;
+
+	/*
+	 * When will the transaction expire (become due for commit), in jiffies?
+	 * [no locking]
+	 */
+	unsigned long		t_expires;
+
+	/*
+	 * When this transaction started, in nanoseconds [no locking]
+	 */
+	ktime_t			t_start_time;
+
+	/*
+	 * How many handles used this transaction? [t_handle_lock]
+	 */
+	int t_handle_count;
+
+	/*
+	 * This transaction is being forced and some process is
+	 * waiting for it to finish.
+	 */
+	unsigned int t_synchronous_commit:1;
+};
+
+/**
+ * struct journal_s - this is the concrete type associated with journal_t.
+ * @j_flags:  General journaling state flags
+ * @j_errno:  Is there an outstanding uncleared error on the journal (from a
+ *     prior abort)? 
+ * @j_sb_buffer: First part of superblock buffer
+ * @j_superblock: Second part of superblock buffer
+ * @j_format_version: Version of the superblock format
+ * @j_state_lock: Protect the various scalars in the journal
+ * @j_barrier_count:  Number of processes waiting to create a barrier lock
+ * @j_barrier: The barrier lock itself
+ * @j_running_transaction: The current running transaction..
+ * @j_committing_transaction: the transaction we are pushing to disk
+ * @j_checkpoint_transactions: a linked circular list of all transactions
+ *  waiting for checkpointing
+ * @j_wait_transaction_locked: Wait queue for waiting for a locked transaction
+ *  to start committing, or for a barrier lock to be released
+ * @j_wait_logspace: Wait queue for waiting for checkpointing to complete
+ * @j_wait_done_commit: Wait queue for waiting for commit to complete 
+ * @j_wait_checkpoint:  Wait queue to trigger checkpointing
+ * @j_wait_commit: Wait queue to trigger commit
+ * @j_wait_updates: Wait queue to wait for updates to complete
+ * @j_checkpoint_mutex: Mutex for locking against concurrent checkpoints
+ * @j_head: Journal head - identifies the first unused block in the journal
+ * @j_tail: Journal tail - identifies the oldest still-used block in the
+ *  journal.
+ * @j_free: Journal free - how many free blocks are there in the journal?
+ * @j_first: The block number of the first usable block 
+ * @j_last: The block number one beyond the last usable block
+ * @j_dev: Device where we store the journal
+ * @j_blocksize: blocksize for the location where we store the journal.
+ * @j_blk_offset: starting block offset for into the device where we store the
+ *     journal
+ * @j_fs_dev: Device which holds the client fs.  For internal journal this will
+ *     be equal to j_dev
+ * @j_maxlen: Total maximum capacity of the journal region on disk.
+ * @j_list_lock: Protects the buffer lists and internal buffer state.
+ * @j_inode: Optional inode where we store the journal.  If present, all journal
+ *     block numbers are mapped into this inode via bmap().
+ * @j_tail_sequence:  Sequence number of the oldest transaction in the log 
+ * @j_transaction_sequence: Sequence number of the next transaction to grant
+ * @j_commit_sequence: Sequence number of the most recently committed
+ *  transaction
+ * @j_commit_request: Sequence number of the most recent transaction wanting
+ *     commit 
+ * @j_uuid: Uuid of client object.
+ * @j_task: Pointer to the current commit thread for this journal
+ * @j_max_transaction_buffers:  Maximum number of metadata buffers to allow in a
+ *     single compound commit transaction
+ * @j_commit_interval: What is the maximum transaction lifetime before we begin
+ *  a commit?
+ * @j_commit_timer:  The timer used to wakeup the commit thread
+ * @j_revoke_lock: Protect the revoke table
+ * @j_revoke: The revoke table - maintains the list of revoked blocks in the
+ *     current transaction.
+ * @j_revoke_table: alternate revoke tables for j_revoke
+ * @j_wbuf: array of buffer_heads for hfsplus_jbd_commit_transaction
+ * @j_wbufsize: maximum number of buffer_heads allowed in j_wbuf, the
+ *	number that will fit in j_blocksize
+ * @j_last_sync_writer: most recent pid which did a synchronous write
+ * @j_average_commit_time: the average amount of time in nanoseconds it
+ *	takes to commit a transaction to the disk.
+ * @j_private: An opaque pointer to fs-private information.
+ */
+
+struct hfsplus_jbd_s
+{
+	/* General journaling state flags [j_state_lock] */
+	unsigned long		j_flags;
+
+	/*
+	 * Is there an outstanding uncleared error on the journal (from a prior
+	 * abort)? [j_state_lock]
+	 */
+	int			j_errno;
+
+	/* The superblock buffer */
+	struct buffer_head	*j_sb_buffer;
+	hfsplus_jbd_superblock_t	*j_superblock;
+
+	/* Version of the superblock format */
+	int			j_format_version;
+
+	/*
+	 * Protect the various scalars in the journal
+	 */
+	spinlock_t		j_state_lock;
+
+	/*
+	 * Number of processes waiting to create a barrier lock [j_state_lock]
+	 */
+	int			j_barrier_count;
+
+	/* The barrier lock itself */
+	struct mutex		j_barrier;
+
+	/*
+	 * Transactions: The current running transaction...
+	 * [j_state_lock] [caller holding open handle]
+	 */
+	hfsplus_transaction_t		*j_running_transaction;
+
+	/*
+	 * the transaction we are pushing to disk
+	 * [j_state_lock] [caller holding open handle]
+	 */
+	hfsplus_transaction_t		*j_committing_transaction;
+
+	/*
+	 * ... and a linked circular list of all transactions waiting for
+	 * checkpointing. [j_list_lock]
+	 */
+	hfsplus_transaction_t		*j_checkpoint_transactions;
+
+	/*
+	 * Wait queue for waiting for a locked transaction to start committing,
+	 * or for a barrier lock to be released
+	 */
+	wait_queue_head_t	j_wait_transaction_locked;
+
+	/* Wait queue for waiting for checkpointing to complete */
+	wait_queue_head_t	j_wait_logspace;
+
+	/* Wait queue for waiting for commit to complete */
+	wait_queue_head_t	j_wait_done_commit;
+
+	/* Wait queue to trigger checkpointing */
+	wait_queue_head_t	j_wait_checkpoint;
+
+	/* Wait queue to trigger commit */
+	wait_queue_head_t	j_wait_commit;
+
+	/* Wait queue to wait for updates to complete */
+	wait_queue_head_t	j_wait_updates;
+
+	/* Semaphore for locking against concurrent checkpoints */
+	struct mutex		j_checkpoint_mutex;
+
+	/*
+	 * Journal head: identifies the first unused block in the journal.
+	 * [j_state_lock]
+	 */
+	unsigned int		j_head;
+
+	/*
+	 * Journal tail: identifies the oldest still-used block in the journal.
+	 * [j_state_lock]
+	 */
+	unsigned int		j_tail;
+
+	/*
+	 * Journal free: how many free blocks are there in the journal?
+	 * [j_state_lock]
+	 */
+	unsigned int		j_free;
+
+	/*
+	 * Journal start and end: the block numbers of the first usable block
+	 * and one beyond the last usable block in the journal. [j_state_lock]
+	 */
+	unsigned int		j_first;
+	unsigned int		j_last;
+
+	/*
+	 * Device, blocksize and starting block offset for the location where we
+	 * store the journal.
+	 */
+	struct block_device	*j_dev;
+	int			j_blocksize;
+	unsigned int		j_blk_offset;
+
+	/*
+	 * Device which holds the client fs.  For internal journal this will be
+	 * equal to j_dev.
+	 */
+	struct block_device	*j_fs_dev;
+
+	/* Total maximum capacity of the journal region on disk. */
+	unsigned int		j_maxlen;
+
+	/*
+	 * Protects the buffer lists and internal buffer state.
+	 */
+	spinlock_t		j_list_lock;
+
+	/* Optional inode where we store the journal.  If present, all */
+	/* journal block numbers are mapped into this inode via */
+	/* bmap(). */
+	struct inode		*j_inode;
+
+	/*
+	 * Sequence number of the oldest transaction in the log [j_state_lock]
+	 */
+	hfsplus_jbd_tid_t			j_tail_sequence;
+
+	/*
+	 * Sequence number of the next transaction to grant [j_state_lock]
+	 */
+	hfsplus_jbd_tid_t			j_transaction_sequence;
+
+	/*
+	 * Sequence number of the most recently committed transaction
+	 * [j_state_lock].
+	 */
+	hfsplus_jbd_tid_t			j_commit_sequence;
+
+	/*
+	 * Sequence number of the most recent transaction wanting commit
+	 * [j_state_lock]
+	 */
+	hfsplus_jbd_tid_t			j_commit_request;
+
+	/*
+	 * Journal uuid: identifies the object (filesystem, LVM volume etc)
+	 * backed by this journal.  This will eventually be replaced by an array
+	 * of uuids, allowing us to index multiple devices within a single
+	 * journal and to perform atomic updates across them.
+	 */
+	__u8			j_uuid[16];
+
+	/* Pointer to the current commit thread for this journal */
+	struct task_struct	*j_task;
+
+	/*
+	 * Maximum number of metadata buffers to allow in a single compound
+	 * commit transaction
+	 */
+	int			j_max_transaction_buffers;
+
+	/*
+	 * What is the maximum transaction lifetime before we begin a commit?
+	 */
+	unsigned long		j_commit_interval;
+
+	/* The timer used to wakeup the commit thread: */
+	struct timer_list	j_commit_timer;
+
+	/*
+	 * The revoke table: maintains the list of revoked blocks in the
+	 * current transaction.  [j_revoke_lock]
+	 */
+	spinlock_t		j_revoke_lock;
+	struct hfsplus_jbd_revoke_table_s *j_revoke;
+	struct hfsplus_jbd_revoke_table_s *j_revoke_table[2];
+
+	/*
+	 * array of bhs for hfsplus_jbd_commit_transaction
+	 */
+	struct buffer_head	**j_wbuf;
+	int			j_wbufsize;
+
+	/*
+	 * this is the pid of the last person to run a synchronous operation
+	 * through the journal.
+	 */
+	pid_t			j_last_sync_writer;
+
+	/*
+	 * the average amount of time in nanoseconds it takes to commit a
+	 * transaction to the disk.  [j_state_lock]
+	 */
+	u64			j_average_commit_time;
+
+	/*
+	 * An opaque pointer to fs-private information.  ext3 puts its
+	 * superblock pointer here
+	 */
+	void *j_private;
+};
+
+/* 
+ * Journal flag definitions 
+ */
+#define JFS_UNMOUNT	0x001	/* Journal thread is being destroyed */
+#define JFS_ABORT	0x002	/* Journaling has been aborted for errors. */
+#define JFS_ACK_ERR	0x004	/* The errno in the sb has been acked */
+#define JFS_FLUSHED	0x008	/* The journal superblock has been flushed */
+#define JFS_LOADED	0x010	/* The journal superblock has been loaded */
+#define JFS_BARRIER	0x020	/* Use IDE barriers */
+#define JFS_ABORT_ON_SYNCDATA_ERR	0x040  /* Abort the journal on file
+						* data write error in ordered
+						* mode */
+
+/* 
+ * Function declarations for the journaling transaction and buffer
+ * management
+ */
+
+/* Filing buffers */
+extern void hfsplus_jbd_unfile_buffer(hfsplus_jbd_t *, struct hfsplus_jbd_head *);
+extern void __hfsplus_jbd_unfile_buffer(struct hfsplus_jbd_head *);
+extern void __hfsplus_jbd_refile_buffer(struct hfsplus_jbd_head *);
+extern void hfsplus_jbd_refile_buffer(hfsplus_jbd_t *, struct hfsplus_jbd_head *);
+extern void __hfsplus_jbd_file_buffer(struct hfsplus_jbd_head *, hfsplus_transaction_t *, int);
+extern void __hfsplus_jbd_free_buffer(struct hfsplus_jbd_head *bh);
+extern void hfsplus_jbd_file_buffer(struct hfsplus_jbd_head *, hfsplus_transaction_t *, int);
+extern void __hfsplus_jbd_clean_data_list(hfsplus_transaction_t *transaction);
+
+/* Log buffer allocation */
+extern struct hfsplus_jbd_head * hfsplus_jbd_get_descriptor_buffer(hfsplus_jbd_t *);
+int hfsplus_jbd_next_log_block(hfsplus_jbd_t *, unsigned int *);
+
+/* Commit management */
+extern void hfsplus_jbd_commit_transaction(hfsplus_jbd_t *);
+
+/* Checkpoint list management */
+int __hfsplus_jbd_clean_checkpoint_list(hfsplus_jbd_t *journal);
+int __hfsplus_jbd_remove_checkpoint(struct hfsplus_jbd_head *);
+void __hfsplus_jbd_insert_checkpoint(struct hfsplus_jbd_head *, hfsplus_transaction_t *);
+
+/* Buffer IO */
+extern int 
+hfsplus_jbd_write_metadata_buffer(hfsplus_transaction_t	  *transaction,
+			      struct hfsplus_jbd_head  *jh_in,
+			      struct hfsplus_jbd_head **jh_out,
+			      unsigned int blocknr);
+
+/* Transaction locking */
+extern void		__hfsplus__wait_on_journal (hfsplus_jbd_t *);
+
+/*
+ * Journal locking.
+ *
+ * We need to lock the journal during transaction state changes so that nobody
+ * ever tries to take a handle on the running transaction while we are in the
+ * middle of moving it to the commit phase.  j_state_lock does this.
+ *
+ * Note that the locking is completely interrupt unsafe.  We never touch
+ * journal structures from interrupts.
+ */
+
+static inline hfsplus_handle_t *hfsplus_jbd_current_handle(void)
+{
+	return current->journal_info;
+}
+
+/* The journaling code user interface:
+ *
+ * Create and destroy handles
+ * Register buffer modifications against the current transaction. 
+ */
+
+extern hfsplus_jbd_handle_t *hfsplus_jbd_start(hfsplus_jbd_t *, int nblocks, hfsplus_handle_t *hfsplus_handle);
+extern int	 hfsplus_jbd_restart (hfsplus_jbd_handle_t *, int nblocks);
+extern int	 hfsplus_jbd_extend (hfsplus_jbd_handle_t *, int nblocks);
+extern int	 hfsplus_jbd_get_write_access(hfsplus_jbd_handle_t *, struct buffer_head *);
+extern int	 hfsplus_jbd_get_create_access (hfsplus_jbd_handle_t *, struct buffer_head *);
+extern int	 hfsplus_jbd_get_undo_access(hfsplus_jbd_handle_t *, struct buffer_head *);
+extern int	 hfsplus_jbd_dirty_data (hfsplus_jbd_handle_t *, struct buffer_head *);
+extern int	 hfsplus_jbd_dirty_metadata (hfsplus_jbd_handle_t *, struct buffer_head *);
+extern void	 hfsplus_jbd_release_buffer (hfsplus_jbd_handle_t *, struct buffer_head *);
+extern int	 hfsplus_jbd_forget (hfsplus_jbd_handle_t *, struct buffer_head *);
+extern void	 hfsplus_jbd_sync_buffer (struct buffer_head *);
+extern void	 hfsplus_jbd_invalidatepage(hfsplus_jbd_t *,
+				struct page *, unsigned long);
+extern int	 hfsplus_jbd_try_to_free_buffers(hfsplus_jbd_t *, struct page *, gfp_t);
+extern int	 hfsplus_jbd_stop(hfsplus_jbd_handle_t *);
+extern int	 hfsplus_jbd_flush (hfsplus_jbd_t *);
+extern void	 hfsplus_jbd_lock_updates (hfsplus_jbd_t *);
+extern void	 hfsplus_jbd_unlock_updates (hfsplus_jbd_t *);
+
+extern hfsplus_jbd_t * hfsplus_jbd_init_dev(struct block_device *bdev,
+				struct block_device *fs_dev,
+				int start, int len, int bsize);
+extern hfsplus_jbd_t * hfsplus_jbd_init_inode (struct inode *);
+extern int	   hfsplus_jbd_update_format (hfsplus_jbd_t *);
+extern int	   hfsplus_jbd_check_used_features 
+		   (hfsplus_jbd_t *, unsigned long, unsigned long, unsigned long);
+extern int	   hfsplus_jbd_check_available_features 
+		   (hfsplus_jbd_t *, unsigned long, unsigned long, unsigned long);
+extern int	   hfsplus_jbd_set_features 
+		   (hfsplus_jbd_t *, unsigned long, unsigned long, unsigned long);
+extern int	   hfsplus_jbd_create     (hfsplus_jbd_t *);
+extern int	   hfsplus_jbd_load       (hfsplus_jbd_t *journal);
+extern int	   hfsplus_jbd_destroy    (hfsplus_jbd_t *);
+extern int	   hfsplus_jbd_recover    (hfsplus_jbd_t *journal);
+extern int	   hfsplus_jbd_wipe       (hfsplus_jbd_t *, int);
+extern int	   hfsplus_jbd_skip_recovery	(hfsplus_jbd_t *);
+extern void	   hfsplus_jbd_update_superblock	(hfsplus_jbd_t *, int);
+extern void	   __hfsplus_jbd_abort_hard	(hfsplus_jbd_t *);
+extern void	   hfsplus_jbd_abort      (hfsplus_jbd_t *, int);
+extern int	   hfsplus_jbd_errno      (hfsplus_jbd_t *);
+extern void	   hfsplus_jbd_ack_err    (hfsplus_jbd_t *);
+extern int	   hfsplus_jbd_clear_err  (hfsplus_jbd_t *);
+extern int	   hfsplus_jbd_bmap(hfsplus_jbd_t *, unsigned int, unsigned int *);
+extern int	   hfsplus_jbd_force_commit(hfsplus_jbd_t *);
+
+/*
+ * hfsplus_jbd_head management
+ */
+struct hfsplus_jbd_head *hfsplus_jbd_add_journal_head(struct buffer_head *bh);
+struct hfsplus_jbd_head *hfsplus_jbd_grab_journal_head(struct buffer_head *bh);
+void hfsplus_jbd_remove_journal_head(struct buffer_head *bh);
+void hfsplus_jbd_put_journal_head(struct hfsplus_jbd_head *jh);
+
+/*
+ * handle management
+ */
+extern struct kmem_cache *hfsplus_jbd_handle_cache;
+
+static inline hfsplus_jbd_handle_t *hfsplus_jbd_alloc_handle(gfp_t gfp_flags)
+{
+	return kmem_cache_alloc(hfsplus_jbd_handle_cache, gfp_flags);
+}
+
+static inline void hfsplus_jbd_free_handle(hfsplus_jbd_handle_t *handle)
+{
+	kmem_cache_free(hfsplus_jbd_handle_cache, handle);
+}
+
+/* Primary revoke support */
+#define HFSPLUS_JBD_REVOKE_DEFAULT_HASH 256
+extern int	   hfsplus_jbd_init_revoke(hfsplus_jbd_t *, int);
+extern void	   hfsplus_jbd_destroy_revoke_caches(void);
+extern int	   hfsplus_jbd_init_revoke_caches(void);
+
+extern void	   hfsplus_jbd_destroy_revoke(hfsplus_jbd_t *);
+extern int	   hfsplus_jbd_revoke (hfsplus_jbd_handle_t *,
+				unsigned int, struct buffer_head *);
+extern int	   hfsplus_jbd_cancel_revoke(hfsplus_jbd_handle_t *, struct hfsplus_jbd_head *);
+extern void	   hfsplus_jbd_write_revoke_records(hfsplus_jbd_t *,
+						hfsplus_transaction_t *, int);
+
+/* Recovery revoke support */
+extern int	hfsplus_jbd_set_revoke(hfsplus_jbd_t *, unsigned int, hfsplus_jbd_tid_t);
+extern int	hfsplus_jbd_test_revoke(hfsplus_jbd_t *, unsigned int, hfsplus_jbd_tid_t);
+extern void	hfsplus_jbd_clear_revoke(hfsplus_jbd_t *);
+//extern void	hfsplus_jbd_brelse_array(struct buffer_head *b[], int n);
+extern void	hfsplus_jbd_switch_revoke_table(hfsplus_jbd_t *journal);
+
+/*
+ * The log thread user interface:
+ *
+ * Request space in the current transaction, and force transaction commit
+ * transitions on demand.
+ */
+
+int __hfsplus__log_space_left(hfsplus_jbd_t *); /* Called with journal locked */
+int hfsplus_log_start_commit(hfsplus_jbd_t *journal, hfsplus_jbd_tid_t tid);
+int __hfsplus__log_start_commit(hfsplus_jbd_t *journal, hfsplus_jbd_tid_t tid);
+int hfsplus_jbd_start_commit(hfsplus_jbd_t *journal, hfsplus_jbd_tid_t *tid);
+int hfsplus_jbd_force_commit_nested(hfsplus_jbd_t *journal);
+int hfsplus_jbd_log_wait_commit(hfsplus_jbd_t *journal, hfsplus_jbd_tid_t tid);
+int hfsplus_jbd_log_do_checkpoint(hfsplus_jbd_t *journal);
+
+void __hfsplus__log_wait_for_space(hfsplus_jbd_t *journal);
+extern void	__hfsplus_jbd_drop_transaction(hfsplus_jbd_t *, hfsplus_transaction_t *);
+extern int	cleanup_hfsplus_jbd_tail(hfsplus_jbd_t *);
+
+/* Debugging code only: */
+int hfsplus_jbd_init(void);
+void hfsplus_jbd_exit(void);
+
+#define hfsplus_jbd_ENOSYS() \
+do {								           \
+	printk (KERN_ERR "HFSPLUS_JBD unimplemented function %s\n", __func__); \
+	current->state = TASK_UNINTERRUPTIBLE;			           \
+	schedule();						           \
+} while (1)
+
+/*
+ * is_hfsplus_jbd_abort
+ *
+ * Simple test wrapper function to test the JFS_ABORT state flag.  This
+ * bit, when set, indicates that we have had a fatal error somewhere,
+ * either inside the journaling layer or indicated to us by the client
+ * (eg. ext3), and that we and should not commit any further
+ * transactions.  
+ */
+
+static inline int is_hfsplus_jbd_aborted(hfsplus_jbd_t *journal)
+{
+	return journal->j_flags & JFS_ABORT;
+}
+
+static inline int hfsplus_jbd_is_handle_aborted(hfsplus_jbd_handle_t *handle)
+{
+	if (handle->h_aborted)
+		return 1;
+	return is_hfsplus_jbd_aborted(handle->h_transaction->t_journal);
+}
+
+static inline void hfsplus_jbd_abort_handle(hfsplus_jbd_handle_t *handle)
+{
+	handle->h_aborted = 1;
+}
+
+#endif /* __KERNEL__   */
+
+/* Comparison functions for transaction IDs: perform comparisons using
+ * modulo arithmetic so that they work over sequence number wraps. */
+
+static inline int hfsplus_tid_gt(hfsplus_jbd_tid_t x, hfsplus_jbd_tid_t y)
+{
+	int difference = (x - y);
+	return (difference > 0);
+}
+
+static inline int hfsplus_tid_geq(hfsplus_jbd_tid_t x, hfsplus_jbd_tid_t y)
+{
+	int difference = (x - y);
+	return (difference >= 0);
+}
+
+extern int hfsplus_jbd_blocks_per_page(struct inode *inode);
+
+/*
+ * Return the minimum number of blocks which must be free in the journal
+ * before a new transaction may be started.  Must be called under j_state_lock.
+ */
+static inline int hfsplus_jbd_space_needed(hfsplus_jbd_t *journal)
+{
+	int nblocks = journal->j_max_transaction_buffers;
+	if (journal->j_committing_transaction)
+		nblocks += journal->j_committing_transaction->
+					t_outstanding_credits;
+	return nblocks;
+}
+
+/*
+ * Definitions which augment the buffer_head layer
+ */
+
+/* journaling buffer types */
+#define HFSPLUS_BJ_None		0	/* Not journaled */
+#define HFSPLUS_BJ_SyncData	1	/* Normal data: flush before commit */
+#define HFSPLUS_BJ_Metadata	2	/* Normal journaled metadata */
+#define HFSPLUS_BJ_Forget	3	/* Buffer superseded by this transaction */
+#define HFSPLUS_BJ_IO		4	/* Buffer is for temporary IO use */
+#define HFSPLUS_BJ_Shadow	5	/* Buffer contents being shadowed to the log */
+#define HFSPLUS_BJ_LogCtl	6	/* Buffer contains log descriptors */
+#define HFSPLUS_BJ_Reserved	7	/* Buffer is reserved for access by journal */
+#define HFSPLUS_BJ_Locked	8	/* Locked for I/O during commit */
+#define HFSPLUS_BJ_Types	9
+ 
+extern int hfsplus_jbd_blocks_per_page(struct inode *inode);
+
+#ifdef __KERNEL__
+
+#define HFSPLUS_buffer_trace_init(bh)	do {} while (0)
+#define HFSPLUS_print_buffer_fields(bh)	do {} while (0)
+#define HFSPLUS_print_buffer_trace(bh)	do {} while (0)
+#define HFSPLUS_BUFFER_TRACE(bh, info)	do {} while (0)
+#define HFSPLUS_BUFFER_TRACE2(bh, bh2, info)	do {} while (0)
+#define HFSPLUS_JBUFFER_TRACE(jh, info)	do {} while (0)
+
+#endif	/* __KERNEL__ */
+
+#endif	/* _LINUX_HFSPLUS_JBD_H */
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/hfsplus_journal_head.h linux-2.6.32/fs/hfsplus_journal/hfsplus_journal_head.h
--- linux-2.6.32-old//fs/hfsplus_journal/hfsplus_journal_head.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/hfsplus_journal_head.h	2011-11-17 09:00:40.778818402 -0500
@@ -0,0 +1,100 @@
+/*
+ * include/linux/journal-head.h
+ *
+ * buffer_head fields for JBD
+ *
+ * 27 May 2001 Andrew Morton
+ *	Created - pulled out of fs.h
+ */
+
+#ifndef HFSPLUS_JOURNAL_HEAD_H_INCLUDED
+#define HFSPLUS_JOURNAL_HEAD_H_INCLUDED
+
+typedef unsigned int		hfsplus_jbd_tid_t;		/* Unique transaction ID */
+typedef struct hfsplus_transaction_s	hfsplus_transaction_t;	/* Compound transaction type */
+
+
+struct buffer_head;
+
+struct hfsplus_jbd_head {
+	/*
+	 * Points back to our buffer_head. [jbd_lock_bh_hfsplus_jbd_head()]
+	 */
+	struct buffer_head *b_bh;
+
+	/*
+	 * Reference count - see description in journal.c
+	 * [jbd_lock_bh_hfsplus_jbd_head()]
+	 */
+	int b_jcount;
+
+	/*
+	 * Journalling list for this buffer [jbd_lock_bh_state()]
+	 */
+	unsigned b_jlist;
+
+	/*
+	 * This flag signals the buffer has been modified by
+	 * the currently running transaction
+	 * [jbd_lock_bh_state()]
+	 */
+	unsigned b_modified;
+
+	/*
+	 * Copy of the buffer data frozen for writing to the log.
+	 * [jbd_lock_bh_state()]
+	 */
+	char *b_frozen_data;
+
+	/*
+	 * Pointer to a saved copy of the buffer containing no uncommitted
+	 * deallocation references, so that allocations can avoid overwriting
+	 * uncommitted deletes. [jbd_lock_bh_state()]
+	 */
+	char *b_committed_data;
+
+	/*
+	 * Pointer to the compound transaction which owns this buffer's
+	 * metadata: either the running transaction or the committing
+	 * transaction (if there is one).  Only applies to buffers on a
+	 * transaction's data or metadata journaling list.
+	 * [j_list_lock] [jbd_lock_bh_state()]
+	 */
+	hfsplus_transaction_t *b_transaction;
+
+	/*
+	 * Pointer to the running compound transaction which is currently
+	 * modifying the buffer's metadata, if there was already a transaction
+	 * committing it when the new transaction touched it.
+	 * [t_list_lock] [jbd_lock_bh_state()]
+	 */
+	hfsplus_transaction_t *b_next_transaction;
+
+	/*
+	 * Doubly-linked list of buffers on a transaction's data, metadata or
+	 * forget queue. [t_list_lock] [jbd_lock_bh_state()]
+	 */
+	struct hfsplus_jbd_head *b_tnext, *b_tprev;
+
+	/*
+	 * Pointer to the compound transaction against which this buffer
+	 * is checkpointed.  Only dirty buffers can be checkpointed.
+	 * [j_list_lock]
+	 */
+	hfsplus_transaction_t *b_cp_transaction;
+
+	/*
+	 * Doubly-linked list of buffers still remaining to be flushed
+	 * before an old transaction can be checkpointed.
+	 * [j_list_lock]
+	 */
+	struct hfsplus_jbd_head *b_cpnext, *b_cpprev;
+
+	/* Trigger type */
+	struct jbd2_buffer_trigger_type *b_triggers;
+
+	/* Trigger type for the committing transaction's frozen data */
+	struct jbd2_buffer_trigger_type *b_frozen_triggers;
+};
+
+#endif		/* JOURNAL_HEAD_H_INCLUDED */
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/hfsplus_raw.h linux-2.6.32/fs/hfsplus_journal/hfsplus_raw.h
--- linux-2.6.32-old//fs/hfsplus_journal/hfsplus_raw.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/hfsplus_raw.h	2011-11-17 09:00:40.778818402 -0500
@@ -0,0 +1,381 @@
+/*
+ *  linux/include/linux/hfsplus_raw.h
+ *
+ * Copyright (C) 1999
+ * Brad Boyer (flar@pants.nu)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Format of structures on disk
+ * Information taken from Apple Technote #1150 (HFS Plus Volume Format)
+ *
+ */
+
+#ifndef _LINUX_HFSPLUS_RAW_H
+#define _LINUX_HFSPLUS_RAW_H
+
+#include <linux/types.h>
+
+/* Some constants */
+#define HFSPLUS_SECTOR_SIZE        512
+#define HFSPLUS_SECTOR_SHIFT         9
+#define HFSPLUS_VOLHEAD_SECTOR       2
+#define HFSPLUS_VOLHEAD_SIG     0x482b
+#define HFSPLUS_VOLHEAD_SIGX    0x4858
+#define HFSPLUS_SUPER_MAGIC     0x482b
+#define HFSPLUS_MIN_VERSION          4
+#define HFSPLUS_CURRENT_VERSION      5
+
+#define HFSP_WRAP_MAGIC         0x4244
+#define HFSP_WRAP_ATTRIB_SLOCK  0x8000
+#define HFSP_WRAP_ATTRIB_SPARED 0x0200
+
+#define HFSP_WRAPOFF_SIG          0x00
+#define HFSP_WRAPOFF_ATTRIB       0x0A
+#define HFSP_WRAPOFF_ABLKSIZE     0x14
+#define HFSP_WRAPOFF_ABLKSTART    0x1C
+#define HFSP_WRAPOFF_EMBEDSIG     0x7C
+#define HFSP_WRAPOFF_EMBEDEXT     0x7E
+
+#define HFSP_HIDDENDIR_NAME	"\xe2\x90\x80\xe2\x90\x80\xe2\x90\x80\xe2\x90\x80HFS+ Private Data"
+
+#define HFSP_HARDLINK_TYPE	0x686c6e6b	/* 'hlnk' */
+#define HFSP_HFSPLUS_CREATOR	0x6866732b	/* 'hfs+' */
+
+#define HFSP_SYMLINK_TYPE	0x736c6e6b	/* 'slnk' */
+#define HFSP_SYMLINK_CREATOR	0x72686170	/* 'rhap' */
+
+#define HFSP_MOUNT_VERSION	0x482b4c78	/* 'H+Lx' */
+#define HFSP_MOUNT_JOURNALED_VERSION 0x4846534A
+
+/* Structures used on disk */
+
+typedef __be32 hfsplus_cnid;
+typedef __be16 hfsplus_unichr;
+
+/* A "string" as used in filenames, etc. */
+struct hfsplus_unistr {
+	__be16 length;
+	hfsplus_unichr unicode[255];
+} __packed;
+
+#define HFSPLUS_MAX_STRLEN 255
+
+/* POSIX permissions */
+struct hfsplus_perm {
+	__be32 owner;
+	__be32 group;
+	u8  rootflags;
+	u8  userflags;
+	__be16 mode;
+	__be32 dev;
+} __packed;
+
+#define HFSPLUS_FLG_NODUMP	0x01
+#define HFSPLUS_FLG_IMMUTABLE	0x02
+#define HFSPLUS_FLG_APPEND	0x04
+
+/* A single contiguous area of a file */
+struct hfsplus_extent {
+	__be32 start_block;
+	__be32 block_count;
+} __packed;
+typedef struct hfsplus_extent hfsplus_extent_rec[8];
+
+/* Information for a "Fork" in a file */
+struct hfsplus_fork_raw {
+	__be64 total_size;
+	__be32 clump_size;
+	__be32 total_blocks;
+	hfsplus_extent_rec extents;
+} __packed;
+
+/* HFS+ Volume Header */
+struct hfsplus_vh {
+	__be16 signature;
+	__be16 version;
+	__be32 attributes;
+	__be32 last_mount_vers;
+	__be32 journal_info_block;
+
+	__be32 create_date;
+	__be32 modify_date;
+	__be32 backup_date;
+	__be32 checked_date;
+
+	__be32 file_count;
+	__be32 folder_count;
+
+	__be32 blocksize;
+	__be32 total_blocks;
+	__be32 free_blocks;
+
+	__be32 next_alloc;
+	__be32 rsrc_clump_sz;
+	__be32 data_clump_sz;
+	hfsplus_cnid next_cnid;
+
+	__be32 write_count;
+	__be64 encodings_bmp;
+
+	u8 finder_info[32];
+
+	struct hfsplus_fork_raw alloc_file;
+	struct hfsplus_fork_raw ext_file;
+	struct hfsplus_fork_raw cat_file;
+	struct hfsplus_fork_raw attr_file;
+	struct hfsplus_fork_raw start_file;
+} __packed;
+
+/* HFS+ volume attributes */
+#define HFSPLUS_VOL_UNMNT		(1 << 8)
+#define HFSPLUS_VOL_SPARE_BLK		(1 << 9)
+#define HFSPLUS_VOL_NOCACHE		(1 << 10)
+#define HFSPLUS_VOL_INCNSTNT		(1 << 11)
+#define HFSPLUS_VOL_NODEID_REUSED	(1 << 12)
+#define HFSPLUS_VOL_JOURNALED		(1 << 13)
+#define HFSPLUS_VOL_SOFTLOCK		(1 << 15)
+
+/* HFS+ BTree node descriptor */
+struct hfs_bnode_desc {
+	__be32 next;
+	__be32 prev;
+	s8 type;
+	u8 height;
+	__be16 num_recs;
+	u16 reserved;
+} __packed;
+
+/* HFS+ BTree node types */
+#define HFS_NODE_INDEX	0x00
+#define HFS_NODE_HEADER	0x01
+#define HFS_NODE_MAP	0x02
+#define HFS_NODE_LEAF	0xFF
+
+/* HFS+ BTree header */
+struct hfs_btree_header_rec {
+	__be16 depth;
+	__be32 root;
+	__be32 leaf_count;
+	__be32 leaf_head;
+	__be32 leaf_tail;
+	__be16 node_size;
+	__be16 max_key_len;
+	__be32 node_count;
+	__be32 free_nodes;
+	u16 reserved1;
+	__be32 clump_size;
+	u8 btree_type;
+	u8 key_type;
+	__be32 attributes;
+	u32 reserved3[16];
+} __packed;
+
+/* BTree attributes */
+#define HFS_TREE_BIGKEYS	2
+#define HFS_TREE_VARIDXKEYS	4
+
+/* HFS+ BTree misc info */
+#define HFSPLUS_TREE_HEAD 0
+#define HFSPLUS_NODE_MXSZ 32768
+
+/* Some special File ID numbers (stolen from hfs.h) */
+#define HFSPLUS_POR_CNID		1	/* Parent Of the Root */
+#define HFSPLUS_ROOT_CNID		2	/* ROOT directory */
+#define HFSPLUS_EXT_CNID		3	/* EXTents B-tree */
+#define HFSPLUS_CAT_CNID		4	/* CATalog B-tree */
+#define HFSPLUS_BAD_CNID		5	/* BAD blocks file */
+#define HFSPLUS_ALLOC_CNID		6	/* ALLOCation file */
+#define HFSPLUS_START_CNID		7	/* STARTup file */
+#define HFSPLUS_ATTR_CNID		8	/* ATTRibutes file */
+#define HFSPLUS_EXCH_CNID		15	/* ExchangeFiles temp id */
+#define HFSPLUS_FIRSTUSER_CNID		16	/* first available user id */
+
+/* btree key type */
+#define HFSPLUS_KEY_CASEFOLDING		0xCF	/* case-insensitive */
+#define HFSPLUS_KEY_BINARY		0xBC	/* case-sensitive */
+
+/* HFS+ catalog entry key */
+struct hfsplus_cat_key {
+	__be16 key_len;
+	hfsplus_cnid parent;
+	struct hfsplus_unistr name;
+} __packed;
+
+
+/* Structs from hfs.h */
+struct hfsp_point {
+	__be16 v;
+	__be16 h;
+} __packed;
+
+struct hfsp_rect {
+	__be16 top;
+	__be16 left;
+	__be16 bottom;
+	__be16 right;
+} __packed;
+
+
+/* HFS directory info (stolen from hfs.h */
+struct DInfo {
+	struct hfsp_rect frRect;
+	__be16 frFlags;
+	struct hfsp_point frLocation;
+	__be16 frView;
+} __packed;
+
+struct DXInfo {
+	struct hfsp_point frScroll;
+	__be32 frOpenChain;
+	__be16 frUnused;
+	__be16 frComment;
+	__be32 frPutAway;
+} __packed;
+
+/* HFS+ folder data (part of an hfsplus_cat_entry) */
+struct hfsplus_cat_folder {
+	__be16 type;
+	__be16 flags;
+	__be32 valence;
+	hfsplus_cnid id;
+	__be32 create_date;
+	__be32 content_mod_date;
+	__be32 attribute_mod_date;
+	__be32 access_date;
+	__be32 backup_date;
+	struct hfsplus_perm permissions;
+	struct DInfo user_info;
+	struct DXInfo finder_info;
+	__be32 text_encoding;
+	u32 reserved;
+} __packed;
+
+/* HFS file info (stolen from hfs.h) */
+struct FInfo {
+	__be32 fdType;
+	__be32 fdCreator;
+	__be16 fdFlags;
+	struct hfsp_point fdLocation;
+	__be16 fdFldr;
+} __packed;
+
+struct FXInfo {
+	__be16 fdIconID;
+	u8 fdUnused[8];
+	__be16 fdComment;
+	__be32 fdPutAway;
+} __packed;
+
+/* HFS+ file data (part of a cat_entry) */
+struct hfsplus_cat_file {
+	__be16 type;
+	__be16 flags;
+	u32 reserved1;
+	hfsplus_cnid id;
+	__be32 create_date;
+	__be32 content_mod_date;
+	__be32 attribute_mod_date;
+	__be32 access_date;
+	__be32 backup_date;
+	struct hfsplus_perm permissions;
+	struct FInfo user_info;
+	struct FXInfo finder_info;
+	__be32 text_encoding;
+	u32 reserved2;
+
+	struct hfsplus_fork_raw data_fork;
+	struct hfsplus_fork_raw rsrc_fork;
+} __packed;
+
+/* File attribute bits */
+#define HFSPLUS_FILE_LOCKED		0x0001
+#define HFSPLUS_FILE_THREAD_EXISTS	0x0002
+
+/* HFS+ catalog thread (part of a cat_entry) */
+struct hfsplus_cat_thread {
+	__be16 type;
+	s16 reserved;
+	hfsplus_cnid parentID;
+	struct hfsplus_unistr nodeName;
+} __packed;
+
+#define HFSPLUS_MIN_THREAD_SZ 10
+
+/* A data record in the catalog tree */
+typedef union {
+	__be16 type;
+	struct hfsplus_cat_folder folder;
+	struct hfsplus_cat_file file;
+	struct hfsplus_cat_thread thread;
+} __packed hfsplus_cat_entry;
+
+/* HFS+ catalog entry type */
+#define HFSPLUS_FOLDER         0x0001
+#define HFSPLUS_FILE           0x0002
+#define HFSPLUS_FOLDER_THREAD  0x0003
+#define HFSPLUS_FILE_THREAD    0x0004
+
+/* HFS+ extents tree key */
+struct hfsplus_ext_key {
+	__be16 key_len;
+	u8 fork_type;
+	u8 pad;
+	hfsplus_cnid cnid;
+	__be32 start_block;
+} __packed;
+
+#define HFSPLUS_EXT_KEYLEN 12
+
+/* HFS+ generic BTree key */
+typedef union {
+	__be16 key_len;
+	struct hfsplus_cat_key cat;
+	struct hfsplus_ext_key ext;
+} __packed hfsplus_btree_key;
+
+struct hfsplus_journal_info_block {
+	__be32 flags;
+	__be32 device_signature[8];
+	__be64 offset;
+	__be64 size;
+	u32 reserved[32];
+} __packed;
+
+/* Possible values of flags */
+#define HFSPLUS_JOURNAL_IN_FS		0x01
+#define HFSPLUS_JOURNAL_ON_OTHER_DEVICE	0x02
+#define HFSPLUS_JOURNAL_NEED_INIT	0x04
+
+struct hfsplus_journal_header {
+	__be32 magic;
+	__be32 endian;
+	__be64 start;
+	__be64 end;
+	__be64 size; /* This includes the journal header and the journal buffer */
+	__be32 blhdr_size;
+	__be32 checksum;
+	__be32 jhdr_size;
+} __packed;
+
+/* Valid magic and endian value */
+#define HFSPLUS_JOURNAL_HEADER_MAGIC	0x4A4E4C78
+#define HFSPLUS_JOURNAL_HEADER_ENDIAN	0x12345678
+
+struct hfsplus_block_info {
+	__be64 bnum;
+	__be32 bsize;
+	__be32 next;
+} __packed;
+
+struct hfsplus_blhdr {
+	__be16 max_blocks;
+	__be16 num_blocks;
+	__be32 bytes_used;
+	__be32 checksum;
+	__be32 pad;
+	struct hfsplus_block_info binfo[1];
+} __packed;
+
+typedef struct hfsplus_blhdr hfsplus_blhdr_t;
+
+#endif
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/inode.c linux-2.6.32/fs/hfsplus_journal/inode.c
--- linux-2.6.32-old//fs/hfsplus_journal/inode.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/inode.c	2011-11-17 09:00:40.778818402 -0500
@@ -0,0 +1,862 @@
+/*
+ *  linux/fs/hfsplus/inode.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Inode handling routines
+ */
+
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <linux/mpage.h>
+#include <linux/sched.h>
+
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+static int hfsplus_readpage(struct file *file, struct page *page)
+{
+	return block_read_full_page(page, hfsplus_get_block);
+}
+
+static int hfsplus_writepage(struct page *page, struct writeback_control *wbc)
+{
+	return block_write_full_page(page, hfsplus_get_block, wbc);
+}
+
+static int hfsplus_write_begin(struct file *file, struct address_space *mapping,
+			loff_t pos, unsigned len, unsigned flags,
+			struct page **pagep, void **fsdata)
+{
+	*pagep = NULL;
+	return cont_write_begin(file, mapping, pos, len, flags, pagep, fsdata,
+				hfsplus_get_block,
+				&HFSPLUS_I(mapping->host).phys_size);
+}
+
+static sector_t hfsplus_bmap(struct address_space *mapping, sector_t block)
+{
+	return generic_block_bmap(mapping, block, hfsplus_get_block);
+}
+
+#if 0
+static sector_t hfsplus_journalled_bmap(struct address_space *mapping, sector_t block)
+{
+	struct inode *inode = mapping->host;
+	sector_t ret;
+
+	hfsplus_handle_t hfsplus_handle;
+	if (hfsplus_journal_start(__FUNCTION__, inode->i_sb, &hfsplus_handle))
+		return 1; /* TODO: Need to check return value */
+
+	ret = generic_block_bmap(mapping, block, hfsplus_get_block);
+
+	hfsplus_journal_stop(&hfsplus_handle);
+
+	return ret;
+}
+#endif
+
+static int hfsplus_releasepage(struct page *page, gfp_t mask)
+{
+	struct inode *inode = page->mapping->host;
+	struct super_block *sb = inode->i_sb;
+	struct hfs_btree *tree;
+	struct hfs_bnode *node;
+	u32 nidx;
+	int i, res = 1;
+
+	switch (inode->i_ino) {
+	case HFSPLUS_EXT_CNID:
+		tree = HFSPLUS_SB(sb).ext_tree;
+		break;
+	case HFSPLUS_CAT_CNID:
+		tree = HFSPLUS_SB(sb).cat_tree;
+		break;
+	case HFSPLUS_ATTR_CNID:
+		tree = HFSPLUS_SB(sb).attr_tree;
+		break;
+	default:
+		BUG();
+		return 0;
+	}
+	if (!tree)
+		return 0;
+	if (tree->node_size >= PAGE_CACHE_SIZE) {
+		nidx = page->index >> (tree->node_size_shift - PAGE_CACHE_SHIFT);
+		spin_lock(&tree->hash_lock);
+		node = hfs_bnode_findhash(tree, nidx);
+		if (!node)
+			;
+		else if (atomic_read(&node->refcnt))
+			res = 0;
+		if (res && node) {
+			hfs_bnode_unhash(node);
+			hfs_bnode_free(node);
+		}
+		spin_unlock(&tree->hash_lock);
+	} else {
+		nidx = page->index << (PAGE_CACHE_SHIFT - tree->node_size_shift);
+		i = 1 << (PAGE_CACHE_SHIFT - tree->node_size_shift);
+		spin_lock(&tree->hash_lock);
+		do {
+			node = hfs_bnode_findhash(tree, nidx++);
+			if (!node)
+				continue;
+			if (atomic_read(&node->refcnt)) {
+				res = 0;
+				break;
+			}
+			hfs_bnode_unhash(node);
+			hfs_bnode_free(node);
+		} while (--i && nidx < tree->node_count);
+		spin_unlock(&tree->hash_lock);
+	}
+	return res ? try_to_free_buffers(page) : 0;
+}
+
+int hfsplus_commit_write_fn(hfsplus_handle_t *hfsplus_handle, struct buffer_head *bh)
+{
+	if (!buffer_mapped(bh) || buffer_hfsplus_jbd_freed(bh))
+		return 0;
+	set_buffer_uptodate(bh);
+
+	return hfsplus_journal_dirty_metadata(__FUNCTION__, bh, hfsplus_handle);
+}
+
+static int hfsplus_jbd_set_page_dirty(struct page *page)
+{
+	SetPageChecked(page);
+	return __set_page_dirty_nobuffers(page);
+}
+
+int hfsplus_walk_page_buffers(hfsplus_handle_t *hfsplus_handle,
+				struct buffer_head *head,
+				unsigned from,
+				unsigned to,
+				int *partial,
+				int (*fn)(hfsplus_handle_t *hfsplus_handle,
+						struct buffer_head *bh))
+{
+	struct buffer_head *bh;
+	unsigned block_start, block_end;
+	unsigned blocksize = head->b_size;
+	int err, ret = 0;
+	struct buffer_head *next;
+
+	for (	bh = head, block_start = 0;
+		ret == 0 && (bh != head || !block_start);
+	    	block_start = block_end, bh = next)
+	{
+		next = bh->b_this_page;
+		block_end = block_start + blocksize;
+		if (block_end <= from || block_start >= to) {
+			if (partial && !buffer_uptodate(bh))
+				*partial = 1;
+			continue;
+		}
+		err = (*fn)(hfsplus_handle, bh);
+		if (!ret)
+			ret = err;
+	}
+	return ret;
+}
+
+int hfsplus_do_journal_get_write_access(hfsplus_handle_t *hfsplus_handle, struct buffer_head *bh)
+{
+	if (!buffer_mapped(bh) || buffer_hfsplus_jbd_freed(bh))
+		return 0;
+	return hfsplus_journal_get_write_access(__FUNCTION__, hfsplus_handle, bh);
+}
+
+static int hfsplus_journalled_writepage(struct page *page, struct writeback_control *wbc)
+{
+	struct inode *inode = page->mapping->host;
+	struct super_block *sb;
+	hfsplus_handle_t hfsplus_handle;
+	hfsplus_jbd_t *journal;
+	int ret = 0;
+	int err;
+
+	sb = inode->i_sb;
+
+	if (hfsplus_jbd_current_handle()) {
+		dprint(DBG_JCOMMIT, "HFS+-fs: It is already in a handle\n");
+		goto no_write;
+	}
+
+	journal = HFSPLUS_SB(sb).jnl.s_journal;
+	if (is_hfsplus_jbd_aborted(journal)) {
+		printk("HFS+-fs: Detected aborted journal\n");
+		goto no_write;
+	}
+
+	if ((ret = hfsplus_journal_start(__FUNCTION__, sb, &hfsplus_handle))) 
+		goto no_write;
+
+	/* Taken from ext3 */
+	if (!page_has_buffers(page) || PageChecked(page)) {
+		/*
+		 * It's mmapped pagecache.  Add buffers and journal it.  There
+		 * doesn't seem much point in redirtying the page here.
+		 */
+		ClearPageChecked(page);
+		ret = block_prepare_write(page, 0, PAGE_CACHE_SIZE, hfsplus_get_block);
+		if (ret != 0) {
+			hfsplus_journal_stop(&hfsplus_handle);
+			goto out_unlock;
+		}
+		ret = hfsplus_walk_page_buffers(&hfsplus_handle, page_buffers(page), 0,
+			PAGE_CACHE_SIZE, NULL, hfsplus_do_journal_get_write_access);
+
+		err = hfsplus_walk_page_buffers(&hfsplus_handle, page_buffers(page), 0,
+				PAGE_CACHE_SIZE, NULL, hfsplus_commit_write_fn);
+		if (ret == 0)
+			ret = err;
+		unlock_page(page);
+	} else {
+		/*
+		 * It may be a page full of checkpoint-mode buffers.  We don't
+		 * really know unless we go poke around in the buffer_heads.
+		 * But block_write_full_page will do the right thing.
+		 */
+		ret = block_write_full_page(page, hfsplus_get_block, wbc);
+	}
+	err = hfsplus_journal_stop(&hfsplus_handle);
+	if (!ret)
+		ret = err;
+
+out:
+	return ret;
+
+no_write:
+	redirty_page_for_writepage(wbc, page);
+out_unlock:
+	unlock_page(page);
+	goto out;
+}
+
+static int hfsplus_journalled_write_begin(struct file *file, struct address_space *mapping, 
+	loff_t pos, unsigned len, unsigned flags, struct page **pagep, void **fsdata)
+{
+	struct inode *inode = mapping->host;
+	hfsplus_handle_t hfsplus_handle;
+	int ret;
+
+	if ((ret = hfsplus_journal_start(__FUNCTION__, inode->i_sb, &hfsplus_handle)))
+		goto out;
+	
+	*pagep = NULL;
+	ret = cont_write_begin(file, mapping, pos, len, flags, pagep, fsdata,
+				hfsplus_get_block,
+				&HFSPLUS_I(mapping->host).phys_size);
+	
+	if (ret)
+		hfsplus_journal_stop(&hfsplus_handle);
+	
+out:
+	return ret;
+}
+
+static int hfsplus_journalled_write_end(struct file *file, struct address_space *mapping,
+		loff_t pos, unsigned len, unsigned copied, struct page *page, void *fsdata)
+{
+	
+	hfsplus_handle_t *hfsplus_handle; 
+	struct inode *inode = mapping->host;
+	int ret = 0, ret2;
+	int partial = 0;
+	int i_size_changed = 0;
+	unsigned start;
+
+	hfsplus_handle = hfsplus_jbd_current_handle();
+
+	//Here we duplicate the generic_write_end() functionality
+	start = pos & (PAGE_CACHE_SIZE -1);
+	if (unlikely(copied < len)) {
+		/* The buffers that were written will now be upto date, so we
+		  * don't have to worry about a readpage reading them and
+		  * overwiting a partial write. However if we have encountered
+		  * a short write and only partially written into a buffer, it will
+		  * not be marked uptodate, so a readpage might come in and
+		  * destroy our partial write.
+		  *
+		  * Do the simplest thing, and just treat any short write to a
+		  * non uptodate page as a zero-length write, and force the
+		  * caller to redo the whole thing.
+		*/
+		if (!PageUptodate(page))
+			copied = 0;
+		page_zero_new_buffers(page, start+copied, start+len);
+	}
+	flush_dcache_page(page);
+	
+	pos = ((loff_t)page->index << PAGE_CACHE_SHIFT) + start + copied;
+
+	//This could be a short (even 0-length) commint.
+	ret = hfsplus_walk_page_buffers(hfsplus_handle, page_buffers(page), start, 
+			start+copied, &partial, hfsplus_commit_write_fn);
+	if (!partial)
+		SetPageUptodate(page);
+	if (pos+copied > inode->i_size) {
+		i_size_write(inode, pos+copied);
+		i_size_changed = 1;
+	}
+
+	//unlockpage(page_buffers(page));
+	page_cache_release(page);
+
+	//Don't mark the inode dirty under page lock, First, it unnecessarily makes the holding time of page lock longer.
+	//Second, it forces lock ordering of page lock and transaction start for journaling filesystems.
+	ret2 = hfsplus_journalled_mark_inode_dirty(__FUNCTION__, hfsplus_handle, inode);
+	
+	ret2 = hfsplus_journal_stop(hfsplus_handle);
+	//if (!ret)
+	//	ret = ret2;
+	
+	//return ret;
+	return copied;
+	
+}
+
+/*static int hfsplus_get_blocks(struct inode *inode, sector_t iblock, unsigned long max_blocks,
+			      struct buffer_head *bh_result, int create)
+{
+	int ret;
+
+	ret = hfsplus_get_block(inode, iblock, bh_result, create);
+	if (!ret)
+		bh_result->b_size = (1 << inode->i_blkbits);
+	return ret;
+}*/
+
+static ssize_t hfsplus_direct_IO(int rw, struct kiocb *iocb,
+		const struct iovec *iov, loff_t offset, unsigned long nr_segs)
+{
+	struct file *file = iocb->ki_filp;
+	struct inode *inode = file->f_path.dentry->d_inode->i_mapping->host;
+
+	return blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev, iov,
+				  offset, nr_segs, hfsplus_get_block, NULL);
+}
+
+#if 0
+static ssize_t hfsplus_journalled_direct_IO(int rw, struct kiocb *iocb,
+		const struct iovec *iov, loff_t offset, unsigned long nr_segs)
+{
+	struct file *file = iocb->ki_filp;
+	struct inode *inode = file->f_dentry->d_inode->i_mapping->host;
+	int ret;
+	hfsplus_handle_t hfsplus_handle;
+
+	if (hfsplus_journal_start(__FUNCTION__, inode->i_sb, &hfsplus_handle))
+		return 1; /* TODO: Need to check return value */
+
+	ret = blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev, iov,
+				  offset, nr_segs, hfsplus_get_blocks, NULL);
+
+	hfsplus_journal_stop(&hfsplus_handle);
+
+	return ret;
+}
+#endif
+
+static int hfsplus_writepages(struct address_space *mapping,
+			      struct writeback_control *wbc)
+{
+	struct inode * const inode = mapping->host;
+	int ret;
+	u32 block_num = be32_to_cpu(HFSPLUS_I(inode).first_extents[0].start_block);
+
+	if (block_num == 1)
+		return mpage_writepages(mapping, wbc, NULL);
+	else
+		return mpage_writepages(mapping, wbc, hfsplus_get_block);
+
+	return ret;
+}
+
+#if 0
+static int hfsplus_journalled_writepages(struct address_space *mapping,
+			      struct writeback_control *wbc)
+{
+	struct inode * const inode = mapping->host;
+	u32 block_num = be32_to_cpu(HFSPLUS_I(inode).first_extents[0].start_block);
+	int ret;
+	hfsplus_handle_t hfsplus_handle;
+
+	if (hfsplus_journal_start(__FUNCTION__, inode->i_sb, &hfsplus_handle))
+		return 1; /* TODO: Need to check return value */
+
+	if (block_num == 1)
+		ret = mpage_writepages(mapping, wbc, NULL);
+	else
+		ret = mpage_writepages(mapping, wbc, hfsplus_get_block);
+
+	hfsplus_journal_stop(&hfsplus_handle);
+	return ret;
+}
+#endif
+
+const struct address_space_operations hfsplus_journalled_btree_aops = {
+	.readpage	= hfsplus_readpage,
+	.writepage	= hfsplus_journalled_writepage,
+	.sync_page	= block_sync_page,
+	.write_begin	= hfsplus_journalled_write_begin,
+	.write_end	= hfsplus_journalled_write_end,
+	.set_page_dirty = hfsplus_jbd_set_page_dirty,
+	.bmap		= hfsplus_bmap,
+	.releasepage	= hfsplus_releasepage,
+};
+
+const struct address_space_operations hfsplus_journalled_aops = {
+	.readpage	= hfsplus_readpage,
+	.writepage	= hfsplus_journalled_writepage,
+	.sync_page	= block_sync_page,
+	.write_begin	= hfsplus_journalled_write_begin,
+	.write_end	= hfsplus_journalled_write_end,
+	.set_page_dirty = hfsplus_jbd_set_page_dirty,
+	.bmap		= hfsplus_bmap,
+	.direct_IO	= hfsplus_direct_IO,
+	.writepages	= hfsplus_writepages,
+};
+
+const struct address_space_operations hfsplus_btree_aops = {
+	.readpage	= hfsplus_readpage,
+	.writepage	= hfsplus_writepage,
+	.sync_page	= block_sync_page,
+	.write_begin	= hfsplus_write_begin,
+	.write_end	= generic_write_end,
+	.bmap		= hfsplus_bmap,
+	.releasepage	= hfsplus_releasepage,
+};
+
+const struct address_space_operations hfsplus_aops = {
+	.readpage	= hfsplus_readpage,
+	.writepage	= hfsplus_writepage,
+	.sync_page	= block_sync_page,
+	.write_begin	= hfsplus_write_begin,
+	.write_end	= generic_write_end,
+	.bmap		= hfsplus_bmap,
+	.direct_IO	= hfsplus_direct_IO,
+	.writepages	= hfsplus_writepages,
+};
+
+const struct dentry_operations hfsplus_dentry_operations = {
+	.d_hash       = hfsplus_hash_dentry,
+	.d_compare    = hfsplus_compare_dentry,
+};
+
+static struct dentry *hfsplus_file_lookup(struct inode *dir, struct dentry *dentry,
+					  struct nameidata *nd)
+{
+	struct hfs_find_data fd;
+	struct super_block *sb = dir->i_sb;
+	struct inode *inode = NULL;
+	hfsplus_handle_t hfsplus_handle;
+	int err;
+
+	if (HFSPLUS_IS_RSRC(dir) || strcmp(dentry->d_name.name, "rsrc"))
+		goto out;
+
+	inode = HFSPLUS_I(dir).rsrc_inode;
+	if (inode)
+		goto out;
+
+	if (hfsplus_journal_start(__FUNCTION__, sb, &hfsplus_handle))
+		return NULL;
+
+	inode = new_inode(sb);
+	if (!inode) {
+		hfsplus_journal_stop(&hfsplus_handle);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	inode->i_ino = dir->i_ino;
+	INIT_LIST_HEAD(&HFSPLUS_I(inode).open_dir_list);
+	mutex_init(&HFSPLUS_I(inode).extents_lock);
+	HFSPLUS_I(inode).flags = HFSPLUS_FLG_RSRC;
+
+	hfs_find_init(HFSPLUS_SB(sb).cat_tree, &fd);
+	err = hfsplus_find_cat(&hfsplus_handle, sb, dir->i_ino, &fd);
+	if (!err)
+		err = hfsplus_cat_read_inode(inode, &fd);
+	hfs_find_exit(&hfsplus_handle, &fd);
+	if (err) {
+		iput(inode);
+		hfsplus_journal_stop(&hfsplus_handle);
+		return ERR_PTR(err);
+	}
+	HFSPLUS_I(inode).rsrc_inode = dir;
+	HFSPLUS_I(dir).rsrc_inode = inode;
+	igrab(dir);
+	hlist_add_head(&inode->i_hash, &HFSPLUS_SB(sb).rsrc_inodes);
+	hfsplus_journalled_mark_inode_dirty(__FUNCTION__, &hfsplus_handle, inode);
+	hfsplus_journal_stop(&hfsplus_handle);
+out:
+	d_add(dentry, inode);
+	return NULL;
+}
+
+static void hfsplus_get_perms(struct inode *inode, struct hfsplus_perm *perms, int dir)
+{
+	struct super_block *sb = inode->i_sb;
+	u16 mode;
+
+	mode = be16_to_cpu(perms->mode);
+
+	inode->i_uid = be32_to_cpu(perms->owner);
+	if (!inode->i_uid && !mode)
+		inode->i_uid = HFSPLUS_SB(sb).uid;
+
+	inode->i_gid = be32_to_cpu(perms->group);
+	if (!inode->i_gid && !mode)
+		inode->i_gid = HFSPLUS_SB(sb).gid;
+
+	if (dir) {
+		mode = mode ? (mode & S_IALLUGO) :
+			(S_IRWXUGO & ~(HFSPLUS_SB(sb).umask));
+		mode |= S_IFDIR;
+	} else if (!mode)
+		mode = S_IFREG | ((S_IRUGO|S_IWUGO) &
+			~(HFSPLUS_SB(sb).umask));
+	inode->i_mode = mode;
+
+	HFSPLUS_I(inode).rootflags = perms->rootflags;
+	HFSPLUS_I(inode).userflags = perms->userflags;
+	if (perms->rootflags & HFSPLUS_FLG_IMMUTABLE)
+		inode->i_flags |= S_IMMUTABLE;
+	else
+		inode->i_flags &= ~S_IMMUTABLE;
+	if (perms->rootflags & HFSPLUS_FLG_APPEND)
+		inode->i_flags |= S_APPEND;
+	else
+		inode->i_flags &= ~S_APPEND;
+}
+
+static void hfsplus_set_perms(struct inode *inode, struct hfsplus_perm *perms)
+{
+	if (inode->i_flags & S_IMMUTABLE)
+		perms->rootflags |= HFSPLUS_FLG_IMMUTABLE;
+	else
+		perms->rootflags &= ~HFSPLUS_FLG_IMMUTABLE;
+	if (inode->i_flags & S_APPEND)
+		perms->rootflags |= HFSPLUS_FLG_APPEND;
+	else
+		perms->rootflags &= ~HFSPLUS_FLG_APPEND;
+	perms->userflags = HFSPLUS_I(inode).userflags;
+	perms->mode = cpu_to_be16(inode->i_mode);
+	perms->owner = cpu_to_be32(inode->i_uid);
+	perms->group = cpu_to_be32(inode->i_gid);
+	perms->dev = cpu_to_be32(HFSPLUS_I(inode).dev);
+}
+
+static int hfsplus_file_open(struct inode *inode, struct file *file)
+{
+	if (HFSPLUS_IS_RSRC(inode))
+		inode = HFSPLUS_I(inode).rsrc_inode;
+	if (!(file->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)
+		return -EOVERFLOW;
+	atomic_inc(&HFSPLUS_I(inode).opencnt);
+	return 0;
+}
+
+static int hfsplus_file_release(struct inode *inode, struct file *file)
+{
+	struct super_block *sb = inode->i_sb;
+	hfsplus_handle_t hfsplus_handle;
+
+	if (HFSPLUS_IS_RSRC(inode))
+		inode = HFSPLUS_I(inode).rsrc_inode;
+	if (atomic_dec_and_test(&HFSPLUS_I(inode).opencnt)) {
+		int ret;
+		mutex_lock(&inode->i_mutex);
+		hfsplus_file_truncate(inode);
+		if (inode->i_flags & S_DEAD) {
+			if ((ret = hfsplus_journal_start(__FUNCTION__, sb, &hfsplus_handle))) {
+				mutex_unlock(&inode->i_mutex);
+				return ret;
+			}
+			hfsplus_delete_cat(&hfsplus_handle, inode->i_ino, HFSPLUS_SB(sb).hidden_dir, NULL);
+			hfsplus_delete_inode(&hfsplus_handle, inode);
+			hfsplus_journal_stop(&hfsplus_handle);
+		}
+		mutex_unlock(&inode->i_mutex);
+	}
+	return 0;
+}
+
+static const struct inode_operations hfsplus_file_inode_operations = {
+	.lookup		= hfsplus_file_lookup,
+	.truncate	= hfsplus_file_truncate,
+	.setxattr	= hfsplus_setxattr,
+	.getxattr	= hfsplus_getxattr,
+	.listxattr	= hfsplus_listxattr,
+};
+
+static const struct file_operations hfsplus_file_operations = {
+	.llseek 	= generic_file_llseek,
+	.read		= do_sync_read,
+	.aio_read	= generic_file_aio_read,
+	.write		= do_sync_write,
+	.aio_write	= generic_file_aio_write,
+	.mmap		= generic_file_mmap,
+	.splice_read	= generic_file_splice_read,
+	.fsync		= file_fsync,
+	.open		= hfsplus_file_open,
+	.release	= hfsplus_file_release,
+	.ioctl          = hfsplus_ioctl,
+};
+
+struct inode *hfsplus_new_inode(hfsplus_handle_t *hfsplus_handle, struct super_block *sb, int mode)
+{
+	struct inode *inode = new_inode(sb);
+	if (!inode)
+		return NULL;
+
+	inode->i_ino = HFSPLUS_SB(sb).next_cnid++;
+	inode->i_mode = mode;
+	inode->i_uid = current_fsuid();
+	inode->i_gid = current_fsgid();
+	inode->i_nlink = 1;
+	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
+	INIT_LIST_HEAD(&HFSPLUS_I(inode).open_dir_list);
+	mutex_init(&HFSPLUS_I(inode).extents_lock);
+	atomic_set(&HFSPLUS_I(inode).opencnt, 0);
+	HFSPLUS_I(inode).flags = 0;
+	memset(HFSPLUS_I(inode).first_extents, 0, sizeof(hfsplus_extent_rec));
+	memset(HFSPLUS_I(inode).cached_extents, 0, sizeof(hfsplus_extent_rec));
+	HFSPLUS_I(inode).alloc_blocks = 0;
+	HFSPLUS_I(inode).first_blocks = 0;
+	HFSPLUS_I(inode).cached_start = 0;
+	HFSPLUS_I(inode).cached_blocks = 0;
+	HFSPLUS_I(inode).phys_size = 0;
+	HFSPLUS_I(inode).fs_blocks = 0;
+	HFSPLUS_I(inode).rsrc_inode = NULL;
+	if (S_ISDIR(inode->i_mode)) {
+		inode->i_size = 2;
+		HFSPLUS_SB(sb).folder_count++;
+		inode->i_op = &hfsplus_dir_inode_operations;
+		inode->i_fop = &hfsplus_dir_operations;
+	} else if (S_ISREG(inode->i_mode)) {
+		HFSPLUS_SB(sb).file_count++;
+		inode->i_op = &hfsplus_file_inode_operations;
+		inode->i_fop = &hfsplus_file_operations;
+		inode->i_mapping->a_ops = &hfsplus_aops;
+		HFSPLUS_I(inode).clump_blocks = HFSPLUS_SB(sb).data_clump_blocks;
+	} else if (S_ISLNK(inode->i_mode)) {
+		HFSPLUS_SB(sb).file_count++;
+		inode->i_op = &page_symlink_inode_operations;
+		inode->i_mapping->a_ops = &hfsplus_aops;
+		HFSPLUS_I(inode).clump_blocks = 1;
+	} else
+		HFSPLUS_SB(sb).file_count++;
+	insert_inode_hash(inode);
+	if (hfsplus_journalled_mark_inode_dirty(__FUNCTION__, hfsplus_handle, inode)) {
+		hfsplus_delete_inode(hfsplus_handle, inode);	
+		return NULL;
+	}
+	sb->s_dirt = 1;
+
+	return inode;
+}
+
+void hfsplus_delete_inode(hfsplus_handle_t *hfsplus_handle, struct inode *inode)
+{
+	struct super_block *sb = inode->i_sb;
+
+	if (S_ISDIR(inode->i_mode)) {
+		HFSPLUS_SB(sb).folder_count--;
+		sb->s_dirt = 1;
+		return;
+	}
+	HFSPLUS_SB(sb).file_count--;
+	if (S_ISREG(inode->i_mode)) {
+		if (!inode->i_nlink) {
+			inode->i_size = 0;
+			hfsplus_file_truncate(inode);
+		}
+	} else if (S_ISLNK(inode->i_mode)) {
+		inode->i_size = 0;
+		hfsplus_file_truncate(inode);
+	}
+	sb->s_dirt = 1;
+}
+
+void hfsplus_inode_read_fork(struct inode *inode, struct hfsplus_fork_raw *fork)
+{
+	struct super_block *sb = inode->i_sb;
+	u32 count;
+	int i;
+
+	memcpy(&HFSPLUS_I(inode).first_extents, &fork->extents,
+	       sizeof(hfsplus_extent_rec));
+	for (count = 0, i = 0; i < 8; i++)
+		count += be32_to_cpu(fork->extents[i].block_count);
+	HFSPLUS_I(inode).first_blocks = count;
+	memset(HFSPLUS_I(inode).cached_extents, 0, sizeof(hfsplus_extent_rec));
+	HFSPLUS_I(inode).cached_start = 0;
+	HFSPLUS_I(inode).cached_blocks = 0;
+
+	HFSPLUS_I(inode).alloc_blocks = be32_to_cpu(fork->total_blocks);
+	inode->i_size = HFSPLUS_I(inode).phys_size = be64_to_cpu(fork->total_size);
+	HFSPLUS_I(inode).fs_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;
+	inode_set_bytes(inode, HFSPLUS_I(inode).fs_blocks << sb->s_blocksize_bits);
+	HFSPLUS_I(inode).clump_blocks = be32_to_cpu(fork->clump_size) >> HFSPLUS_SB(sb).alloc_blksz_shift;
+	if (!HFSPLUS_I(inode).clump_blocks)
+		HFSPLUS_I(inode).clump_blocks = HFSPLUS_IS_RSRC(inode) ? HFSPLUS_SB(sb).rsrc_clump_blocks :
+				HFSPLUS_SB(sb).data_clump_blocks;
+}
+
+void hfsplus_inode_write_fork(struct inode *inode, struct hfsplus_fork_raw *fork)
+{
+	memcpy(&fork->extents, &HFSPLUS_I(inode).first_extents,
+	       sizeof(hfsplus_extent_rec));
+	fork->total_size = cpu_to_be64(inode->i_size);
+	fork->total_blocks = cpu_to_be32(HFSPLUS_I(inode).alloc_blocks);
+}
+
+int hfsplus_cat_read_inode(struct inode *inode, struct hfs_find_data *fd)
+{
+	hfsplus_cat_entry entry;
+	int res = 0;
+	u16 type;
+
+	type = hfs_bnode_read_u16(fd->bnode, fd->entryoffset);
+
+	HFSPLUS_I(inode).dev = 0;
+	if (type == HFSPLUS_FOLDER) {
+		struct hfsplus_cat_folder *folder = &entry.folder;
+
+		if (fd->entrylength < sizeof(struct hfsplus_cat_folder))
+			/* panic? */;
+		hfs_bnode_read(fd->bnode, &entry, fd->entryoffset,
+					sizeof(struct hfsplus_cat_folder));
+		hfsplus_get_perms(inode, &folder->permissions, 1);
+		inode->i_nlink = 1;
+		inode->i_size = 2 + be32_to_cpu(folder->valence);
+		inode->i_atime = hfsp_mt2ut(folder->access_date);
+		inode->i_mtime = hfsp_mt2ut(folder->content_mod_date);
+		inode->i_ctime = hfsp_mt2ut(folder->attribute_mod_date);
+		HFSPLUS_I(inode).create_date = folder->create_date;
+		HFSPLUS_I(inode).fs_blocks = 0;
+		inode->i_op = &hfsplus_dir_inode_operations;
+		inode->i_fop = &hfsplus_dir_operations;
+	} else if (type == HFSPLUS_FILE) {
+		struct hfsplus_cat_file *file = &entry.file;
+
+		if (fd->entrylength < sizeof(struct hfsplus_cat_file))
+			/* panic? */;
+		hfs_bnode_read(fd->bnode, &entry, fd->entryoffset,
+					sizeof(struct hfsplus_cat_file));
+
+		hfsplus_inode_read_fork(inode, HFSPLUS_IS_DATA(inode) ?
+					&file->data_fork : &file->rsrc_fork);
+		hfsplus_get_perms(inode, &file->permissions, 0);
+		inode->i_nlink = 1;
+		if (S_ISREG(inode->i_mode)) {
+			if (file->permissions.dev)
+				inode->i_nlink = be32_to_cpu(file->permissions.dev);
+			inode->i_op = &hfsplus_file_inode_operations;
+			inode->i_fop = &hfsplus_file_operations;
+			inode->i_mapping->a_ops = &hfsplus_aops;
+		} else if (S_ISLNK(inode->i_mode)) {
+			inode->i_op = &page_symlink_inode_operations;
+			inode->i_mapping->a_ops = &hfsplus_aops;
+		} else {
+			init_special_inode(inode, inode->i_mode,
+					   be32_to_cpu(file->permissions.dev));
+		}
+		inode->i_atime = hfsp_mt2ut(file->access_date);
+		inode->i_mtime = hfsp_mt2ut(file->content_mod_date);
+		inode->i_ctime = hfsp_mt2ut(file->attribute_mod_date);
+		HFSPLUS_I(inode).create_date = file->create_date;
+	} else {
+		printk(KERN_ERR "hfs: bad catalog entry used to create inode\n");
+		res = -EIO;
+	}
+	return res;
+}
+
+int hfsplus_cat_write_inode(hfsplus_handle_t *hfsplus_handle, struct inode *inode)
+{
+	struct inode *main_inode = inode;
+	struct hfs_find_data fd;
+	hfsplus_cat_entry entry;
+
+	if (HFSPLUS_IS_RSRC(inode))
+		main_inode = HFSPLUS_I(inode).rsrc_inode;
+
+	if (!main_inode->i_nlink)
+		return 0;
+
+	if (hfsplus_handle->journaled != HFSPLUS_JOURNAL_PRESENT) {
+		if (hfs_find_init(HFSPLUS_SB(main_inode->i_sb).cat_tree, &fd))
+			/* panic? */
+			return -EIO;
+	} else {
+		if (hfsplus_journalled_find_init(HFSPLUS_SB(main_inode->i_sb).cat_tree, &fd))
+			/* panic? */
+			return -EIO;
+	}
+
+	if (hfsplus_find_cat(hfsplus_handle, main_inode->i_sb, main_inode->i_ino, &fd))
+		/* panic? */
+		goto out;
+
+	if (S_ISDIR(main_inode->i_mode)) {
+		struct hfsplus_cat_folder *folder = &entry.folder;
+
+		if (fd.entrylength < sizeof(struct hfsplus_cat_folder))
+			/* panic? */;
+		hfs_bnode_read(fd.bnode, &entry, fd.entryoffset,
+					sizeof(struct hfsplus_cat_folder));
+		/* simple node checks? */
+		hfsplus_set_perms(inode, &folder->permissions);
+		folder->access_date = hfsp_ut2mt(inode->i_atime);
+		folder->content_mod_date = hfsp_ut2mt(inode->i_mtime);
+		folder->attribute_mod_date = hfsp_ut2mt(inode->i_ctime);
+		folder->valence = cpu_to_be32(inode->i_size - 2);
+		hfs_bnode_write(hfsplus_handle, fd.bnode, &entry, fd.entryoffset,
+					 sizeof(struct hfsplus_cat_folder));
+	} else if (HFSPLUS_IS_RSRC(inode)) {
+		struct hfsplus_cat_file *file = &entry.file;
+		hfs_bnode_read(fd.bnode, &entry, fd.entryoffset,
+			       sizeof(struct hfsplus_cat_file));
+		hfsplus_inode_write_fork(inode, &file->rsrc_fork);
+		hfs_bnode_write(hfsplus_handle, fd.bnode, &entry, fd.entryoffset,
+				sizeof(struct hfsplus_cat_file));
+	} else {
+		struct hfsplus_cat_file *file = &entry.file;
+
+		if (fd.entrylength < sizeof(struct hfsplus_cat_file))
+			/* panic? */;
+		hfs_bnode_read(fd.bnode, &entry, fd.entryoffset,
+					sizeof(struct hfsplus_cat_file));
+		hfsplus_inode_write_fork(inode, &file->data_fork);
+		if (S_ISREG(inode->i_mode))
+			HFSPLUS_I(inode).dev = inode->i_nlink;
+		if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
+			HFSPLUS_I(inode).dev = kdev_t_to_nr(inode->i_rdev);
+		hfsplus_set_perms(inode, &file->permissions);
+		if ((file->permissions.rootflags | file->permissions.userflags) & HFSPLUS_FLG_IMMUTABLE)
+			file->flags |= cpu_to_be16(HFSPLUS_FILE_LOCKED);
+		else
+			file->flags &= cpu_to_be16(~HFSPLUS_FILE_LOCKED);
+		file->access_date = hfsp_ut2mt(inode->i_atime);
+		file->content_mod_date = hfsp_ut2mt(inode->i_mtime);
+		file->attribute_mod_date = hfsp_ut2mt(inode->i_ctime);
+		hfs_bnode_write(hfsplus_handle, fd.bnode, &entry, fd.entryoffset,
+					 sizeof(struct hfsplus_cat_file));
+	}
+out:
+	if (hfsplus_handle->journaled != HFSPLUS_JOURNAL_PRESENT) {
+		hfs_find_exit(hfsplus_handle, &fd);
+	} else {
+		hfsplus_journalled_find_exit(hfsplus_handle, &fd);
+	}
+	return 0;
+}
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/ioctl.c linux-2.6.32/fs/hfsplus_journal/ioctl.c
--- linux-2.6.32-old//fs/hfsplus_journal/ioctl.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/ioctl.c	2011-11-17 09:00:40.778818402 -0500
@@ -0,0 +1,222 @@
+/*
+ *  linux/fs/hfsplus/ioctl.c
+ *
+ * Copyright (C) 2003
+ * Ethan Benson <erbenson@alaska.net>
+ * partially derived from linux/fs/ext2/ioctl.c
+ * Copyright (C) 1993, 1994, 1995
+ * Remy Card (card@masi.ibp.fr)
+ * Laboratoire MASI - Institut Blaise Pascal
+ * Universite Pierre et Marie Curie (Paris VI)
+ *
+ * hfsplus ioctls
+ */
+
+#include <linux/capability.h>
+#include <linux/fs.h>
+#include <linux/mount.h>
+#include <linux/sched.h>
+#include <linux/xattr.h>
+#include <asm/uaccess.h>
+#include "hfsplus_fs.h"
+
+int hfsplus_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+		  unsigned long arg)
+{
+	unsigned int flags;
+	hfsplus_handle_t hfsplus_handle;
+	int ret;
+
+	switch (cmd) {
+	case HFSPLUS_IOC_EXT2_GETFLAGS:
+		flags = 0;
+		if (HFSPLUS_I(inode).rootflags & HFSPLUS_FLG_IMMUTABLE)
+			flags |= FS_IMMUTABLE_FL; /* EXT2_IMMUTABLE_FL */
+		if (HFSPLUS_I(inode).rootflags & HFSPLUS_FLG_APPEND)
+			flags |= FS_APPEND_FL; /* EXT2_APPEND_FL */
+		if (HFSPLUS_I(inode).userflags & HFSPLUS_FLG_NODUMP)
+			flags |= FS_NODUMP_FL; /* EXT2_NODUMP_FL */
+		return put_user(flags, (int __user *)arg);
+	case HFSPLUS_IOC_EXT2_SETFLAGS: {
+		int err = 0;
+		err = mnt_want_write(filp->f_path.mnt);
+		if (err)
+			return err;
+
+		if (!is_owner_or_cap(inode)) {
+			err = -EACCES;
+			goto setflags_out;
+		}
+		if (get_user(flags, (int __user *)arg)) {
+			err = -EFAULT;
+			goto setflags_out;
+		}
+		if (flags & (FS_IMMUTABLE_FL|FS_APPEND_FL) ||
+		    HFSPLUS_I(inode).rootflags & (HFSPLUS_FLG_IMMUTABLE|HFSPLUS_FLG_APPEND)) {
+			if (!capable(CAP_LINUX_IMMUTABLE)) {
+				err = -EPERM;
+				goto setflags_out;
+			}
+		}
+
+		/* don't silently ignore unsupported ext2 flags */
+		if (flags & ~(FS_IMMUTABLE_FL|FS_APPEND_FL|FS_NODUMP_FL)) {
+			err = -EOPNOTSUPP;
+			goto setflags_out;
+		}
+		if (flags & FS_IMMUTABLE_FL) { /* EXT2_IMMUTABLE_FL */
+			inode->i_flags |= S_IMMUTABLE;
+			HFSPLUS_I(inode).rootflags |= HFSPLUS_FLG_IMMUTABLE;
+		} else {
+			inode->i_flags &= ~S_IMMUTABLE;
+			HFSPLUS_I(inode).rootflags &= ~HFSPLUS_FLG_IMMUTABLE;
+		}
+		if (flags & FS_APPEND_FL) { /* EXT2_APPEND_FL */
+			inode->i_flags |= S_APPEND;
+			HFSPLUS_I(inode).rootflags |= HFSPLUS_FLG_APPEND;
+		} else {
+			inode->i_flags &= ~S_APPEND;
+			HFSPLUS_I(inode).rootflags &= ~HFSPLUS_FLG_APPEND;
+		}
+		if (flags & FS_NODUMP_FL) /* EXT2_NODUMP_FL */
+			HFSPLUS_I(inode).userflags |= HFSPLUS_FLG_NODUMP;
+		else
+			HFSPLUS_I(inode).userflags &= ~HFSPLUS_FLG_NODUMP;
+
+		inode->i_ctime = CURRENT_TIME_SEC;
+		if ((ret = hfsplus_journal_start(__FUNCTION__, inode->i_sb, &hfsplus_handle)))
+			return ret;
+
+		ret = hfsplus_journalled_mark_inode_dirty(__FUNCTION__, &hfsplus_handle, inode);
+		hfsplus_journal_stop(&hfsplus_handle);
+		return ret;
+setflags_out:
+		mnt_drop_write(filp->f_path.mnt);
+		return err;
+	}
+	default:
+		return -ENOTTY;
+	}
+}
+
+int hfsplus_setxattr(struct dentry *dentry, const char *name,
+		     const void *value, size_t size, int flags)
+{
+	struct inode *inode = dentry->d_inode;
+	struct hfs_find_data fd;
+	hfsplus_cat_entry entry;
+	struct hfsplus_cat_file *file;
+	hfsplus_handle_t hfsplus_handle;
+	int res;
+
+	if (!S_ISREG(inode->i_mode) || HFSPLUS_IS_RSRC(inode))
+		return -EOPNOTSUPP;
+
+	res = hfs_find_init(HFSPLUS_SB(inode->i_sb).cat_tree, &fd);
+	if (res)
+		return res;
+
+	if ((res = hfsplus_journal_start(__FUNCTION__, inode->i_sb, &hfsplus_handle)))
+		return res;
+
+	res = hfsplus_find_cat(&hfsplus_handle, inode->i_sb, inode->i_ino, &fd);
+	if (res)
+		goto out;
+	hfs_bnode_read(fd.bnode, &entry, fd.entryoffset,
+			sizeof(struct hfsplus_cat_file));
+	file = &entry.file;
+
+	if (!strcmp(name, "hfs.type")) {
+		if (size == 4)
+			memcpy(&file->user_info.fdType, value, 4);
+		else
+			res = -ERANGE;
+	} else if (!strcmp(name, "hfs.creator")) {
+		if (size == 4)
+			memcpy(&file->user_info.fdCreator, value, 4);
+		else
+			res = -ERANGE;
+	} else
+		res = -EOPNOTSUPP;
+	if (!res)
+		hfs_bnode_write(&hfsplus_handle, fd.bnode, &entry, fd.entryoffset,
+				sizeof(struct hfsplus_cat_file));
+out:
+	hfs_find_exit(&hfsplus_handle, &fd);
+	hfsplus_journal_stop(&hfsplus_handle);
+	return res;
+}
+
+ssize_t hfsplus_getxattr(struct dentry *dentry, const char *name,
+			 void *value, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	struct hfs_find_data fd;
+	hfsplus_cat_entry entry;
+	struct hfsplus_cat_file *file;
+	hfsplus_handle_t hfsplus_handle;
+	ssize_t res = 0;
+	int ret;
+
+	if (!S_ISREG(inode->i_mode) || HFSPLUS_IS_RSRC(inode))
+		return -EOPNOTSUPP;
+
+	if (size) {
+		res = hfs_find_init(HFSPLUS_SB(inode->i_sb).cat_tree, &fd);
+		if (res)
+			return res;
+
+		if ((ret = hfsplus_journal_start(__FUNCTION__, inode->i_sb, &hfsplus_handle)))
+			return ret;
+
+		res = hfsplus_find_cat(&hfsplus_handle, inode->i_sb, inode->i_ino, &fd);
+		if (res)
+			goto out;
+		hfs_bnode_read(fd.bnode, &entry, fd.entryoffset,
+				sizeof(struct hfsplus_cat_file));
+	}
+	else {
+		if ((ret = hfsplus_journal_start(__FUNCTION__, inode->i_sb, &hfsplus_handle)))
+			return ret;
+	}
+	file = &entry.file;
+
+	if (!strcmp(name, "hfs.type")) {
+		if (size >= 4) {
+			memcpy(value, &file->user_info.fdType, 4);
+			res = 4;
+		} else
+			res = size ? -ERANGE : 4;
+	} else if (!strcmp(name, "hfs.creator")) {
+		if (size >= 4) {
+			memcpy(value, &file->user_info.fdCreator, 4);
+			res = 4;
+		} else
+			res = size ? -ERANGE : 4;
+	} else
+		res = -ENODATA;
+out:
+	if (size)
+		hfs_find_exit(&hfsplus_handle, &fd);
+	hfsplus_journal_stop(&hfsplus_handle);
+	return res;
+}
+
+#define HFSPLUS_ATTRLIST_SIZE (sizeof("hfs.creator")+sizeof("hfs.type"))
+
+ssize_t hfsplus_listxattr(struct dentry *dentry, char *buffer, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+
+	if (!S_ISREG(inode->i_mode) || HFSPLUS_IS_RSRC(inode))
+		return -EOPNOTSUPP;
+
+	if (!buffer || !size)
+		return HFSPLUS_ATTRLIST_SIZE;
+	if (size < HFSPLUS_ATTRLIST_SIZE)
+		return -ERANGE;
+	strcpy(buffer, "hfs.type");
+	strcpy(buffer + sizeof("hfs.type"), "hfs.creator");
+
+	return HFSPLUS_ATTRLIST_SIZE;
+}
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/jbd_journal.c linux-2.6.32/fs/hfsplus_journal/jbd_journal.c
--- linux-2.6.32-old//fs/hfsplus_journal/jbd_journal.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/jbd_journal.c	2011-11-17 09:00:40.788818402 -0500
@@ -0,0 +1,2047 @@
+/*
+ * linux/fs/journal.c
+ *
+ * Written by Stephen C. Tweedie <sct@redhat.com>, 1998
+ *
+ * Copyright 1998 Red Hat corp --- All Rights Reserved
+ *
+ * This file is part of the Linux kernel and is made available under
+ * the terms of the GNU General Public License, version 2, or at your
+ * option, any later version, incorporated herein by reference.
+ *
+ * Generic filesystem journal-writing code; part of the ext2fs
+ * journaling system.
+ *
+ * This file manages journals: areas of disk reserved for logging
+ * transactional updates.  This includes the kernel journaling thread
+ * which is responsible for scheduling updates to the log.
+ *
+ * We do not actually manage the physical storage of the journal in this
+ * file: that is left to a per-journal policy function, which allows us
+ * to store the journal within a filesystem-specified area for ext2
+ * journaling (ext2 can use a reserved inode for storing the log).
+ */
+
+#include <linux/module.h>
+#include <linux/time.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/suspend.h>
+#include <linux/freezer.h>
+#include <linux/pagemap.h>
+#include <linux/kthread.h>
+#include <linux/poison.h>
+#include <linux/proc_fs.h>
+#include <linux/debugfs.h>
+#include <asm/uaccess.h>
+#include <asm/page.h>
+#include <linux/proc_fs.h>
+#include "hfsplus_jbd.h"
+#include "hfsplus_fs.h"
+
+EXPORT_SYMBOL(hfsplus_jbd_start);
+EXPORT_SYMBOL(hfsplus_jbd_restart);
+EXPORT_SYMBOL(hfsplus_jbd_extend);
+EXPORT_SYMBOL(hfsplus_jbd_stop);
+EXPORT_SYMBOL(hfsplus_jbd_lock_updates);
+EXPORT_SYMBOL(hfsplus_jbd_unlock_updates);
+EXPORT_SYMBOL(hfsplus_jbd_get_write_access);
+EXPORT_SYMBOL(hfsplus_jbd_get_create_access);
+EXPORT_SYMBOL(hfsplus_jbd_get_undo_access);
+EXPORT_SYMBOL(hfsplus_jbd_dirty_data);
+EXPORT_SYMBOL(hfsplus_jbd_dirty_metadata);
+EXPORT_SYMBOL(hfsplus_jbd_release_buffer);
+EXPORT_SYMBOL(hfsplus_jbd_forget);
+#if 0
+EXPORT_SYMBOL(hfsplus_jbd_sync_buffer);
+#endif
+EXPORT_SYMBOL(hfsplus_jbd_flush);
+EXPORT_SYMBOL(hfsplus_jbd_revoke);
+
+EXPORT_SYMBOL(hfsplus_jbd_init_dev);
+EXPORT_SYMBOL(hfsplus_jbd_init_inode);
+EXPORT_SYMBOL(hfsplus_jbd_update_format);
+EXPORT_SYMBOL(hfsplus_jbd_check_used_features);
+EXPORT_SYMBOL(hfsplus_jbd_check_available_features);
+EXPORT_SYMBOL(hfsplus_jbd_set_features);
+EXPORT_SYMBOL(hfsplus_jbd_create);
+EXPORT_SYMBOL(hfsplus_jbd_load);
+EXPORT_SYMBOL(hfsplus_jbd_destroy);
+EXPORT_SYMBOL(hfsplus_jbd_update_superblock);
+EXPORT_SYMBOL(hfsplus_jbd_abort);
+EXPORT_SYMBOL(hfsplus_jbd_errno);
+EXPORT_SYMBOL(hfsplus_jbd_ack_err);
+EXPORT_SYMBOL(hfsplus_jbd_clear_err);
+EXPORT_SYMBOL(hfsplus_jbd_log_wait_commit);
+EXPORT_SYMBOL(hfsplus_jbd_start_commit);
+EXPORT_SYMBOL(hfsplus_jbd_force_commit_nested);
+EXPORT_SYMBOL(hfsplus_jbd_wipe);
+EXPORT_SYMBOL(hfsplus_jbd_blocks_per_page);
+EXPORT_SYMBOL(hfsplus_jbd_invalidatepage);
+EXPORT_SYMBOL(hfsplus_jbd_try_to_free_buffers);
+EXPORT_SYMBOL(hfsplus_jbd_force_commit);
+
+static int hfsplus_jbd_convert_superblock_v1(hfsplus_jbd_t *, hfsplus_jbd_superblock_t *);
+static void __hfsplus_jbd_abort_soft (hfsplus_jbd_t *journal, int errno);
+
+/*
+ * Helper function used to manage commit timeouts
+ */
+
+static void commit_timeout(unsigned long __data)
+{
+	struct task_struct * p = (struct task_struct *) __data;
+
+	wake_up_process(p);
+}
+
+/*
+ * hfsplus_kjournald: The main thread function used to manage a logging device
+ * journal.
+ *
+ * This kernel thread is responsible for two things:
+ *
+ * 1) COMMIT:  Every so often we need to commit the current state of the
+ *    filesystem to disk.  The journal thread is responsible for writing
+ *    all of the metadata buffers to disk.
+ *
+ * 2) CHECKPOINT: We cannot reuse a used section of the log file until all
+ *    of the data in that part of the log has been rewritten elsewhere on
+ *    the disk.  Flushing these old buffers to reclaim space in the log is
+ *    known as checkpointing, and this thread is responsible for that job.
+ */
+
+static int hfsplus_kjournald(void *arg)
+{
+	hfsplus_jbd_t *journal = (hfsplus_jbd_t *) arg;
+	hfsplus_transaction_t *transaction;
+
+	//daemonize("hfsplus_kjournald");
+
+	/* Set up an interval timer which can be used to trigger a
+           commit wakeup after the commit interval expires */
+	setup_timer(&journal->j_commit_timer, commit_timeout,(unsigned long)current);
+
+	/* Record that the journal thread is running */
+	journal->j_task = current;
+	wake_up(&journal->j_wait_done_commit);
+
+	printk(KERN_INFO "hfsplus_kjournald starting.  Commit interval %ld seconds\n",
+			journal->j_commit_interval / HZ);
+
+	/*
+	 * And now, wait forever for commit wakeup events.
+	 */
+	spin_lock(&journal->j_state_lock);
+
+loop:
+	if (journal->j_flags & JFS_UNMOUNT)
+		goto end_loop;
+
+	hfsplus_jbd_debug(1, "commit_sequence=%d, commit_request=%d\n",
+		journal->j_commit_sequence, journal->j_commit_request);
+
+	if (journal->j_commit_sequence != journal->j_commit_request) {
+		hfsplus_jbd_debug(1, "OK, requests differ\n");
+		spin_unlock(&journal->j_state_lock);
+		del_timer_sync(&journal->j_commit_timer);
+		hfsplus_jbd_commit_transaction(journal);
+		spin_lock(&journal->j_state_lock);
+		goto loop;
+	}
+
+	wake_up(&journal->j_wait_done_commit);
+	if (freezing(current)) {
+		/*
+		 * The simpler the better. Flushing journal isn't a
+		 * good idea, because that depends on threads that may
+		 * be already stopped.
+		 */
+		hfsplus_jbd_debug(1, "Now suspending hfsplus_kjournald\n");
+		spin_unlock(&journal->j_state_lock);
+		refrigerator();
+		spin_lock(&journal->j_state_lock);
+	} else {
+		/*
+		 * We assume on resume that commits are already there,
+		 * so we don't sleep
+		 */
+		DEFINE_WAIT(wait);
+		int should_sleep = 1;
+
+		prepare_to_wait(&journal->j_wait_commit, &wait,
+				TASK_INTERRUPTIBLE);
+		if (journal->j_commit_sequence != journal->j_commit_request)
+			should_sleep = 0;
+		transaction = journal->j_running_transaction;
+		if (transaction && time_after_eq(jiffies,
+						transaction->t_expires))
+			should_sleep = 0;
+		if (journal->j_flags & JFS_UNMOUNT)
+ 			should_sleep = 0;
+		if (should_sleep) {
+			spin_unlock(&journal->j_state_lock);
+			schedule();
+			spin_lock(&journal->j_state_lock);
+		}
+		finish_wait(&journal->j_wait_commit, &wait);
+	}
+
+	hfsplus_jbd_debug(1, "hfsplus_kjournald wakes\n");
+
+	/*
+	 * Were we woken up by a commit wakeup event?
+	 */
+	transaction = journal->j_running_transaction;
+	if (transaction && time_after_eq(jiffies, transaction->t_expires)) {
+		journal->j_commit_request = transaction->t_tid;
+		hfsplus_jbd_debug(1, "woke because of timeout\n");
+	}
+	goto loop;
+
+end_loop:
+	spin_unlock(&journal->j_state_lock);
+	del_timer_sync(&journal->j_commit_timer);
+	journal->j_task = NULL;
+	wake_up(&journal->j_wait_done_commit);
+	hfsplus_jbd_debug(1, "Journal thread exiting.\n");
+	return 0;
+}
+
+static int hfsplus_jbd_start_thread(hfsplus_jbd_t *journal)
+{
+	struct task_struct *t;
+
+	t = kthread_run(hfsplus_kjournald, journal, "kjournald");
+	if (IS_ERR(t))
+		return PTR_ERR(t);
+
+	wait_event(journal->j_wait_done_commit, journal->j_task != NULL);
+	return 0;
+	//kernel_thread(hfsplus_kjournald, journal, CLONE_VM|CLONE_FS|CLONE_FILES);
+	//wait_event(journal->j_wait_done_commit, journal->j_task != NULL);
+}
+
+static void hfsplus_jbd_kill_thread(hfsplus_jbd_t *journal)
+{
+	spin_lock(&journal->j_state_lock);
+	journal->j_flags |= JFS_UNMOUNT;
+
+	while (journal->j_task) {
+		wake_up(&journal->j_wait_commit);
+		spin_unlock(&journal->j_state_lock);
+		wait_event(journal->j_wait_done_commit, journal->j_task == NULL);
+		spin_lock(&journal->j_state_lock);
+	}
+	spin_unlock(&journal->j_state_lock);
+}
+
+/*
+ * hfsplus_jbd_write_metadata_buffer: write a metadata buffer to the journal.
+ *
+ * Writes a metadata buffer to a given disk block.  The actual IO is not
+ * performed but a new buffer_head is constructed which labels the data
+ * to be written with the correct destination disk block.
+ *
+ * Any magic-number escaping which needs to be done will cause a
+ * copy-out here.  If the buffer happens to start with the
+ * JFS_MAGIC_NUMBER, then we can't write it to the log directly: the
+ * magic number is only written to the log for descripter blocks.  In
+ * this case, we copy the data and replace the first word with 0, and we
+ * return a result code which indicates that this buffer needs to be
+ * marked as an escaped buffer in the corresponding log descriptor
+ * block.  The missing word can then be restored when the block is read
+ * during recovery.
+ *
+ * If the source buffer has already been modified by a new transaction
+ * since we took the last commit snapshot, we use the frozen copy of
+ * that data for IO.  If we end up using the existing buffer_head's data
+ * for the write, then we *have* to lock the buffer to prevent anyone
+ * else from using and possibly modifying it while the IO is in
+ * progress.
+ *
+ * The function returns a pointer to the buffer_heads to be used for IO.
+ *
+ * We assume that the journal has already been locked in this function.
+ *
+ * Return value:
+ *  <0: Error
+ * >=0: Finished OK
+ *
+ * On success:
+ * Bit 0 set == escape performed on the data
+ * Bit 1 set == buffer copy-out performed (kfree the data after IO)
+ */
+
+int hfsplus_jbd_write_metadata_buffer(hfsplus_transaction_t *transaction,
+				  struct hfsplus_jbd_head  *jh_in,
+				  struct hfsplus_jbd_head **jh_out,
+				  unsigned int blocknr)
+{
+	int need_copy_out = 0;
+	int done_copy_out = 0;
+	int do_escape = 0;
+	char *mapped_data;
+	struct buffer_head *new_bh;
+	struct hfsplus_jbd_head *new_jh;
+	struct page *new_page;
+	unsigned int new_offset;
+	struct buffer_head *bh_in = hfsplus_jh2bh(jh_in);
+	hfsplus_jbd_t *journal = transaction->t_journal;
+
+	/*
+	 * The buffer really shouldn't be locked: only the current committing
+	 * transaction is allowed to write it, so nobody else is allowed
+	 * to do any IO.
+	 *
+	 * akpm: except if we're journalling data, and write() output is
+	 * also part of a shared mapping, and another thread has
+	 * decided to launch a writepage() against this buffer.
+	 */
+	HFSPLUS_J_ASSERT_BH(bh_in, buffer_hfsplus_jbddirty(bh_in));
+
+	new_bh = alloc_buffer_head(GFP_NOFS|__GFP_NOFAIL);
+	/* keep subsequent assertions sane */
+	new_bh->b_state = 0;
+	init_buffer(new_bh, NULL, NULL);
+	atomic_set(&new_bh->b_count, 1);
+	new_jh = hfsplus_jbd_add_journal_head(new_bh);  /* This sleeps */
+
+	/*
+	 * If a new transaction has already done a buffer copy-out, then
+	 * we use that version of the data for the commit.
+	 */
+	hfsplus_jbd_lock_bh_state(bh_in);
+repeat:
+	if (jh_in->b_frozen_data) {
+		done_copy_out = 1;
+		new_page = virt_to_page(jh_in->b_frozen_data);
+		new_offset = offset_in_page(jh_in->b_frozen_data);
+	} else {
+		new_page = hfsplus_jh2bh(jh_in)->b_page;
+		new_offset = offset_in_page(hfsplus_jh2bh(jh_in)->b_data);
+	}
+
+	mapped_data = kmap_atomic(new_page, KM_USER0);
+	/*
+	 * Check for escaping
+	 */
+	if (*((__be32 *)(mapped_data + new_offset)) ==
+				cpu_to_be32(JFS_MAGIC_NUMBER)) {
+//printk("@@@@@@@ Oops! .. Need to check it function: %s, Line: %d\n", __FUNCTION__, __LINE__);
+		need_copy_out = 1;
+		do_escape = 1;
+	}
+	kunmap_atomic(mapped_data, KM_USER0);
+
+	/*
+	 * Do we need to do a data copy?
+	 */
+	if (need_copy_out && !done_copy_out) {
+		char *tmp;
+
+		hfsplus_jbd_unlock_bh_state(bh_in);
+		tmp = hfsplus_jbd_alloc(bh_in->b_size, GFP_NOFS);
+		hfsplus_jbd_lock_bh_state(bh_in);
+		if (jh_in->b_frozen_data) {
+			hfsplus_jbd_free(tmp, bh_in->b_size);
+			goto repeat;
+		}
+
+		jh_in->b_frozen_data = tmp;
+		mapped_data = kmap_atomic(new_page, KM_USER0);
+		memcpy(tmp, mapped_data + new_offset, hfsplus_jh2bh(jh_in)->b_size);
+		kunmap_atomic(mapped_data, KM_USER0);
+
+		new_page = virt_to_page(tmp);
+		new_offset = offset_in_page(tmp);
+		done_copy_out = 1;
+	}
+
+	/*
+	 * Did we need to do an escaping?  Now we've done all the
+	 * copying, we can finally do so.
+	 */
+	if (do_escape) {
+		mapped_data = kmap_atomic(new_page, KM_USER0);
+		*((unsigned int *)(mapped_data + new_offset)) = 0;
+		kunmap_atomic(mapped_data, KM_USER0);
+	}
+
+	//new_bh->b_state = 0;
+	//init_buffer(new_bh, NULL, NULL);
+	//atomic_set(&new_bh->b_count, 1);
+	//hfsplus_jbd_unlock_bh_state(bh_in);
+
+	//new_jh = hfsplus_jbd_add_journal_head(new_bh);	/* This sleeps */
+
+	set_bh_page(new_bh, new_page, new_offset);
+	new_jh->b_transaction = NULL;
+	new_bh->b_size = hfsplus_jh2bh(jh_in)->b_size;
+	new_bh->b_bdev = transaction->t_journal->j_dev;
+	new_bh->b_blocknr = blocknr;
+	set_buffer_mapped(new_bh);
+	set_buffer_dirty(new_bh);
+
+	*jh_out = new_jh;
+
+	/*
+	 * The to-be-written buffer needs to get moved to the io queue,
+	 * and the original buffer whose contents we are shadowing or
+	 * copying is moved to the transaction's shadow queue.
+	 */
+	HFSPLUS_JBUFFER_TRACE(jh_in, "file as HFSPLUS_BJ_Shadow");
+	spin_lock(&journal->j_list_lock);
+	__hfsplus_jbd_file_buffer(jh_in, transaction, HFSPLUS_BJ_Shadow);
+	spin_unlock(&journal->j_list_lock);
+	hfsplus_jbd_unlock_bh_state(bh_in);
+
+	HFSPLUS_JBUFFER_TRACE(new_jh, "file as HFSPLUS_BJ_IO");
+	hfsplus_jbd_file_buffer(new_jh, transaction, HFSPLUS_BJ_IO);
+
+	return do_escape | (done_copy_out << 1);
+}
+
+/*
+ * Allocation code for the journal file.  Manage the space left in the
+ * journal, so that we can begin checkpointing when appropriate.
+ */
+
+/*
+ * __hfsplus__log_space_left: Return the number of free blocks left in the journal.
+ *
+ * Called with the journal already locked.
+ *
+ * Called under j_state_lock
+ */
+
+int __hfsplus__log_space_left(hfsplus_jbd_t *journal)
+{
+	int left = journal->j_free;
+
+	assert_spin_locked(&journal->j_state_lock);
+
+	/*
+	 * Be pessimistic here about the number of those free blocks which
+	 * might be required for log descriptor control blocks.
+	 */
+
+#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */
+
+	left -= MIN_LOG_RESERVED_BLOCKS;
+
+	if (left <= 0)
+		return 0;
+	left -= (left >> 3);
+	return left;
+}
+
+/*
+ * Called under j_state_lock.  Returns true if a transaction was started.
+ */
+int __hfsplus__log_start_commit(hfsplus_jbd_t *journal, hfsplus_jbd_tid_t target)
+{
+	/*
+	 * Are we already doing a recent enough commit?
+	 */
+	if (!hfsplus_tid_geq(journal->j_commit_request, target)) {
+		/*
+		 * We want a new commit: OK, mark the request and wakup the
+		 * commit thread.  We do _not_ do the commit ourselves.
+		 */
+
+		journal->j_commit_request = target;
+		hfsplus_jbd_debug(1, "JBD: requesting commit %d/%d\n",
+			  journal->j_commit_request,
+			  journal->j_commit_sequence);
+		wake_up(&journal->j_wait_commit);
+		return 1;
+	}
+	return 0;
+}
+
+int hfsplus_log_start_commit(hfsplus_jbd_t *journal, hfsplus_jbd_tid_t tid)
+{
+	int ret;
+
+	spin_lock(&journal->j_state_lock);
+	ret = __hfsplus__log_start_commit(journal, tid);
+	spin_unlock(&journal->j_state_lock);
+	return ret;
+}
+
+/*
+ * Force and wait upon a commit if the calling process is not within
+ * transaction.  This is used for forcing out undo-protected data which contains
+ * bitmaps, when the fs is running out of space.
+ *
+ * We can only force the running transaction if we don't have an active handle;
+ * otherwise, we will deadlock.
+ *
+ * Returns true if a transaction was started.
+ */
+int hfsplus_jbd_force_commit_nested(hfsplus_jbd_t *journal)
+{
+	hfsplus_transaction_t *transaction = NULL;
+	hfsplus_jbd_tid_t tid;
+
+	spin_lock(&journal->j_state_lock);
+	if (journal->j_running_transaction && !current->journal_info) {
+		transaction = journal->j_running_transaction;
+		__hfsplus__log_start_commit(journal, transaction->t_tid);
+	} else if (journal->j_committing_transaction)
+		transaction = journal->j_committing_transaction;
+
+	if (!transaction) {
+		spin_unlock(&journal->j_state_lock);
+		return 0;	/* Nothing to retry */
+	}
+
+	tid = transaction->t_tid;
+	spin_unlock(&journal->j_state_lock);
+	hfsplus_jbd_log_wait_commit(journal, tid);
+	return 1;
+}
+
+/*
+ * Start a commit of the current running transaction (if any).  Returns true
+ * if a transaction was started, and fills its tid in at *ptid
+ */
+int hfsplus_jbd_start_commit(hfsplus_jbd_t *journal, hfsplus_jbd_tid_t *ptid)
+{
+	int ret = 0;
+
+	spin_lock(&journal->j_state_lock);
+	if (journal->j_running_transaction) {
+		hfsplus_jbd_tid_t tid = journal->j_running_transaction->t_tid;
+
+		ret = __hfsplus__log_start_commit(journal, tid);
+		if (ret && ptid)
+			*ptid = tid;
+	} else if (journal->j_committing_transaction && ptid) {
+		/*
+		 * If hfsplus_write_super() recently started a commit, then we
+		 * have to wait for completion of that transaction
+		 */
+		*ptid = journal->j_committing_transaction->t_tid;
+		ret = 1;
+	}
+	spin_unlock(&journal->j_state_lock);
+	return ret;
+}
+
+/*
+ * Wait for a specified commit to complete.
+ * The caller may not hold the journal lock.
+ */
+int hfsplus_jbd_log_wait_commit(hfsplus_jbd_t *journal, hfsplus_jbd_tid_t tid)
+{
+	int err = 0;
+
+#ifdef CONFIG_JBD_DEBUG
+	spin_lock(&journal->j_state_lock);
+	if (!hfsplus_tid_geq(journal->j_commit_request, tid)) {
+		printk(KERN_EMERG
+		       "%s: error: j_commit_request=%d, tid=%d\n",
+		       __func__, journal->j_commit_request, tid);
+	}
+	spin_unlock(&journal->j_state_lock);
+#endif
+	spin_lock(&journal->j_state_lock);
+	while (hfsplus_tid_gt(tid, journal->j_commit_sequence)) {
+		hfsplus_jbd_debug(1, "JBD: want %d, j_commit_sequence=%d\n",
+				  tid, journal->j_commit_sequence);
+		wake_up(&journal->j_wait_commit);
+		spin_unlock(&journal->j_state_lock);
+		wait_event(journal->j_wait_done_commit,
+				!hfsplus_tid_gt(tid, journal->j_commit_sequence));
+		spin_lock(&journal->j_state_lock);
+	}
+	spin_unlock(&journal->j_state_lock);
+
+	if (unlikely(is_hfsplus_jbd_aborted(journal))) {
+		printk(KERN_EMERG "journal commit I/O error\n");
+		err = -EIO;
+	}
+	return err;
+}
+
+/*
+ * Log buffer allocation routines:
+ */
+
+int hfsplus_jbd_next_log_block(hfsplus_jbd_t *journal, unsigned int *retp)
+{
+	unsigned int blocknr;
+
+	spin_lock(&journal->j_state_lock);
+	HFSPLUS_J_ASSERT(journal->j_free > 1);
+
+	blocknr = journal->j_head;
+	journal->j_head++;
+	journal->j_free--;
+	if (journal->j_head == journal->j_last)
+		journal->j_head = journal->j_first;
+	spin_unlock(&journal->j_state_lock);
+	return hfsplus_jbd_bmap(journal, blocknr, retp);
+}
+
+/*
+ * Conversion of logical to physical block numbers for the journal
+ *
+ * On external journals the journal blocks are identity-mapped, so
+ * this is a no-op.  If needed, we can use j_blk_offset - everything is
+ * ready.
+ */
+int hfsplus_jbd_bmap(hfsplus_jbd_t *journal, unsigned int blocknr, 
+		 unsigned int *retp)
+{
+	int err = 0;
+	unsigned int ret;
+
+	if (journal->j_inode) {
+		ret = bmap(journal->j_inode, blocknr);
+		if (ret)
+			*retp = ret;
+		else {
+			char b[BDEVNAME_SIZE];
+
+			printk(KERN_ALERT "%s: journal block not found "
+					"at offset %u on %s\n",
+				__func__,
+				blocknr,
+				bdevname(journal->j_dev, b));
+			err = -EIO;
+			__hfsplus_jbd_abort_soft(journal, err);
+		}
+	} else {
+		*retp = blocknr; /* +journal->j_blk_offset */
+	}
+	return err;
+}
+
+/*
+ * We play buffer_head aliasing tricks to write data/metadata blocks to
+ * the journal without copying their contents, but for journal
+ * descriptor blocks we do need to generate bona fide buffers.
+ *
+ * After the caller of hfsplus_jbd_get_descriptor_buffer() has finished modifying
+ * the buffer's contents they really should run flush_dcache_page(bh->b_page).
+ * But we don't bother doing that, so there will be coherency problems with
+ * mmaps of blockdevs which hold live JBD-controlled filesystems.
+ */
+struct hfsplus_jbd_head *hfsplus_jbd_get_descriptor_buffer(hfsplus_jbd_t *journal)
+{
+	struct buffer_head *bh;
+	unsigned int blocknr;
+	int err;
+
+	err = hfsplus_jbd_next_log_block(journal, &blocknr);
+
+	if (err)
+		return NULL;
+
+	bh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);
+	if(!bh)
+		return NULL;
+	lock_buffer(bh);
+	memset(bh->b_data, 0, journal->j_blocksize);
+	set_buffer_uptodate(bh);
+	unlock_buffer(bh);
+	HFSPLUS_BUFFER_TRACE(bh, "return this buffer");
+	return hfsplus_jbd_add_journal_head(bh);
+}
+
+/*
+ * Management for journal control blocks: functions to create and
+ * destroy hfsplus_jbd_t structures, and to initialise and read existing
+ * journal blocks from disk.  */
+
+/* First: create and setup a hfsplus_jbd_t object in memory.  We initialise
+ * very few fields yet: that has to wait until we have created the
+ * journal structures from from scratch, or loaded them from disk. */
+
+static hfsplus_jbd_t * hfsplus_jbd_init_common (void)
+{
+	hfsplus_jbd_t *journal;
+	int err;
+
+	journal = kzalloc(sizeof(*journal), GFP_KERNEL);
+	if (!journal)
+		goto fail;
+
+	init_waitqueue_head(&journal->j_wait_transaction_locked);
+	init_waitqueue_head(&journal->j_wait_logspace);
+	init_waitqueue_head(&journal->j_wait_done_commit);
+	init_waitqueue_head(&journal->j_wait_checkpoint);
+	init_waitqueue_head(&journal->j_wait_commit);
+	init_waitqueue_head(&journal->j_wait_updates);
+	mutex_init(&journal->j_barrier);
+	mutex_init(&journal->j_checkpoint_mutex);
+	spin_lock_init(&journal->j_revoke_lock);
+	spin_lock_init(&journal->j_list_lock);
+	spin_lock_init(&journal->j_state_lock);
+
+	journal->j_commit_interval = (HZ * HFSPLUS_JBD_DEFAULT_MAX_COMMIT_AGE);
+
+	/* The journal is marked for error until we succeed with recovery! */
+	journal->j_flags = JFS_ABORT;
+
+	/* Set up a default-sized revoke table for the new mount. */
+	err = hfsplus_jbd_init_revoke(journal, HFSPLUS_JBD_REVOKE_DEFAULT_HASH);
+	if (err) {
+		kfree(journal);
+		goto fail;
+	}
+	return journal;
+fail:
+	return NULL;
+}
+
+/* hfsplus_jbd_init_dev and hfsplus_jbd_init_inode:
+ *
+ * Create a journal structure assigned some fixed set of disk blocks to
+ * the journal.  We don't actually touch those disk blocks yet, but we
+ * need to set up all of the mapping information to tell the journaling
+ * system where the journal blocks are.
+ *
+ */
+
+/**
+ *  hfsplus_jbd_t * hfsplus_jbd_init_dev() - creates an initialises a journal structure
+ *  @bdev: Block device on which to create the journal
+ *  @fs_dev: Device which hold journalled filesystem for this journal.
+ *  @start: Block nr Start of journal.
+ *  @len:  Lenght of the journal in blocks.
+ *  @blocksize: blocksize of journalling device
+ *  @returns: a newly created hfsplus_jbd_t *
+ *  
+ *  hfsplus_jbd_init_dev creates a journal which maps a fixed contiguous
+ *  range of blocks on an arbitrary block device.
+ * 
+ */
+hfsplus_jbd_t * hfsplus_jbd_init_dev(struct block_device *bdev,
+			struct block_device *fs_dev,
+			int start, int len, int blocksize)
+{
+	hfsplus_jbd_t *journal = hfsplus_jbd_init_common();
+	struct buffer_head *bh;
+	int n;
+
+	if (!journal)
+		return NULL;
+
+	journal->j_dev = bdev;
+	journal->j_fs_dev = fs_dev;
+	journal->j_blk_offset = start;
+	journal->j_maxlen = len;
+	journal->j_blocksize = blocksize;
+
+	bh = __getblk(journal->j_dev, start, journal->j_blocksize);
+	HFSPLUS_J_ASSERT(bh != NULL);
+	journal->j_sb_buffer = bh;
+	journal->j_superblock = (hfsplus_jbd_superblock_t *)bh->b_data;
+
+	/* journal descriptor can store up to n blocks -bzzz */
+	n = (journal->j_blocksize - HFSPLUS_SECTOR_SIZE) / sizeof(hfsplus_jbd_block_tag_t);
+	journal->j_wbufsize = n;
+	journal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);
+	if (!journal->j_wbuf) {
+		printk(KERN_ERR "%s: Cant allocate bhs for commit thread\n",
+			__func__);
+		kfree(journal);
+		journal = NULL;
+	}
+
+	return journal;
+}
+ 
+/** 
+ *  hfsplus_jbd_t * hfsplus_jbd_init_inode () - creates a journal which maps to a inode.
+ *  @inode: An inode to create the journal in
+ *  
+ * hfsplus_jbd_init_inode creates a journal which maps an on-disk inode as
+ * the journal.  The inode must exist already, must support bmap() and
+ * must have all data blocks preallocated.
+ */
+hfsplus_jbd_t * hfsplus_jbd_init_inode (struct inode *inode)
+{
+	struct buffer_head *bh;
+	hfsplus_jbd_t *journal = hfsplus_jbd_init_common();
+	int err;
+	int n;
+	unsigned int blocknr;
+
+	if (!journal)
+		return NULL;
+
+	journal->j_dev = journal->j_fs_dev = inode->i_sb->s_bdev;
+	journal->j_inode = inode;
+	hfsplus_jbd_debug(1,
+		  "journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld\n",
+		  journal, inode->i_sb->s_id, inode->i_ino, 
+		  (long long) inode->i_size,
+		  inode->i_sb->s_blocksize_bits, inode->i_sb->s_blocksize);
+
+	journal->j_maxlen = inode->i_size >> inode->i_sb->s_blocksize_bits;
+	journal->j_blocksize = inode->i_sb->s_blocksize;
+
+	/* journal descriptor can store up to n blocks -bzzz */
+	n = journal->j_blocksize / sizeof(hfsplus_jbd_block_tag_t);
+	journal->j_wbufsize = n;
+	journal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);
+	if (!journal->j_wbuf) {
+		printk(KERN_ERR "%s: Cant allocate bhs for commit thread\n",
+			__func__);
+		kfree(journal);
+		return NULL;
+	}
+
+	err = hfsplus_jbd_bmap(journal, 0, &blocknr);
+	/* If that failed, give up */
+	if (err) {
+		printk(KERN_ERR "%s: Cannnot locate journal superblock\n",
+		       __func__);
+		kfree(journal);
+		return NULL;
+	}
+
+	bh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);
+	HFSPLUS_J_ASSERT(bh != NULL);
+	journal->j_sb_buffer = bh;
+	journal->j_superblock = (hfsplus_jbd_superblock_t *)bh->b_data;
+
+	return journal;
+}
+
+/* 
+ * If the journal init or create aborts, we need to mark the journal
+ * superblock as being NULL to prevent the journal destroy from writing
+ * back a bogus superblock. 
+ */
+static void hfsplus_jbd_fail_superblock (hfsplus_jbd_t *journal)
+{
+	struct buffer_head *bh = journal->j_sb_buffer;
+	brelse(bh);
+	journal->j_sb_buffer = NULL;
+}
+
+/*
+ * Given a hfsplus_jbd_t structure, initialise the various fields for
+ * startup of a new journaling session.  We use this both when creating
+ * a journal, and after recovering an old journal to reset it for
+ * subsequent use.
+ */
+
+static int hfsplus_jbd_reset(hfsplus_jbd_t *journal)
+{
+	hfsplus_jbd_superblock_t *sb = journal->j_superblock;
+	unsigned int first, last;
+
+	first = be32_to_cpu(sb->s_first);
+	last = be32_to_cpu(sb->s_maxlen);
+
+	if (first + JFS_MIN_JOURNAL_BLOCKS > last + 1) {
+		printk(KERN_ERR "JBD: Journal too short (blocks %u-%u).\n",
+				first, last);
+		hfsplus_jbd_fail_superblock(journal);
+		return -EINVAL;
+	}
+	journal->j_first = first;
+	journal->j_last = last;
+
+	journal->j_head = first;
+	journal->j_tail = first;
+	journal->j_free = last - first;
+
+	journal->j_tail_sequence = journal->j_transaction_sequence;
+	journal->j_commit_sequence = journal->j_transaction_sequence - 1;
+	journal->j_commit_request = journal->j_commit_sequence;
+
+	journal->j_max_transaction_buffers = journal->j_maxlen / 4;
+
+	/* Add the dynamic fields and write it to disk. */
+	hfsplus_jbd_update_superblock(journal, 1);
+	return hfsplus_jbd_start_thread(journal);
+}
+
+/** 
+ * int hfsplus_jbd_create() - Initialise the new journal file
+ * @journal: Journal to create. This structure must have been initialised
+ * 
+ * Given a hfsplus_jbd_t structure which tells us which disk blocks we can
+ * use, create a new journal superblock and initialise all of the
+ * journal fields from scratch.  
+ **/
+int hfsplus_jbd_create(hfsplus_jbd_t *journal)
+{
+	unsigned int blocknr;
+	struct buffer_head *bh;
+	hfsplus_jbd_superblock_t *sb;
+	int i, err;
+
+	if (journal->j_maxlen < JFS_MIN_JOURNAL_BLOCKS) {
+		printk (KERN_ERR "Journal length (%d blocks) too short.\n",
+			journal->j_maxlen);
+		hfsplus_jbd_fail_superblock(journal);
+		return -EINVAL;
+	}
+
+	if (journal->j_inode == NULL) {
+		/*
+		 * We don't know what block to start at!
+		 */
+		printk(KERN_EMERG
+		       "%s: creation of journal on external device!\n",
+		       __func__);
+		BUG();
+	}
+
+	/* Zero out the entire journal on disk.  We cannot afford to
+	   have any blocks on disk beginning with JFS_MAGIC_NUMBER. */
+	hfsplus_jbd_debug(1, "JBD: Zeroing out journal blocks...\n");
+	for (i = 0; i < journal->j_maxlen; i++) {
+		err = hfsplus_jbd_bmap(journal, i, &blocknr);
+		if (err)
+			return err;
+		bh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);
+		lock_buffer(bh);
+		memset (bh->b_data, 0, journal->j_blocksize);
+		HFSPLUS_BUFFER_TRACE(bh, "marking dirty");
+		mark_buffer_dirty(bh);
+		HFSPLUS_BUFFER_TRACE(bh, "marking uptodate");
+		set_buffer_uptodate(bh);
+		unlock_buffer(bh);
+		__brelse(bh);
+	}
+
+	sync_blockdev(journal->j_dev);
+	hfsplus_jbd_debug(1, "JBD: journal cleared.\n");
+
+	/* OK, fill in the initial static fields in the new superblock */
+	sb = journal->j_superblock;
+
+	sb->s_header.h_magic	 = cpu_to_be32(JFS_MAGIC_NUMBER);
+	sb->s_header.h_blocktype = cpu_to_be32(JFS_SUPERBLOCK_V2);
+
+	sb->s_blocksize	= cpu_to_be32(journal->j_blocksize);
+	sb->s_maxlen	= cpu_to_be32(journal->j_maxlen);
+	sb->s_first	= cpu_to_be32(1);
+
+	journal->j_transaction_sequence = 1;
+
+	journal->j_flags &= ~JFS_ABORT;
+	journal->j_format_version = 2;
+
+	return hfsplus_jbd_reset(journal);
+}
+
+/** 
+ * void hfsplus_jbd_update_superblock() - Update journal sb on disk.
+ * @journal: The journal to update.
+ * @wait: Set to '0' if you don't want to wait for IO completion.
+ *
+ * Update a journal's dynamic superblock fields and write it to disk,
+ * optionally waiting for the IO to complete.
+ */
+void hfsplus_jbd_update_superblock(hfsplus_jbd_t *journal, int wait)
+{
+	hfsplus_jbd_superblock_t *sb = journal->j_superblock;
+	struct buffer_head *bh = journal->j_sb_buffer;
+
+	/*
+	 * As a special case, if the on-disk copy is already marked as needing
+	 * no recovery (s_start == 0) and there are no outstanding transactions
+	 * in the filesystem, then we can safely defer the superblock update
+	 * until the next commit by setting JFS_FLUSHED.  This avoids
+	 * attempting a write to a potential-readonly device.
+	 */
+	if (sb->s_start == 0 && journal->j_tail_sequence ==
+				journal->j_transaction_sequence) {
+		hfsplus_jbd_debug(1,"JBD: Skipping superblock update on recovered sb "
+			"(start %ld, seq %d, errno %d)\n",
+			journal->j_tail, journal->j_tail_sequence, 
+			journal->j_errno);
+		goto out;
+	}
+
+	spin_lock(&journal->j_state_lock);
+	hfsplus_jbd_debug(1,"JBD: updating superblock (start %ld, seq %d, errno %d)\n",
+		  journal->j_tail, journal->j_tail_sequence, journal->j_errno);
+
+	sb->s_sequence = cpu_to_be32(journal->j_tail_sequence);
+	sb->s_start    = cpu_to_be32(journal->j_tail);
+	sb->s_errno    = cpu_to_be32(journal->j_errno);
+	hfsplus_jhdr_checksum_calculate(journal);
+	spin_unlock(&journal->j_state_lock);
+
+	HFSPLUS_BUFFER_TRACE(bh, "marking dirty");
+	mark_buffer_dirty(bh);
+	if (wait)
+		sync_dirty_buffer(bh);
+	else
+		ll_rw_block(SWRITE, 1, &bh);
+
+out:
+	/* If we have just flushed the log (by marking s_start==0), then
+	 * any future commit will have to be careful to update the
+	 * superblock again to re-record the true start of the log. */
+
+	spin_lock(&journal->j_state_lock);
+	if (sb->s_start)
+		journal->j_flags &= ~JFS_FLUSHED;
+	else
+		journal->j_flags |= JFS_FLUSHED;
+	spin_unlock(&journal->j_state_lock);
+}
+
+/*
+ * Read the superblock for a given journal, performing initial
+ * validation of the format.
+ */
+
+static int hfsplus_jbd_get_superblock(hfsplus_jbd_t *journal)
+{
+	struct buffer_head *bh;
+	hfsplus_jbd_superblock_t *sb;
+	int err = -EIO;
+
+	bh = journal->j_sb_buffer;
+
+	HFSPLUS_J_ASSERT(bh != NULL);
+	if (!buffer_uptodate(bh)) {
+		ll_rw_block(READ, 1, &bh);
+		wait_on_buffer(bh);
+		if (!buffer_uptodate(bh)) {
+			printk (KERN_ERR
+				"JBD: IO error reading journal superblock\n");
+			goto out;
+		}
+	}
+
+	sb = journal->j_superblock;
+
+	err = -EINVAL;
+
+	if (sb->s_header.h_magic != cpu_to_be32(JFS_MAGIC_NUMBER) ||
+	    sb->s_blocksize != cpu_to_be32(journal->j_blocksize)) {
+		printk(KERN_WARNING "JBD: no valid journal superblock found, cpu_to_be32(sb->s_header.h_magic): %x, cpu_to_be32(sb->s_blocksize): %x\n", cpu_to_be32(sb->s_header.h_magic), cpu_to_be32(sb->s_blocksize));
+		goto out;
+	}
+
+	switch(be32_to_cpu(sb->s_header.h_blocktype)) {
+	case JFS_SUPERBLOCK_V1:
+		journal->j_format_version = 1;
+		break;
+	case JFS_SUPERBLOCK_V2:
+		journal->j_format_version = 2;
+		break;
+	default:
+		printk(KERN_WARNING "JBD: unrecognised superblock format ID\n");
+		goto out;
+	}
+
+	if (be32_to_cpu(sb->s_maxlen) < journal->j_maxlen)
+		journal->j_maxlen = be32_to_cpu(sb->s_maxlen);
+	else if (be32_to_cpu(sb->s_maxlen) > journal->j_maxlen) {
+		printk (KERN_WARNING "JBD: journal file too short\n");
+		goto out;
+	}
+
+	return 0;
+
+out:
+	hfsplus_jbd_fail_superblock(journal);
+	return err;
+}
+
+/*
+ * Load the on-disk journal superblock and read the key fields into the
+ * hfsplus_jbd_t.
+ */
+
+static int load_superblock(hfsplus_jbd_t *journal)
+{
+	int err;
+	hfsplus_jbd_superblock_t *sb;
+
+	err = hfsplus_jbd_get_superblock(journal);
+	if (err)
+		return err;
+
+	sb = journal->j_superblock;
+
+	journal->j_tail_sequence = be32_to_cpu(sb->s_sequence);
+	journal->j_tail = be32_to_cpu(sb->s_start);
+	journal->j_first = be32_to_cpu(sb->s_first);
+	journal->j_last = be32_to_cpu(sb->s_maxlen);
+	journal->j_errno = be32_to_cpu(sb->s_errno);
+
+	return 0;
+}
+
+
+/**
+ * int hfsplus_jbd_load() - Read journal from disk.
+ * @journal: Journal to act on.
+ * 
+ * Given a hfsplus_jbd_t structure which tells us which disk blocks contain
+ * a journal, read the journal from disk to initialise the in-memory
+ * structures.
+ */
+int hfsplus_jbd_load(hfsplus_jbd_t *journal)
+{
+	int err;
+
+	err = load_superblock(journal);
+	if (err)
+		return err;
+
+	/* If this is a V2 superblock, then we have to check the
+	 * features flags on it. */
+
+	if (journal->j_format_version >= 2) {
+		hfsplus_jbd_superblock_t *sb = journal->j_superblock;
+
+		if ((sb->s_feature_ro_compat &
+		     ~cpu_to_be32(JFS_KNOWN_ROCOMPAT_FEATURES)) ||
+		    (sb->s_feature_incompat &
+		     ~cpu_to_be32(JFS_KNOWN_INCOMPAT_FEATURES))) {
+			printk (KERN_WARNING
+				"JBD: Unrecognised features on journal\n");
+			return -EINVAL;
+		}
+	}
+
+	/* Let the recovery code check whether it needs to recover any
+	 * data from the journal. */
+	if (hfsplus_jbd_recover(journal))
+		goto recovery_error;
+
+	/* OK, we've finished with the dynamic journal bits:
+	 * reinitialise the dynamic contents of the superblock in memory
+	 * and reset them on disk. */
+	if (hfsplus_jbd_reset(journal))
+		goto recovery_error;
+
+	journal->j_flags &= ~JFS_ABORT;
+	journal->j_flags |= JFS_LOADED;
+	return 0;
+
+recovery_error:
+	printk (KERN_WARNING "JBD: recovery failed\n");
+	return -EIO;
+}
+
+/**
+ * void hfsplus_jbd_destroy() - Release a hfsplus_jbd_t structure.
+ * @journal: Journal to act on.
+ *
+ * Release a hfsplus_jbd_t structure once it is no longer in use by the
+ * journaled object.
+ */
+int hfsplus_jbd_destroy(hfsplus_jbd_t *journal)
+{
+	int err = 0;
+	/* Wait for the commit thread to wake up and die. */
+	hfsplus_jbd_kill_thread(journal);
+
+	/* Force a final log commit */
+	if (journal->j_running_transaction)
+		hfsplus_jbd_commit_transaction(journal);
+
+	/* Force any old transactions to disk */
+
+	/* Totally anal locking here... */
+	spin_lock(&journal->j_list_lock);
+	while (journal->j_checkpoint_transactions != NULL) {
+		spin_unlock(&journal->j_list_lock);
+		hfsplus_jbd_log_do_checkpoint(journal);
+		spin_lock(&journal->j_list_lock);
+	}
+
+	HFSPLUS_J_ASSERT(journal->j_running_transaction == NULL);
+	HFSPLUS_J_ASSERT(journal->j_committing_transaction == NULL);
+	HFSPLUS_J_ASSERT(journal->j_checkpoint_transactions == NULL);
+	spin_unlock(&journal->j_list_lock);
+
+	/* We can now mark the journal as empty. */
+	journal->j_tail = 0;
+	journal->j_tail_sequence = ++journal->j_transaction_sequence;
+#ifdef HFSPLUS_JOURNAL_MAC_COMPATIBLE
+	hfsplus_journal_mark_journal_empty(journal);
+#endif
+	if (journal->j_sb_buffer) {
+		if (!is_hfsplus_jbd_aborted(journal)) {
+			/* We can now mark the journal as empty. */
+			journal->j_tail = 0;
+			journal->j_tail_sequence =
+				++journal->j_transaction_sequence;
+			hfsplus_jbd_update_superblock(journal, 1);
+		} else {
+			err = -EIO;
+		}
+		brelse(journal->j_sb_buffer);
+	}
+
+	if (journal->j_inode)
+		iput(journal->j_inode);
+	if (journal->j_revoke)
+		hfsplus_jbd_destroy_revoke(journal);
+	kfree(journal->j_wbuf);
+	kfree(journal);
+	return err;
+}
+
+
+/**
+ *int hfsplus_jbd_check_used_features () - Check if features specified are used.
+ * @journal: Journal to check.
+ * @compat: bitmask of compatible features
+ * @ro: bitmask of features that force read-only mount
+ * @incompat: bitmask of incompatible features
+ * 
+ * Check whether the journal uses all of a given set of
+ * features.  Return true (non-zero) if it does. 
+ **/
+
+int hfsplus_jbd_check_used_features (hfsplus_jbd_t *journal, unsigned long compat,
+				 unsigned long ro, unsigned long incompat)
+{
+	hfsplus_jbd_superblock_t *sb;
+
+	if (!compat && !ro && !incompat)
+		return 1;
+	if (journal->j_format_version == 1)
+		return 0;
+
+	sb = journal->j_superblock;
+
+	if (((be32_to_cpu(sb->s_feature_compat) & compat) == compat) &&
+	    ((be32_to_cpu(sb->s_feature_ro_compat) & ro) == ro) &&
+	    ((be32_to_cpu(sb->s_feature_incompat) & incompat) == incompat))
+		return 1;
+
+	return 0;
+}
+
+/**
+ * int hfsplus_jbd_check_available_features() - Check feature set in journalling layer
+ * @journal: Journal to check.
+ * @compat: bitmask of compatible features
+ * @ro: bitmask of features that force read-only mount
+ * @incompat: bitmask of incompatible features
+ * 
+ * Check whether the journaling code supports the use of
+ * all of a given set of features on this journal.  Return true
+ * (non-zero) if it can. */
+
+int hfsplus_jbd_check_available_features (hfsplus_jbd_t *journal, unsigned long compat,
+				      unsigned long ro, unsigned long incompat)
+{
+	hfsplus_jbd_superblock_t *sb;
+
+	if (!compat && !ro && !incompat)
+		return 1;
+
+	sb = journal->j_superblock;
+
+	/* We can support any known requested features iff the
+	 * superblock is in version 2.  Otherwise we fail to support any
+	 * extended sb features. */
+
+	if (journal->j_format_version != 2)
+		return 0;
+
+	if ((compat   & JFS_KNOWN_COMPAT_FEATURES) == compat &&
+	    (ro       & JFS_KNOWN_ROCOMPAT_FEATURES) == ro &&
+	    (incompat & JFS_KNOWN_INCOMPAT_FEATURES) == incompat)
+		return 1;
+
+	return 0;
+}
+
+/**
+ * int hfsplus_jbd_set_features () - Mark a given journal feature in the superblock
+ * @journal: Journal to act on.
+ * @compat: bitmask of compatible features
+ * @ro: bitmask of features that force read-only mount
+ * @incompat: bitmask of incompatible features
+ *
+ * Mark a given journal feature as present on the
+ * superblock.  Returns true if the requested features could be set. 
+ *
+ */
+
+int hfsplus_jbd_set_features (hfsplus_jbd_t *journal, unsigned long compat,
+			  unsigned long ro, unsigned long incompat)
+{
+	hfsplus_jbd_superblock_t *sb;
+
+	if (hfsplus_jbd_check_used_features(journal, compat, ro, incompat))
+		return 1;
+
+	if (!hfsplus_jbd_check_available_features(journal, compat, ro, incompat))
+		return 0;
+
+	hfsplus_jbd_debug(1, "Setting new features 0x%lx/0x%lx/0x%lx\n",
+		  compat, ro, incompat);
+
+	sb = journal->j_superblock;
+
+	sb->s_feature_compat    |= cpu_to_be32(compat);
+	sb->s_feature_ro_compat |= cpu_to_be32(ro);
+	sb->s_feature_incompat  |= cpu_to_be32(incompat);
+
+	return 1;
+}
+
+
+/**
+ * int hfsplus_jbd_update_format () - Update on-disk journal structure.
+ * @journal: Journal to act on.
+ *
+ * Given an initialised but unloaded journal struct, poke about in the
+ * on-disk structure to update it to the most recent supported version.
+ */
+int hfsplus_jbd_update_format (hfsplus_jbd_t *journal)
+{
+	hfsplus_jbd_superblock_t *sb;
+	int err;
+
+	err = hfsplus_jbd_get_superblock(journal);
+	if (err)
+		return err;
+
+	sb = journal->j_superblock;
+
+	switch (be32_to_cpu(sb->s_header.h_blocktype)) {
+	case JFS_SUPERBLOCK_V2:
+		return 0;
+	case JFS_SUPERBLOCK_V1:
+		return hfsplus_jbd_convert_superblock_v1(journal, sb);
+	default:
+		break;
+	}
+	return -EINVAL;
+}
+
+static int hfsplus_jbd_convert_superblock_v1(hfsplus_jbd_t *journal,
+					 hfsplus_jbd_superblock_t *sb)
+{
+	int offset, blocksize;
+	struct buffer_head *bh;
+
+	printk(KERN_WARNING
+		"JBD: Converting superblock from version 1 to 2.\n");
+
+	/* Pre-initialise new fields to zero */
+	offset = ((char *) &(sb->s_feature_compat)) - ((char *) sb);
+	blocksize = be32_to_cpu(sb->s_blocksize);
+	memset(&sb->s_feature_compat, 0, blocksize-offset);
+
+	sb->s_nr_users = cpu_to_be32(1);
+	sb->s_header.h_blocktype = cpu_to_be32(JFS_SUPERBLOCK_V2);
+	journal->j_format_version = 2;
+
+	bh = journal->j_sb_buffer;
+	HFSPLUS_BUFFER_TRACE(bh, "marking dirty");
+	mark_buffer_dirty(bh);
+	sync_dirty_buffer(bh);
+	return 0;
+}
+
+
+/**
+ * int hfsplus_jbd_flush () - Flush journal
+ * @journal: Journal to act on.
+ * 
+ * Flush all data for a given journal to disk and empty the journal.
+ * Filesystems can use this when remounting readonly to ensure that
+ * recovery does not need to happen on remount.
+ */
+
+int hfsplus_jbd_flush(hfsplus_jbd_t *journal)
+{
+	int err = 0;
+	hfsplus_transaction_t *transaction = NULL;
+	unsigned int old_tail;
+
+	spin_lock(&journal->j_state_lock);
+
+	/* Force everything buffered to the log... */
+	if (journal->j_running_transaction) {
+		transaction = journal->j_running_transaction;
+		__hfsplus__log_start_commit(journal, transaction->t_tid);
+	} else if (journal->j_committing_transaction)
+		transaction = journal->j_committing_transaction;
+
+	/* Wait for the log commit to complete... */
+	if (transaction) {
+		hfsplus_jbd_tid_t tid = transaction->t_tid;
+
+		spin_unlock(&journal->j_state_lock);
+		hfsplus_jbd_log_wait_commit(journal, tid);
+	} else {
+		spin_unlock(&journal->j_state_lock);
+	}
+
+	/* ...and flush everything in the log out to disk. */
+	spin_lock(&journal->j_list_lock);
+	while (!err && journal->j_checkpoint_transactions != NULL) {
+		spin_unlock(&journal->j_list_lock);
+		mutex_lock(&journal->j_checkpoint_mutex);
+		err = hfsplus_jbd_log_do_checkpoint(journal);
+		mutex_unlock(&journal->j_checkpoint_mutex);
+		spin_lock(&journal->j_list_lock);
+	}
+	spin_unlock(&journal->j_list_lock);
+	if (is_hfsplus_jbd_aborted(journal))
+		return -EIO;
+	cleanup_hfsplus_jbd_tail(journal);
+
+	/* Finally, mark the journal as really needing no recovery.
+	 * This sets s_start==0 in the underlying superblock, which is
+	 * the magic code for a fully-recovered superblock.  Any future
+	 * commits of data to the journal will restore the current
+	 * s_start value. */
+	spin_lock(&journal->j_state_lock);
+	old_tail = journal->j_tail;
+	journal->j_tail = 0;
+	spin_unlock(&journal->j_state_lock);
+	hfsplus_jbd_update_superblock(journal, 1);
+	spin_lock(&journal->j_state_lock);
+	journal->j_tail = old_tail;
+
+	HFSPLUS_J_ASSERT(!journal->j_running_transaction);
+	HFSPLUS_J_ASSERT(!journal->j_committing_transaction);
+	HFSPLUS_J_ASSERT(!journal->j_checkpoint_transactions);
+	HFSPLUS_J_ASSERT(journal->j_head == journal->j_tail);
+	HFSPLUS_J_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);
+	spin_unlock(&journal->j_state_lock);
+	return 0;
+}
+
+/**
+ * int hfsplus_jbd_wipe() - Wipe journal contents
+ * @journal: Journal to act on.
+ * @write: flag (see below)
+ * 
+ * Wipe out all of the contents of a journal, safely.  This will produce
+ * a warning if the journal contains any valid recovery information.
+ * Must be called between hfsplus_jbd_init_*() and hfsplus_jbd_load().
+ *
+ * If 'write' is non-zero, then we wipe out the journal on disk; otherwise
+ * we merely suppress recovery.
+ */
+
+int hfsplus_jbd_wipe(hfsplus_jbd_t *journal, int write)
+{
+	hfsplus_jbd_superblock_t *sb;
+	int err = 0;
+
+	HFSPLUS_J_ASSERT (!(journal->j_flags & JFS_LOADED));
+
+	err = load_superblock(journal);
+	if (err)
+		return err;
+
+	sb = journal->j_superblock;
+
+	if (!journal->j_tail)
+		goto no_recovery;
+
+	printk (KERN_WARNING "JBD: %s recovery information on journal\n",
+		write ? "Clearing" : "Ignoring");
+
+	err = hfsplus_jbd_skip_recovery(journal);
+	if (write)
+		hfsplus_jbd_update_superblock(journal, 1);
+
+ no_recovery:
+	return err;
+}
+
+/*
+ * hfsplus_jbd_dev_name: format a character string to describe on what
+ * device this journal is present.
+ */
+
+static const char *hfsplus_jbd_dev_name(hfsplus_jbd_t *journal, char *buffer)
+{
+	struct block_device *bdev;
+
+	if (journal->j_inode)
+		bdev = journal->j_inode->i_sb->s_bdev;
+	else
+		bdev = journal->j_dev;
+
+	return bdevname(bdev, buffer);
+}
+
+/*
+ * Journal abort has very specific semantics, which we describe
+ * for journal abort. 
+ *
+ * Two internal function, which provide abort to te jbd layer
+ * itself are here.
+ */
+
+/*
+ * Quick version for internal journal use (doesn't lock the journal).
+ * Aborts hard --- we mark the abort as occurred, but do _nothing_ else,
+ * and don't attempt to make any other journal updates.
+ */
+void __hfsplus_jbd_abort_hard(hfsplus_jbd_t *journal)
+{
+	hfsplus_transaction_t *transaction;
+	char b[BDEVNAME_SIZE];
+
+	if (journal->j_flags & JFS_ABORT)
+		return;
+
+	printk(KERN_ERR "Aborting journal on device %s.\n",
+		hfsplus_jbd_dev_name(journal, b));
+
+	spin_lock(&journal->j_state_lock);
+	journal->j_flags |= JFS_ABORT;
+	transaction = journal->j_running_transaction;
+	if (transaction)
+		__hfsplus__log_start_commit(journal, transaction->t_tid);
+	spin_unlock(&journal->j_state_lock);
+}
+
+/* Soft abort: record the abort error status in the journal superblock,
+ * but don't do any other IO. */
+static void __hfsplus_jbd_abort_soft (hfsplus_jbd_t *journal, int errno)
+{
+	if (journal->j_flags & JFS_ABORT)
+		return;
+
+	if (!journal->j_errno)
+		journal->j_errno = errno;
+
+	__hfsplus_jbd_abort_hard(journal);
+
+	if (errno)
+		hfsplus_jbd_update_superblock(journal, 1);
+}
+
+/**
+ * void hfsplus_jbd_abort () - Shutdown the journal immediately.
+ * @journal: the journal to shutdown.
+ * @errno:   an error number to record in the journal indicating
+ *           the reason for the shutdown.
+ *
+ * Perform a complete, immediate shutdown of the ENTIRE
+ * journal (not of a single transaction).  This operation cannot be
+ * undone without closing and reopening the journal.
+ *           
+ * The hfsplus_jbd_abort function is intended to support higher level error
+ * recovery mechanisms such as the ext2/ext3 remount-readonly error
+ * mode.
+ *
+ * Journal abort has very specific semantics.  Any existing dirty,
+ * unjournaled buffers in the main filesystem will still be written to
+ * disk by bdflush, but the journaling mechanism will be suspended
+ * immediately and no further transaction commits will be honoured.
+ *
+ * Any dirty, journaled buffers will be written back to disk without
+ * hitting the journal.  Atomicity cannot be guaranteed on an aborted
+ * filesystem, but we _do_ attempt to leave as much data as possible
+ * behind for fsck to use for cleanup.
+ *
+ * Any attempt to get a new transaction handle on a journal which is in
+ * ABORT state will just result in an -EROFS error return.  A
+ * hfsplus_jbd_stop on an existing handle will return -EIO if we have
+ * entered abort state during the update.
+ *
+ * Recursive transactions are not disturbed by journal abort until the
+ * final hfsplus_jbd_stop, which will receive the -EIO error.
+ *
+ * Finally, the hfsplus_jbd_abort call allows the caller to supply an errno
+ * which will be recorded (if possible) in the journal superblock.  This
+ * allows a client to record failure conditions in the middle of a
+ * transaction without having to complete the transaction to record the
+ * failure to disk.  ext3_error, for example, now uses this
+ * functionality.
+ *
+ * Errors which originate from within the journaling layer will NOT
+ * supply an errno; a null errno implies that absolutely no further
+ * writes are done to the journal (unless there are any already in
+ * progress).
+ * 
+ */
+
+void hfsplus_jbd_abort(hfsplus_jbd_t *journal, int errno)
+{
+	__hfsplus_jbd_abort_soft(journal, errno);
+}
+
+/** 
+ * int hfsplus_jbd_errno () - returns the journal's error state.
+ * @journal: journal to examine.
+ *
+ * This is the errno numbet set with hfsplus_jbd_abort(), the last
+ * time the journal was mounted - if the journal was stopped
+ * without calling abort this will be 0.
+ *
+ * If the journal has been aborted on this mount time -EROFS will
+ * be returned.
+ */
+int hfsplus_jbd_errno(hfsplus_jbd_t *journal)
+{
+	int err;
+
+	spin_lock(&journal->j_state_lock);
+	if (journal->j_flags & JFS_ABORT)
+		err = -EROFS;
+	else
+		err = journal->j_errno;
+	spin_unlock(&journal->j_state_lock);
+	return err;
+}
+
+/** 
+ * int hfsplus_jbd_clear_err () - clears the journal's error state
+ * @journal: journal to act on.
+ *
+ * An error must be cleared or Acked to take a FS out of readonly
+ * mode.
+ */
+int hfsplus_jbd_clear_err(hfsplus_jbd_t *journal)
+{
+	int err = 0;
+
+	spin_lock(&journal->j_state_lock);
+	if (journal->j_flags & JFS_ABORT)
+		err = -EROFS;
+	else
+		journal->j_errno = 0;
+	spin_unlock(&journal->j_state_lock);
+	return err;
+}
+
+/** 
+ * void hfsplus_jbd_ack_err() - Ack journal err.
+ * @journal: journal to act on.
+ *
+ * An error must be cleared or Acked to take a FS out of readonly
+ * mode.
+ */
+void hfsplus_jbd_ack_err(hfsplus_jbd_t *journal)
+{
+	spin_lock(&journal->j_state_lock);
+	if (journal->j_errno)
+		journal->j_flags |= JFS_ACK_ERR;
+	spin_unlock(&journal->j_state_lock);
+}
+
+int hfsplus_jbd_blocks_per_page(struct inode *inode)
+{
+	return 1 << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);
+}
+
+/*
+ * Simple support for retrying memory allocations.  Introduced to help to
+ * debug different VM deadlock avoidance strategies. 
+ */
+void * __hfsplus_jbd_kmalloc (const char *where, size_t size, gfp_t flags, int retry)
+{
+	return kmalloc(size, flags | (retry ? __GFP_NOFAIL : 0));
+}
+
+/*
+ * Journal_head storage management
+ */
+static struct kmem_cache *hfsplus_jbd_head_cache;
+#ifdef CONFIG_JBD_DEBUG
+static atomic_t nr_hfsplus_jbd_heads = ATOMIC_INIT(0);
+#endif
+
+static int hfsplus_jbd_init_journal_head_cache(void)
+{
+	int retval;
+
+	HFSPLUS_J_ASSERT(hfsplus_jbd_head_cache == NULL);
+	hfsplus_jbd_head_cache = kmem_cache_create("hfsplus_jbd_head",
+				sizeof(struct hfsplus_jbd_head),
+				0,		/* offset */
+				SLAB_TEMPORARY,		/* flags */
+				NULL);		/* dtor */
+	retval = 0;
+	if (!hfsplus_jbd_head_cache) {
+		retval = -ENOMEM;
+		printk(KERN_EMERG "JBD: no memory for hfsplus_jbd_head cache\n");
+	}
+	return retval;
+}
+
+static void hfsplus_jbd_destroy_journal_head_cache(void)
+{
+	if (hfsplus_jbd_head_cache) {
+		kmem_cache_destroy(hfsplus_jbd_head_cache);
+		hfsplus_jbd_head_cache = NULL;
+	}
+}
+
+/*
+ * hfsplus_jbd_head splicing and dicing
+ */
+static struct hfsplus_jbd_head *hfsplus_jbd_alloc_journal_head(void)
+{
+	struct hfsplus_jbd_head *ret;
+	static unsigned long last_warning;
+
+#ifdef CONFIG_JBD_DEBUG
+	atomic_inc(&nr_hfsplus_jbd_heads);
+#endif
+	ret = kmem_cache_alloc(hfsplus_jbd_head_cache, GFP_NOFS);
+	if (ret == NULL) {
+		printk(KERN_ERR "Out of memory for hfsplus_jbd_head\n");
+		if (time_after(jiffies, last_warning + 5*HZ)) {
+			printk(KERN_ERR "ENOMEM in %s, retrying.\n", __func__);
+			last_warning = jiffies;
+		}
+		while (ret == NULL) {
+			yield();
+			ret = kmem_cache_alloc(hfsplus_jbd_head_cache, GFP_NOFS);
+			if (ret == 0)
+				printk(KERN_ERR "Again out of memory for hfsplus_jbd_head\n");
+		}
+	}
+	return ret;
+}
+
+static void hfsplus_jbd_free_journal_head(struct hfsplus_jbd_head *jh)
+{
+#ifdef CONFIG_JBD_DEBUG
+	atomic_dec(&nr_hfsplus_jbd_heads);
+	memset(jh, 0x5b, sizeof(*jh));
+#endif
+	kmem_cache_free(hfsplus_jbd_head_cache, jh);
+}
+
+/*
+ * A hfsplus_jbd_head is attached to a buffer_head whenever JBD has an
+ * interest in the buffer.
+ *
+ * Whenever a buffer has an attached hfsplus_jbd_head, its ->b_state:BH_JBD bit
+ * is set.  This bit is tested in core kernel code where we need to take
+ * JBD-specific actions.  Testing the zeroness of ->b_private is not reliable
+ * there.
+ *
+ * When a buffer has its BH_JBD bit set, its ->b_count is elevated by one.
+ *
+ * When a buffer has its BH_JBD bit set it is immune from being released by
+ * core kernel code, mainly via ->b_count.
+ *
+ * A hfsplus_jbd_head may be detached from its buffer_head when the hfsplus_jbd_head's
+ * b_transaction, b_cp_transaction and b_next_transaction pointers are NULL.
+ * Various places in JBD call hfsplus_jbd_remove_journal_head() to indicate that the
+ * hfsplus_jbd_head can be dropped if needed.
+ *
+ * Various places in the kernel want to attach a hfsplus_jbd_head to a buffer_head
+ * _before_ attaching the hfsplus_jbd_head to a transaction.  To protect the
+ * hfsplus_jbd_head in this situation, hfsplus_jbd_add_journal_head elevates the
+ * hfsplus_jbd_head's b_jcount refcount by one.  The caller must call
+ * hfsplus_jbd_put_journal_head() to undo this.
+ *
+ * So the typical usage would be:
+ *
+ *	(Attach a hfsplus_jbd_head if needed.  Increments b_jcount)
+ *	struct hfsplus_jbd_head *jh = hfsplus_jbd_add_journal_head(bh);
+ *	...
+ *	jh->b_transaction = xxx;
+ *	hfsplus_jbd_put_journal_head(jh);
+ *
+ * Now, the hfsplus_jbd_head's b_jcount is zero, but it is safe from being released
+ * because it has a non-zero b_transaction.
+ */
+
+/*
+ * Give a buffer_head a hfsplus_jbd_head.
+ *
+ * Doesn't need the journal lock.
+ * May sleep.
+ */
+struct hfsplus_jbd_head *hfsplus_jbd_add_journal_head(struct buffer_head *bh)
+{
+	struct hfsplus_jbd_head *jh;
+	struct hfsplus_jbd_head *new_jh = NULL;
+
+repeat:
+	if (!buffer_hfsplus_jbd(bh)) {
+		new_jh = hfsplus_jbd_alloc_journal_head();
+		if (!new_jh) {
+			printk(KERN_ERR "Error in allocating journal head\n");
+			return NULL;
+		}
+		memset(new_jh, 0, sizeof(*new_jh));
+	}
+
+	hfsplus_jbd_lock_bh_hfsplus_jbd_head(bh);
+	if (buffer_hfsplus_jbd(bh)) {
+		jh = hfsplus_bh2jh(bh);
+	} else {
+		HFSPLUS_J_ASSERT_BH(bh,
+			(atomic_read(&bh->b_count) > 0) ||
+			(bh->b_page && bh->b_page->mapping));
+
+		if (!new_jh) {
+			hfsplus_jbd_unlock_bh_hfsplus_jbd_head(bh);
+			goto repeat;
+		}
+
+		jh = new_jh;
+		new_jh = NULL;		/* We consumed it */
+		set_buffer_hfsplus_jbd(bh);
+		bh->b_private = jh;
+		jh->b_bh = bh;
+		get_bh(bh);
+		HFSPLUS_BUFFER_TRACE(bh, "added hfsplus_jbd_head");
+	}
+	jh->b_jcount++;
+	hfsplus_jbd_unlock_bh_hfsplus_jbd_head(bh);
+	if (new_jh)
+		hfsplus_jbd_free_journal_head(new_jh);
+	return bh->b_private;
+}
+
+/*
+ * Grab a ref against this buffer_head's hfsplus_jbd_head.  If it ended up not
+ * having a hfsplus_jbd_head, return NULL
+ */
+struct hfsplus_jbd_head *hfsplus_jbd_grab_journal_head(struct buffer_head *bh)
+{
+	struct hfsplus_jbd_head *jh = NULL;
+
+	hfsplus_jbd_lock_bh_hfsplus_jbd_head(bh);
+	if (buffer_hfsplus_jbd(bh)) {
+		jh = hfsplus_bh2jh(bh);
+		jh->b_jcount++;
+	}
+	hfsplus_jbd_unlock_bh_hfsplus_jbd_head(bh);
+	return jh;
+}
+
+static void __hfsplus_jbd_remove_journal_head(struct buffer_head *bh)
+{
+	struct hfsplus_jbd_head *jh = hfsplus_bh2jh(bh);
+
+	HFSPLUS_J_ASSERT_JH(jh, jh->b_jcount >= 0);
+
+	get_bh(bh);
+	if (jh->b_jcount == 0) {
+		if (jh->b_transaction == NULL &&
+				jh->b_next_transaction == NULL &&
+				jh->b_cp_transaction == NULL) {
+			HFSPLUS_J_ASSERT_JH(jh, jh->b_jlist == HFSPLUS_BJ_None);
+			HFSPLUS_J_ASSERT_BH(bh, buffer_hfsplus_jbd(bh));
+			HFSPLUS_J_ASSERT_BH(bh, hfsplus_jh2bh(jh) == bh);
+			HFSPLUS_BUFFER_TRACE(bh, "remove hfsplus_jbd_head");
+			if (jh->b_frozen_data) {
+				printk(KERN_WARNING "%s: freeing "
+						"b_frozen_data\n",
+						__func__);
+				hfsplus_jbd_free(jh->b_frozen_data, bh->b_size);
+			}
+			if (jh->b_committed_data) {
+				printk(KERN_WARNING "%s: freeing "
+						"b_committed_data\n",
+						__func__);
+				hfsplus_jbd_free(jh->b_committed_data, bh->b_size);
+			}
+			bh->b_private = NULL;
+			jh->b_bh = NULL;	/* debug, really */
+			clear_buffer_hfsplus_jbd(bh);
+			__brelse(bh);
+			hfsplus_jbd_free_journal_head(jh);
+		} else {
+			HFSPLUS_BUFFER_TRACE(bh, "journal_head was locked");
+		}
+	}
+}
+
+/*
+ * hfsplus_jbd_remove_journal_head(): if the buffer isn't attached to a transaction
+ * and has a zero b_jcount then remove and release its hfsplus_jbd_head.   If we did
+ * see that the buffer is not used by any transaction we also "logically"
+ * decrement ->b_count.
+ *
+ * We in fact take an additional increment on ->b_count as a convenience,
+ * because the caller usually wants to do additional things with the bh
+ * after calling here.
+ * The caller of hfsplus_jbd_remove_journal_head() *must* run __brelse(bh) at some
+ * time.  Once the caller has run __brelse(), the buffer is eligible for
+ * reaping by try_to_free_buffers().
+ */
+void hfsplus_jbd_remove_journal_head(struct buffer_head *bh)
+{
+	hfsplus_jbd_lock_bh_hfsplus_jbd_head(bh);
+	__hfsplus_jbd_remove_journal_head(bh);
+	hfsplus_jbd_unlock_bh_hfsplus_jbd_head(bh);
+}
+
+/*
+ * Drop a reference on the passed hfsplus_jbd_head.  If it fell to zero then try to
+ * release the hfsplus_jbd_head from the buffer_head.
+ */
+void hfsplus_jbd_put_journal_head(struct hfsplus_jbd_head *jh)
+{
+	struct buffer_head *bh = hfsplus_jh2bh(jh);
+
+	hfsplus_jbd_lock_bh_hfsplus_jbd_head(bh);
+	HFSPLUS_J_ASSERT_JH(jh, jh->b_jcount > 0);
+	--jh->b_jcount;
+	if (!jh->b_jcount && !jh->b_transaction) {
+		__hfsplus_jbd_remove_journal_head(bh);
+		__brelse(bh);
+	}
+	hfsplus_jbd_unlock_bh_hfsplus_jbd_head(bh);
+}
+
+/*
+ * /proc tunables
+ */
+#if defined(CONFIG_JBD_DEBUG)
+int hfsplus_jbd_enable_debug;
+EXPORT_SYMBOL(hfsplus_jbd_enable_debug);
+#endif
+
+#if defined(CONFIG_JBD_DEBUG) && defined(CONFIG_PROC_FS)
+
+static struct proc_dir_entry *proc_hfsplus_jbd_debug;
+
+static int read_hfsplus_jbd_debug(char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int ret;
+
+	ret = sprintf(page + off, "%d\n", hfsplus_jbd_enable_debug);
+	*eof = 1;
+	return ret;
+}
+
+static int write_hfsplus_jbd_debug(struct file *file, const char __user *buffer,
+			   unsigned long count, void *data)
+{
+	char buf[32];
+
+	if (count > ARRAY_SIZE(buf) - 1)
+		count = ARRAY_SIZE(buf) - 1;
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+	buf[ARRAY_SIZE(buf) - 1] = '\0';
+	hfsplus_jbd_enable_debug = simple_strtoul(buf, NULL, 10);
+	return count;
+}
+
+#define JBD_PROC_NAME "sys/fs/jbd-debug"
+
+static void __init create_jbd_proc_entry(void)
+{
+	proc_hfsplus_jbd_debug = create_proc_entry(JBD_PROC_NAME, 0644, NULL);
+	if (proc_hfsplus_jbd_debug) {
+		/* Why is this so hard? */
+		proc_hfsplus_jbd_debug->read_proc = read_hfsplus_jbd_debug;
+		proc_hfsplus_jbd_debug->write_proc = write_hfsplus_jbd_debug;
+	}
+}
+
+static void __exit remove_jbd_proc_entry(void)
+{
+	if (proc_hfsplus_jbd_debug)
+		remove_proc_entry(JBD_PROC_NAME, NULL);
+}
+
+#else
+
+#define create_jbd_proc_entry() do {} while (0)
+#define remove_jbd_proc_entry() do {} while (0)
+
+#endif
+
+struct kmem_cache *hfsplus_jbd_handle_cache;
+
+static int __init hfsplus_jbd_init_handle_cache(void)
+{
+	hfsplus_jbd_handle_cache = kmem_cache_create("hfsplus_jbd_handle",
+				sizeof(hfsplus_jbd_handle_t),
+				0,		/* offset */
+				SLAB_TEMPORARY,		/* flags */
+				NULL);		/* dtor */
+	if (hfsplus_jbd_handle_cache == NULL) {
+		printk(KERN_EMERG "JBD: failed to create handle cache\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+static void hfsplus_jbd_destroy_handle_cache(void)
+{
+	if (hfsplus_jbd_handle_cache)
+		kmem_cache_destroy(hfsplus_jbd_handle_cache);
+}
+
+/*
+ * Module startup and shutdown
+ */
+
+static int __init hfsplus_jbd_init_caches(void)
+{
+	int ret;
+
+	ret = hfsplus_jbd_init_revoke_caches();
+	if (ret == 0)
+		ret = hfsplus_jbd_init_journal_head_cache();
+	if (ret == 0)
+		ret = hfsplus_jbd_init_handle_cache();
+	return ret;
+}
+
+static void hfsplus_jbd_destroy_caches(void)
+{
+	hfsplus_jbd_destroy_revoke_caches();
+	hfsplus_jbd_destroy_journal_head_cache();
+	hfsplus_jbd_destroy_handle_cache();
+}
+
+int hfsplus_jbd_init(void)
+{
+	int ret;
+
+/* Static check for data structure consistency.  There's no code
+ * invoked --- we'll just get a linker failure if things aren't right.
+ */
+	extern void hfsplus_jbd_bad_superblock_size(void);
+	if (sizeof(struct hfsplus_jbd_superblock_s) != 1024)
+		hfsplus_jbd_bad_superblock_size();
+
+
+	ret = hfsplus_jbd_init_caches();
+	if (ret != 0)
+		hfsplus_jbd_destroy_caches();
+	create_jbd_proc_entry();
+	return ret;
+}
+
+void hfsplus_jbd_exit(void)
+{
+#ifdef CONFIG_JBD_DEBUG
+	int n = atomic_read(&nr_hfsplus_jbd_heads);
+	if (n)
+		printk(KERN_EMERG "JBD: leaked %d hfsplus_jbd_heads!\n", n);
+#endif
+	remove_jbd_proc_entry();
+	hfsplus_jbd_destroy_caches();
+}
+
+MODULE_LICENSE("GPL");
+EXPORT_SYMBOL(hfsplus_jbd_exit);
+EXPORT_SYMBOL(hfsplus_jbd_init);
+
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/journal.c linux-2.6.32/fs/hfsplus_journal/journal.c
--- linux-2.6.32-old//fs/hfsplus_journal/journal.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/journal.c	2011-11-17 11:21:09.028812233 -0500
@@ -0,0 +1,922 @@
+/*
+* HFSPlus journal implementation Tathagata Das 2010
+*/
+
+#include <linux/fs.h>
+#include <linux/blkdev.h>
+#include <linux/pagemap.h>
+#include <linux/slab.h>
+
+#include <asm/current.h>
+#include <asm/unaligned.h>
+
+#include "hfsplus_jbd.h"
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+/* Calculate chesum of ptr of size len */
+static int calc_checksum(unsigned char *ptr, int len)
+{
+	int i, chksum = 0;
+
+	for (i=0; i<len; i++, ptr++)
+		chksum = (chksum << 8) ^ (chksum + *ptr);
+
+	return (~chksum);
+}
+
+void swap_block_list_header(struct hfsplus_blhdr *blhdr)
+{
+	int i;
+
+	blhdr->num_blocks = swab16(blhdr->num_blocks);
+	blhdr->bytes_used = swab32(blhdr->bytes_used);
+	blhdr->checksum = swab32(blhdr->checksum);
+
+	for (i=1; i<blhdr->num_blocks; i++) {
+		blhdr->binfo[i].bnum = swab64(blhdr->binfo[i].bnum);
+		blhdr->binfo[i].bsize = swab32(blhdr->binfo[i].bsize);
+	}
+}
+
+static void swap_journal_header(struct hfsplus_journal_header *jh)
+{
+	jh->magic      = swab32(jh->magic);
+	jh->endian     = swab32(jh->endian);
+	jh->start      = swab64(jh->start);
+	jh->end        = swab64(jh->end);
+	jh->size       = swab64(jh->size);
+	jh->blhdr_size = swab32(jh->blhdr_size);
+	jh->checksum   = swab32(jh->checksum);
+	jh->jhdr_size  = swab32(jh->jhdr_size);
+}
+
+void print_volume_header(struct super_block *sb)
+{
+	int i;
+	unsigned char *vh_ptr = (unsigned char *)HFSPLUS_SB(sb).s_vhdr;
+
+	dprint(DBG_JOURNAL, "VOLUME HEADER\n");
+	for (i=0; i<102; i++)
+		dprint(DBG_JOURNAL, "%x ", vh_ptr[i]);
+	dprint(DBG_JOURNAL, "\n");
+}
+
+static void print_journal_header(struct hfsplus_journal_header *jh)
+{
+	dprint(DBG_JOURNAL, "HFS+-fs: magic: %x\n endian: %x\n start: %llx\n end: %llx\n size: %llx\n blhdr_size: %x\n checksum: %x\n jhdr_size: %x\n", jh->magic, jh->endian, jh->start, jh->end, jh->size, jh->blhdr_size, jh->checksum, jh->jhdr_size);
+}
+
+static int map_journal_header(struct super_block *sb)
+{
+	struct hfsplus_journal *jnl = &(HFSPLUS_SB(sb).jnl);
+	u32 jh_block_number;
+
+	jnl->jh_offset = be64_to_cpu(jnl->jibhdr->offset);
+	jh_block_number = jnl->jh_offset >> sb->s_blocksize_bits;
+	dprint(DBG_JOURNAL, "HFS+-fs: jh_block_number: %x\n", jh_block_number);
+	jnl->jh_bh = sb_bread(sb, HFSPLUS_SB(sb).blockoffset + jh_block_number);
+	if (!jnl->jh_bh) {
+		printk("HFS+-fs Line=%d: Error in buffer read\n", __LINE__);
+		return HFSPLUS_JOURNAL_FAIL;
+	}
+	jnl->jhdr = (struct hfsplus_journal_header *)(jnl->jh_bh->b_data);
+
+	return HFSPLUS_JOURNAL_SUCCESS;
+}
+
+/* START: JBD specfic functions */
+static void hfsplus_abort(struct super_block * sb, const char * function,
+		 const char * fmt, ...)
+{
+	va_list args;
+
+	printk (KERN_ERR "hfsplus_abort called.\n");
+
+	va_start(args, fmt);
+	printk(KERN_ERR "HFS+-fs error (device %s): %s: ",sb->s_id, function);
+	vprintk(fmt, args);
+	printk("\n");
+	va_end(args);
+
+	if (sb->s_flags & MS_RDONLY)
+		return;
+
+	printk(KERN_ERR "Remounting filesystem read-only\n");
+	sb->s_flags |= MS_RDONLY;
+	hfsplus_jbd_abort(HFSPLUS_SB(sb).jnl.s_journal, -EIO);
+}
+
+static void hfsplus_journal_abort_handle(const char *err_no, struct buffer_head *bh, hfsplus_handle_t *hfsplus_handle)
+{
+	if (hfsplus_jbd_is_handle_aborted(hfsplus_handle->handle))
+		return;
+
+	printk(KERN_ERR "HFS+-fs: Aborting transaction\n");
+	hfsplus_jbd_abort_handle(hfsplus_handle->handle);
+}
+
+int hfsplus_journal_get_write_access(const char *err_fn, hfsplus_handle_t *hfsplus_handle, struct buffer_head *bh)
+{
+	int err;
+
+	if (hfsplus_handle->journaled != HFSPLUS_JOURNAL_PRESENT)
+		return HFSPLUS_JOURNAL_SUCCESS;
+
+	err = hfsplus_jbd_get_write_access(hfsplus_handle->handle, bh);
+	if (err) {
+		printk(KERN_ERR "HFS+-fs: %s() unable to get journal write access\n", err_fn);
+		hfsplus_journal_abort_handle(err_fn, bh, hfsplus_handle);
+	}
+
+	return err;
+}
+
+int hfsplus_journal_dirty_metadata(const char *err_fn, struct buffer_head *bh, hfsplus_handle_t *hfsplus_handle)
+{
+	int err;
+	
+	if (hfsplus_handle->journaled != HFSPLUS_JOURNAL_PRESENT)
+		return HFSPLUS_JOURNAL_SUCCESS;
+
+	err = hfsplus_jbd_dirty_metadata(hfsplus_handle->handle, bh);
+	if (err) {
+		if (!hfsplus_handle->handle->h_err)
+			hfsplus_handle->handle->h_err = err;
+
+		if (hfsplus_jbd_is_handle_aborted(hfsplus_handle->handle))
+			return err;
+
+		printk(KERN_ERR "HFS+-fs: %s() aborting transaction:\n", err_fn);
+
+		hfsplus_jbd_abort_handle(hfsplus_handle->handle);
+	} else
+		hfsplus_handle->hcnt++;
+
+	return err;
+}
+
+/*
+ * Force the running and committing transactions to commit,
+ * and wait on the commit.
+ */
+int hfsplus_force_commit(struct super_block *sb)
+{
+	hfsplus_jbd_t *journal;
+	int ret;
+	
+	if (sb->s_flags & MS_RDONLY)
+		return 0;
+
+	journal = HFSPLUS_SB(sb).jnl.s_journal; 
+	sb->s_dirt = 0;
+	ret = hfsplus_jbd_force_commit(journal); 
+	return ret;
+}
+
+int hfsplus_journal_start(const char *err_fn, struct super_block *sb, hfsplus_handle_t *hfsplus_handle)
+{
+	hfsplus_jbd_t *journal = HFSPLUS_SB(sb).jnl.s_journal;
+
+	hfsplus_handle->journaled = HFSPLUS_SB(sb).jnl.journaled;
+	if ((hfsplus_handle->journaled != HFSPLUS_JOURNAL_PRESENT) || (journal == NULL)) {
+		hfsplus_handle->handle = NULL;
+		dprint(DBG_JTRANS, "HFS+-fs: Journal was not loaded\n");
+		return HFSPLUS_JOURNAL_SUCCESS;
+	}
+
+	if (is_hfsplus_jbd_aborted(journal)) {
+		hfsplus_abort(sb, __FUNCTION__, "Detected aborted journal");
+		return -EROFS;
+	}
+
+	hfsplus_handle->hcnt = 0;
+	hfsplus_handle->maxblock = HFSPLUS_SB(sb).jnl.journal_maxblock;
+	hfsplus_handle->handle = hfsplus_jbd_start(journal, HFSPLUS_SB(sb).jnl.journal_maxblock, hfsplus_handle);
+	if (IS_ERR(hfsplus_handle->handle)) {
+		printk(KERN_ERR "HFS+fs: journal cannot be started from %s. Error number: %ld\n", err_fn, PTR_ERR(hfsplus_handle->handle));
+		return PTR_ERR(hfsplus_handle->handle);
+	}
+
+	return HFSPLUS_JOURNAL_SUCCESS;
+}
+
+int hfsplus_journal_stop(hfsplus_handle_t *hfsplus_handle)
+{
+	if ((hfsplus_handle->journaled != HFSPLUS_JOURNAL_PRESENT) || (hfsplus_handle->handle == NULL)) {
+		return HFSPLUS_JOURNAL_SUCCESS;
+	}
+
+	return hfsplus_jbd_stop(hfsplus_handle->handle);
+}
+
+/* Fill in the initial static fields in the new journal superblock */
+static int hfsplus_journal_superblock_init(hfsplus_jbd_t *journal, int start)
+{
+	hfsplus_jbd_superblock_t *jsb;
+	struct buffer_head *bh;
+	unsigned long blocknr;
+	int i;
+   
+	if (journal->j_superblock == NULL)
+		return HFSPLUS_JOURNAL_FAIL;
+
+	jsb = journal->j_superblock;
+	memset(jsb->mac_padding, 0, sizeof(jsb->mac_padding));
+
+	if (jsb->s_header.h_magic == cpu_to_be32(JFS_MAGIC_NUMBER)) {
+		dprint(DBG_JOURNAL, "HFS+-fs: Journal superblock is already initialized\n");
+	}
+
+	dprint(DBG_JOURNAL, "HFS+-fs: Zeroing out journal blocks...\n");
+#if 0
+   for (i = start; i < journal->j_maxlen; i++) {
+		blocknr = i;
+      bh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);
+      lock_buffer(bh);
+		if (i == start)
+      	memset(bh->b_data + HFSPLUS_SECTOR_SIZE, 0, journal->j_blocksize - HFSPLUS_SECTOR_SIZE);
+		else
+      	memset(bh->b_data, 0, journal->j_blocksize);
+      mark_buffer_dirty(bh);
+      set_buffer_uptodate(bh);
+      unlock_buffer(bh);
+      __brelse(bh);
+   }
+#endif
+
+   sync_blockdev(journal->j_dev);
+   dprint(DBG_JOURNAL, "HFS+-fs: journal cleared.\n");
+
+	jsb->s_header.h_magic  = cpu_to_be32(JFS_MAGIC_NUMBER);
+	jsb->s_header.h_blocktype = cpu_to_be32(JFS_SUPERBLOCK_V2);
+
+	jsb->s_blocksize   = cpu_to_be32(journal->j_blocksize);
+	jsb->s_maxlen   = cpu_to_be32(journal->j_maxlen);
+	jsb->s_first = cpu_to_be32(start+1); /* First block is for Mac's journal header and JBD superblock */
+
+	journal->j_transaction_sequence = 1;
+
+	journal->j_flags &= ~JFS_ABORT;
+	journal->j_format_version = 2;
+#if 1
+	jsb->s_feature_ro_compat = cpu_to_be32(JFS_KNOWN_ROCOMPAT_FEATURES);
+	jsb->s_feature_incompat = cpu_to_be32(JFS_KNOWN_INCOMPAT_FEATURES);
+#endif
+
+	/* Update journal superblock on disk and wait for the IO to complete.*/
+	hfsplus_jbd_update_superblock(journal, 1);
+
+	return HFSPLUS_JOURNAL_SUCCESS;
+}
+
+hfsplus_jbd_t * hfsplus_get_dev_journal(struct super_block *sb)
+{
+	struct hfsplus_journal *jnl = &(HFSPLUS_SB(sb).jnl);
+	int start, len, blocksize;
+	hfsplus_jbd_t *journal = NULL;
+	struct hfsplus_journal_header *jh;
+
+	jnl->journal_maxblock = (jnl->jhdr->blhdr_size / sizeof(struct hfsplus_block_info)) - 1;
+	jh = (struct hfsplus_journal_header *)(HFSPLUS_SB(sb).jnl.jhdr);
+	blocksize = sb->s_blocksize;
+	start = (int)(jnl->jh_offset)/blocksize;
+	len = (int)(jh->size + jnl->jh_offset)/blocksize; 
+	jnl->journal_maxblock = 512;
+	dprint(DBG_JOURNAL, "start: %d, len: %d, blocksize: %d, journal_maxblock: %d\n", start, len, blocksize, jnl->journal_maxblock); 
+	journal = hfsplus_jbd_init_dev(sb->s_bdev, sb->s_bdev, start, len, blocksize);
+
+	if (journal) {
+		dprint(DBG_JOURNAL, "HFS+-fs: Able to create device journal\n");
+		journal->j_private = sb;
+		ll_rw_block(READ, 1, &journal->j_sb_buffer);
+		wait_on_buffer(journal->j_sb_buffer);
+		if (!buffer_uptodate(journal->j_sb_buffer)) {
+			printk(KERN_ERR "HFS+-fs: I/O error on journal device\n");
+			goto out_journal;
+		}
+
+		/* Initialize journal superblock for the first time. 
+		 * Otherwise hfsplus_jbd_load will fail. 
+		*/
+		if (hfsplus_journal_superblock_init(journal, start) == HFSPLUS_JOURNAL_SUCCESS) {
+			dprint(DBG_JOURNAL, "HFS+-fs: success in initializeing journal superblock.\n");
+		} else {
+			printk(KERN_ERR "HFS+-fs: error in initializeing journal superblock.\n");
+			goto out_journal;
+		}
+	}
+		
+	return journal;
+
+out_journal:
+	hfsplus_jbd_destroy(journal);
+	return NULL;
+}
+
+/* Caller should lock the page before calling this function */
+static int hfsplus_journalled_write_full_page(hfsplus_handle_t *hfsplus_handle, struct page *page)
+{
+	int err, ret;
+
+	ret = block_prepare_write(page, 0, PAGE_CACHE_SIZE, hfsplus_get_block);
+	if (ret) {
+		printk("%s: Error in block_prepare_write\n", __FUNCTION__);
+		return ret;
+	}
+
+	ret = hfsplus_walk_page_buffers(hfsplus_handle, page_buffers(page), 0,
+		PAGE_CACHE_SIZE, NULL, hfsplus_do_journal_get_write_access);
+
+	err = hfsplus_walk_page_buffers(hfsplus_handle, page_buffers(page), 0,
+			PAGE_CACHE_SIZE, NULL, hfsplus_commit_write_fn);
+	if (ret == 0)
+		ret = err;
+
+	return ret;
+}
+
+int hfsplus_journalled_set_page_dirty(hfsplus_handle_t *hfsplus_handle, struct page *page)
+{
+	if (hfsplus_handle->journaled != HFSPLUS_JOURNAL_PRESENT) {
+		set_page_dirty(page);
+		return HFSPLUS_JOURNAL_SUCCESS;
+	}
+
+	/* Page contains metadata or data */
+	if (page->mapping->a_ops == &hfsplus_journalled_btree_aops) {
+		if (hfsplus_handle->hcnt < hfsplus_handle->maxblock) {
+			int ret;
+
+			lock_page(page);
+			ret = hfsplus_journalled_write_full_page(hfsplus_handle, page);
+			unlock_page(page);
+			return ret;
+		} else {
+			printk("BTREE: HFS+-fs: Count exceeds (count %d, maxblock: %d)\n", hfsplus_handle->hcnt++, hfsplus_handle->maxblock);
+			set_page_dirty(page);
+			return HFSPLUS_JOURNAL_SUCCESS;
+		}
+	}
+	else if (page->mapping->a_ops == &hfsplus_journalled_aops) {
+      if (hfsplus_handle->hcnt < hfsplus_handle->maxblock) {
+         int ret;
+
+         lock_page(page);
+         ret = hfsplus_journalled_write_full_page(hfsplus_handle, page);
+         unlock_page(page);
+         return ret;
+      } else {
+			printk("HFS+-fs: Count exceeds (count %d, maxblock: %d)\n", hfsplus_handle->hcnt++, hfsplus_handle->maxblock);
+         set_page_dirty(page);
+         return HFSPLUS_JOURNAL_SUCCESS;
+      }
+   } else {
+		set_page_dirty(page);
+		return HFSPLUS_JOURNAL_SUCCESS;
+	}
+}
+
+int hfsplus_journalled_mark_inode_dirty(const char *err_fn, hfsplus_handle_t *hfsplus_handle, struct inode *inode)
+{
+	struct hfsplus_vh *vhdr;
+	int ret = 0;
+
+	if (hfsplus_handle->journaled != HFSPLUS_JOURNAL_PRESENT) {
+		mark_inode_dirty(inode);
+		return HFSPLUS_JOURNAL_SUCCESS;
+	}
+
+	dprint(DBG_JTRANS, "hfsplus_journalled_mark_inode_dirty: %lu, called from: %s\n", inode->i_ino, err_fn);
+	hfsplus_ext_write_extent(hfsplus_handle, inode);
+	if (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID) {
+		return hfsplus_cat_write_inode(hfsplus_handle, inode);
+	}
+	vhdr = HFSPLUS_SB(inode->i_sb).s_vhdr;
+	switch (inode->i_ino) {
+	case HFSPLUS_ROOT_CNID:
+		ret = hfsplus_cat_write_inode(hfsplus_handle, inode);
+		break;
+	case HFSPLUS_EXT_CNID:
+		if (vhdr->ext_file.total_size != cpu_to_be64(inode->i_size)) {
+			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
+			inode->i_sb->s_dirt = 1;
+		}
+		hfsplus_inode_write_fork(inode, &vhdr->ext_file);
+		hfs_btree_write(hfsplus_handle, HFSPLUS_SB(inode->i_sb).ext_tree);
+		break;
+	case HFSPLUS_CAT_CNID:
+		if (vhdr->cat_file.total_size != cpu_to_be64(inode->i_size)) {
+			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
+			inode->i_sb->s_dirt = 1;
+		}
+		hfsplus_inode_write_fork(inode, &vhdr->cat_file);
+		hfs_btree_write(hfsplus_handle, HFSPLUS_SB(inode->i_sb).cat_tree);
+		break;
+	case HFSPLUS_ALLOC_CNID:
+		if (vhdr->alloc_file.total_size != cpu_to_be64(inode->i_size)) {
+			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
+			inode->i_sb->s_dirt = 1;
+		}
+		hfsplus_inode_write_fork(inode, &vhdr->alloc_file);
+		break;
+	case HFSPLUS_START_CNID:
+		if (vhdr->start_file.total_size != cpu_to_be64(inode->i_size)) {
+			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
+			inode->i_sb->s_dirt = 1;
+		}
+		hfsplus_inode_write_fork(inode, &vhdr->start_file);
+		break;
+	case HFSPLUS_ATTR_CNID:
+		if (vhdr->attr_file.total_size != cpu_to_be64(inode->i_size)) {
+			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
+			inode->i_sb->s_dirt = 1;
+		}
+		hfsplus_inode_write_fork(inode, &vhdr->attr_file);
+		hfs_btree_write(hfsplus_handle, HFSPLUS_SB(inode->i_sb).attr_tree);
+		break;
+	}
+	if (ret) 
+		printk(KERN_ERR "HFS+-fs: [%s] unable to do hfsplus_journalled_mark_inode_dirty()\n", err_fn);
+	return ret;
+}
+
+void hfsplus_jhdr_checksum_calculate(hfsplus_jbd_t *journal)
+{
+	struct hfsplus_journal_header *jh = &(journal->j_superblock->mac_jh);
+
+	jh->checksum = 0;
+	jh->checksum = calc_checksum((unsigned char *)jh, sizeof(struct hfsplus_journal_header));
+}
+
+void hfsplus_journal_header_start_update(hfsplus_jbd_t *journal, unsigned long freed)
+{
+	struct super_block *sb = journal->j_private;
+	hfsplus_jbd_superblock_t *jsb = journal->j_superblock;
+	struct hfsplus_journal_header *jh = &(jsb->mac_jh);
+	__be32 mac_jh_start_blocknum = (jh->start + HFSPLUS_SB(sb).jnl.jh_offset) >> sb->s_blocksize_bits;
+
+	dprint(DBG_JCHKPT, "jh->start:%llx, jh_offset: %llx, mac_jh_start_blocknum: %x, freed: %lx, last: %lx, j_first: %lx\n", 
+		jh->start, HFSPLUS_SB(sb).jnl.jh_offset, mac_jh_start_blocknum, freed, journal->j_last, journal->j_first); 
+	if ((mac_jh_start_blocknum + freed) < journal->j_last) {
+		jh->start += freed * sb->s_blocksize;
+	}
+	else {
+		jh->start = (journal->j_first + (freed - (journal->j_last - mac_jh_start_blocknum)))*sb->s_blocksize;
+	}
+}
+
+void inline hfsplus_journal_header_end_update(hfsplus_jbd_t *journal, struct hfsplus_journal_header *jh)
+{
+	struct super_block *sb = journal->j_private;
+
+	jh->end = ((journal->j_head - journal->j_first) * sb->s_blocksize) + jh->blhdr_size;
+}
+
+void hfsplus_journal_mark_journal_empty(hfsplus_jbd_t *journal)
+{
+	struct hfsplus_journal_header *jh = &(journal->j_superblock->mac_jh);
+
+	jh->start = jh->end;
+	jh->checksum = 0;
+	jh->checksum = calc_checksum((unsigned char *)jh, sizeof(struct hfsplus_journal_header));
+}
+/* END: JBD specfic functions */
+
+
+/* Write journal header during replay */
+static int hfsplus_replay_write_journal_header(struct super_block *sb)
+{
+	struct hfsplus_journal_header *jh = (struct hfsplus_journal_header *)(HFSPLUS_SB(sb).jnl.jhdr);
+
+	jh->start = sb->s_blocksize;
+	jh->end = sb->s_blocksize;
+	jh->blhdr_size = sb->s_blocksize;
+
+	if (HFSPLUS_SB(sb).jnl.flags == HFSPLUS_JOURNAL_SWAP) {
+		swap_journal_header(jh);
+		jh->checksum = 0;
+		jh->checksum = swab32(calc_checksum((unsigned char *)jh, sizeof(struct hfsplus_journal_header)));
+	}
+	else {
+		jh->checksum = 0;
+		jh->checksum = calc_checksum((unsigned char *)jh, sizeof(struct hfsplus_journal_header));
+	}
+
+	/* Write it to disk */
+	mark_buffer_dirty(HFSPLUS_SB(sb).jnl.jh_bh);
+	sync_dirty_buffer(HFSPLUS_SB(sb).jnl.jh_bh);
+
+	if (HFSPLUS_SB(sb).jnl.flags == HFSPLUS_JOURNAL_SWAP)
+		swap_journal_header(jh);
+
+	return HFSPLUS_JOURNAL_SUCCESS;
+}
+
+static int hfsplus_write_journal_header(struct super_block *sb)
+{
+	struct hfsplus_journal_header *jh = (struct hfsplus_journal_header *)(HFSPLUS_SB(sb).jnl.jhdr);
+
+	jh->checksum = 0;
+	jh->checksum = calc_checksum((unsigned char *)jh, sizeof(struct hfsplus_journal_header));
+
+	/* Write it to disk */
+	mark_buffer_dirty(HFSPLUS_SB(sb).jnl.jh_bh);
+
+	return HFSPLUS_JOURNAL_SUCCESS;
+}
+
+/* Create journal header, journal buffer and initialize them 
+ * Assume that presence of journal is already verified
+*/
+int hfsplus_journalled_create(struct super_block *sb)
+{
+	struct hfsplus_journal_header *jhdr; 
+	u64 jibsize = be64_to_cpu(HFSPLUS_SB(sb).jnl.jibhdr->offset);
+
+	dprint(DBG_JOURNAL, "sb->s_blocksize: %lx, jibsize: %llx\n", sb->s_blocksize, jibsize);
+
+	/* Journal size is not aligned */
+	if (((jibsize >> sb->s_blocksize_bits) << sb->s_blocksize_bits) != jibsize) {
+		printk("HFS+-fs: journal size is not aligned\n");
+		return HFSPLUS_JOURNAL_FAIL;
+	}
+
+	if (map_journal_header(sb) == HFSPLUS_JOURNAL_FAIL) {
+		printk("HFS+-fs: Error in mapping journal header\n");
+		return HFSPLUS_JOURNAL_FAIL;
+	}
+
+	jhdr = (struct hfsplus_journal_header *)HFSPLUS_SB(sb).jnl.jhdr;
+
+	/* Populate journal header and write it to the disk */
+	jhdr->magic = HFSPLUS_JOURNAL_HEADER_MAGIC;
+	jhdr->endian = HFSPLUS_JOURNAL_HEADER_ENDIAN;
+	jhdr->start = sb->s_blocksize; /* First block is for journal header itself */
+	jhdr->end = sb->s_blocksize; /* Initially journal buffer is empty */
+	jhdr->size = 0x800000; /* Default size of journal log is 8MB */
+	jhdr->blhdr_size = sb->s_blocksize;
+	jhdr->jhdr_size = sb->s_blocksize; /* Assign first block for journal header */
+
+	if (jhdr->start != jhdr->end) {
+		printk("HFS+-fs: hfsplus_write_journal_header fail: Journal is not empty\n");
+		return HFSPLUS_JOURNAL_FAIL;
+	}
+
+	return hfsplus_write_journal_header(sb);
+}
+
+void hfsplus_test_block_list_header(const char *func, struct hfsplus_journal_header *jh, struct hfsplus_journal *jnl) 
+{
+	u32 start_block_number;
+	struct buffer_head *blhdr_bh = NULL;
+	struct hfsplus_blhdr *blhdr;
+	struct super_block *sb = jnl->sbp;
+
+	printk("called from %s()\n", func);
+	start_block_number = (jh->start + jnl->jh_offset) >> sb->s_blocksize_bits;
+	blhdr_bh = sb_bread(sb, start_block_number);
+	if (!blhdr_bh) {
+		printk("HFS+-fs Line=%d: Error in read\n", __LINE__);
+		return;
+	}
+	blhdr = (hfsplus_blhdr_t *)blhdr_bh->b_data;
+	if (jnl->flags == HFSPLUS_JOURNAL_SWAP)
+		swap_block_list_header(blhdr);
+	printk("start block number: %x, max_blocks: %x, num_blocks: %x, bytes_used: %x\n", start_block_number, blhdr->max_blocks, blhdr->num_blocks, blhdr->bytes_used);
+	brelse(blhdr_bh);
+}
+
+/* If the journal consists transaction then write them to disk.
+ * Return success if it brings the file system into consistent state.
+ * Otherwise return fail.
+*/
+static int hfsplus_journal_replay(struct super_block *sb)
+{
+	struct hfsplus_journal *jnl = &(HFSPLUS_SB(sb).jnl);
+	struct buffer_head *blhdr_bh = NULL, *tr_bh = NULL, *disk_bh = NULL;
+	struct hfsplus_blhdr *blhdr;
+	u32 start_sector_number, tr_sector_number, disk_sector_number, i, ret = HFSPLUS_JOURNAL_FAIL; 
+	u64 tr_offset, disk_offset;
+	struct hfsplus_journal_header *jh = (struct hfsplus_journal_header *)(HFSPLUS_SB(sb).jnl.jhdr);
+	unsigned char *tr_buf, *disk_buf;
+	__be32 bufsize;
+
+	if (jh->start == jh->end) {
+		dprint(DBG_JREPLAY, "HFS+-fs: Journal is empty, nothing to replay\n");
+		ret = hfsplus_replay_write_journal_header(sb);
+		return ret;
+	}
+
+	if ((jh->start > jh->size) || (jh->end > jh->size)) {
+		printk("HFS+-fs: Wrong start or end offset, start: %llx, end: %llx, jh_offset: %llx, size: %llx\n", jh->start, jh->end, jnl->jh_offset, jh->size);
+		return ret;
+	}
+
+	//hfsplus_test_block_list_header(__FUNCTION__, jh, jnl);
+	
+	if (jh->start == jh->size)
+		jh->start = jh->jhdr_size; 
+
+	down(&jnl->jnl_lock);
+	/* Go through each transaction */
+	while (jh->start != jh->end) {
+		if (blhdr_bh)
+			brelse(blhdr_bh);
+
+		start_sector_number = (jh->start + jnl->jh_offset) >> HFSPLUS_SECTOR_SHIFT;
+		dprint(DBG_JREPLAY, "start: %llx, start_sector_number: %x\n", jh->start, start_sector_number);
+		blhdr_bh = sb_bread512(sb, HFSPLUS_SB(sb).blockoffset + start_sector_number, blhdr);
+		if (!blhdr_bh) {
+			printk("HFS+-fs Line=%d: Error in read\n", __LINE__);
+			up(&jnl->jnl_lock);
+			return ret;
+		}
+
+		if (jnl->flags == HFSPLUS_JOURNAL_SWAP)
+			swap_block_list_header(blhdr);
+
+		dprint(DBG_JREPLAY, "HFS+-fs: num_blocks: %x, bytes_used: %x\n", blhdr->num_blocks, blhdr->bytes_used);
+		/* Point to the second block in the Volume, first block is already in block list header */
+		tr_offset = jnl->jh_offset + jh->start + jh->blhdr_size;
+
+		for (i=1; i<blhdr->num_blocks; i++) {
+			bufsize = blhdr->binfo[i].bsize;
+			disk_offset = blhdr->binfo[i].bnum << HFSPLUS_SECTOR_SHIFT;
+
+			dprint(DBG_JREPLAY, "[i:%x] bnum: %llx, bsize: %x, bufsize: %x, blocksize: %lx\n", i, blhdr->binfo[i].bnum, blhdr->binfo[i].bsize, bufsize, sb->s_blocksize);
+
+			while (bufsize > 0) {
+				/* Read one block */
+				tr_sector_number = tr_offset >> HFSPLUS_SECTOR_SHIFT; 
+				dprint(DBG_JREPLAY, "tr_sector_number: %x, tr_offset: %llx\n", tr_sector_number, tr_offset); 
+				tr_bh = sb_bread512(sb, HFSPLUS_SB(sb).blockoffset + tr_sector_number, tr_buf);
+				if (!tr_bh) {
+					printk("HFS+-fs Line=%d: Error in read\n", __LINE__);
+					if (blhdr_bh)
+						brelse(blhdr_bh);
+					up(&jnl->jnl_lock);
+					return ret;
+				}
+
+				disk_sector_number = disk_offset >> HFSPLUS_SECTOR_SHIFT;
+				dprint(DBG_JREPLAY, "disk_sector_number: %x, disk_offset: %llx, bufsize: %x\n", disk_sector_number, disk_offset, bufsize); 
+				/* Read the same sector from the Volume */
+				disk_bh = sb_bread512(sb, HFSPLUS_SB(sb).blockoffset + disk_sector_number, disk_buf);
+				if (!disk_bh) {
+					printk("HFS+-fs Line=%d: Error in read\n", __LINE__);
+					if (blhdr_bh)
+						brelse(blhdr_bh);
+					if (tr_bh)
+						brelse(tr_bh);
+					up(&jnl->jnl_lock);
+					return ret;
+				}
+
+				/* Write transaction block to the disk block in sector wise */
+				memcpy(disk_buf, tr_buf, HFSPLUS_SECTOR_SIZE);
+				mark_buffer_dirty(disk_bh);
+				sync_dirty_buffer(disk_bh);
+
+				/* Free buffer heads */
+				brelse(disk_bh);
+				brelse(tr_bh);
+
+				tr_offset += HFSPLUS_SECTOR_SIZE;
+				disk_offset += HFSPLUS_SECTOR_SIZE;
+				bufsize -= HFSPLUS_SECTOR_SIZE;
+
+				/* Check tr_offset reaches at the end of journal buffer */
+				if (tr_offset == (jnl->jh_offset + jh->size)) {
+					printk("tr_offset: %llx, jh->size: %llx, jh_offset: %llx\n", tr_offset, jh->size, jnl->jh_offset);
+					tr_offset = jnl->jh_offset + jh->jhdr_size; /* Set to the beginning of journal buffer */
+				}
+			}
+		}
+
+		/* Check position of start index, wrap around if necessary */
+		if ((jh->start + blhdr->bytes_used) < jh->size)
+			jh->start += blhdr->bytes_used;
+		else
+			jh->start = jh->jhdr_size + (jh->start + blhdr->bytes_used) - jh->size;
+	}
+
+	if (blhdr_bh)
+		brelse(blhdr_bh);
+
+	if (jh->start == jh->end) {
+		ret = hfsplus_replay_write_journal_header(sb);
+	} else {
+		printk("HFS+-fs: %s Error in journal replay\n", __func__);
+	}
+
+	/* Populate Volume Header with new values */
+	if (ret == HFSPLUS_JOURNAL_SUCCESS && HFSPLUS_SB(sb).s_vhdr) {
+		struct hfsplus_vh *vhdr = HFSPLUS_SB(sb).s_vhdr;
+		struct buffer_head *bh;
+
+		dprint(DBG_JREPLAY, "Populate Volume Header again\n");
+		HFSPLUS_SB(sb).s_vhdr->attributes |= cpu_to_be32(HFSPLUS_VOL_UNMNT);
+		mark_buffer_dirty(HFSPLUS_SB(sb).s_vhbh);
+		sync_dirty_buffer(HFSPLUS_SB(sb).s_vhbh);
+
+		if (HFSPLUS_SB(sb).s_vhbh)
+			brelse(HFSPLUS_SB(sb).s_vhbh);
+
+		bh = sb_bread512(sb, HFSPLUS_SB(sb).blockoffset + HFSPLUS_VOLHEAD_SECTOR, vhdr);
+		if (!bh) {
+			printk("HFS+-fs Line=%d: Error in read\n", __LINE__);
+			HFSPLUS_SB(sb).s_vhdr = NULL;
+			up(&jnl->jnl_lock);
+			return HFSPLUS_JOURNAL_FAIL;
+		}
+
+		/* should still be the same... */
+		if (be16_to_cpu(vhdr->signature) != HFSPLUS_VOLHEAD_SIG) {
+			printk("Volume header signature (%x) is wrong\n", be16_to_cpu(vhdr->signature));
+			brelse(bh);
+			HFSPLUS_SB(sb).s_vhdr = NULL;
+			up(&jnl->jnl_lock);
+			return HFSPLUS_JOURNAL_FAIL;
+		}
+
+		HFSPLUS_SB(sb).s_vhbh = bh;
+		HFSPLUS_SB(sb).s_vhdr = vhdr;
+	}
+
+	up(&jnl->jnl_lock);
+	return ret;
+}
+
+/* Check consistency of journal log file in hfsplus volume 
+*/
+int hfsplus_journalled_check(struct super_block *sb)
+{
+	struct hfsplus_journal_info_block *jib;
+	struct hfsplus_journal_header *jh;
+	u32 checksum, org_checksum;
+
+	print_volume_header(sb);
+
+	if (HFSPLUS_SB(sb).jnl.journaled != HFSPLUS_JOURNAL_PRESENT) {
+		printk("HFS+-fs: Journal is not present\n");
+		return HFSPLUS_JOURNAL_CONSISTENT;
+	}
+
+	jib = (struct hfsplus_journal_info_block *)(HFSPLUS_SB(sb).jnl.jibhdr);
+	dprint(DBG_JOURNAL, "HFS+-fs: be32_to_cpu(jib->flags): %x\n", be32_to_cpu(jib->flags));
+
+	/* Journal is on another volume, and the "on this volume" flag
+	* isn't set 
+	*/
+	if(be32_to_cpu(jib->flags) & HFSPLUS_JOURNAL_ON_OTHER_DEVICE &&
+		!(be32_to_cpu(jib->flags) & HFSPLUS_JOURNAL_IN_FS)) {
+		printk("HFS+-fs: Unable to access the journal.\n");
+		return HFSPLUS_JOURNAL_INCONSISTENT;
+	}
+
+	/* Journal should be created in initialization. 
+	* Mark inconsistent if the journal is still not created yet 
+	*/
+	if (be32_to_cpu(jib->flags) & HFSPLUS_JOURNAL_NEED_INIT) {
+		printk("HFS+-fs: Error, journal is not created\n");
+		return HFSPLUS_JOURNAL_INCONSISTENT;
+	}
+
+	dprint(DBG_JOURNAL, "HFS+-fs: Found Info Block and verified successfully.\n");
+	jh = (struct hfsplus_journal_header *)(HFSPLUS_SB(sb).jnl.jhdr);
+
+	org_checksum = jh->checksum;
+	jh->checksum = 0;
+
+	if (jh->magic == swab32(HFSPLUS_JOURNAL_HEADER_MAGIC)) {
+		org_checksum = swab32(org_checksum);
+		checksum = calc_checksum((unsigned char *)jh, sizeof(struct hfsplus_journal_header));
+		swap_journal_header(jh);
+		HFSPLUS_SB(sb).jnl.flags = HFSPLUS_JOURNAL_SWAP;
+	}
+	else
+		checksum = calc_checksum((unsigned char *)jh, sizeof(struct hfsplus_journal_header));
+
+	print_journal_header(jh);
+
+	/* Verify the journal header */
+	if(jh->magic != HFSPLUS_JOURNAL_HEADER_MAGIC || jh->endian != HFSPLUS_JOURNAL_HEADER_ENDIAN){
+		printk("HFS+-fs: Journal header verification failed.\n");
+		return HFSPLUS_JOURNAL_INCONSISTENT;
+	}
+
+	if (checksum != org_checksum) {
+		jh->checksum = checksum;
+		printk("HFS+-fs: Error in journal header checksum checksum: %x, org_checksum: %x\n", checksum, org_checksum);
+		return HFSPLUS_JOURNAL_INCONSISTENT;
+	}
+	jh->checksum = checksum;
+
+	dprint(DBG_JOURNAL, "HFS+-fs: No problem in magic number, endian and checksum\n");
+
+	/* Compare start to end */
+	if(jh->start == jh->end) {
+		hfsplus_replay_write_journal_header(sb);
+		/* If they're the same, we can mount, it's clean */
+		printk("HFS+-fs: Journal is empty means consistent\n");
+		return HFSPLUS_JOURNAL_CONSISTENT;
+	} else {
+		/* Replay journal and bring the file system in consistent state */
+		if (hfsplus_journal_replay(sb) == HFSPLUS_JOURNAL_FAIL) {
+			/* Unable to replay */
+			printk("HFS+-fs: Journal is non empty means inconsistent, please run fsck.hfsplus\n");
+			return HFSPLUS_JOURNAL_INCONSISTENT;
+		} else
+			dprint(DBG_JOURNAL, "HFS+-fs: Journal replay done\n");
+	}
+
+	return HFSPLUS_JOURNAL_CONSISTENT;
+}
+
+/* Check journal present or not and initialize hfsplus_journal accordingly 
+ * Assume that super block and volume header are already initialized
+*/
+void hfsplus_journalled_init(struct super_block *sb, struct hfsplus_vh *vhdr)
+{
+	struct hfsplus_journal *jnl = &(HFSPLUS_SB(sb).jnl);
+	u32 jib_flags;
+
+	jnl->journaled = !HFSPLUS_JOURNAL_PRESENT; /* Initialize as non-journaled */
+	jnl->sbp = NULL;
+	jnl->jh_bh = NULL;
+	jnl->alloc_block = be32_to_cpu(vhdr->alloc_file.extents[0].start_block);
+	jnl->ext_block = be32_to_cpu(vhdr->ext_file.extents[0].start_block);
+	jnl->catalog_block = be32_to_cpu(vhdr->cat_file.extents[0].start_block);
+	dprint(DBG_JOURNAL, "alloc_block: %x, ext_block: %x, catalog_block: %x\n", jnl->alloc_block, jnl->ext_block, jnl->catalog_block);
+
+	if (vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_JOURNALED)) {
+		dprint(DBG_JOURNAL,"HFS+-fs: Journaled filesystem\n");
+		jnl->jib_offset = be32_to_cpu(vhdr->journal_info_block);
+		/* Check the journal info block to find the block # of the journal */
+		jnl->jib_bh = sb_bread(sb, HFSPLUS_SB(sb).blockoffset + jnl->jib_offset);
+		if (!jnl->jib_bh) {
+			printk("HFS+-fs Line=%d: Error in buffer read\n", __LINE__);
+			return;
+		}
+		jnl->jibhdr = (struct hfsplus_journal_info_block *)(jnl->jib_bh->b_data);
+		jib_flags = be32_to_cpu(jnl->jibhdr->flags);
+		dprint(DBG_JOURNAL, "HFS+-fs: jib_flags: %x\n", jib_flags);
+		if ((jib_flags & HFSPLUS_JOURNAL_ON_OTHER_DEVICE) && !(jib_flags & HFSPLUS_JOURNAL_IN_FS))
+			goto init_fail;
+ 
+		dprint(DBG_JOURNAL, "HFS+-fs: jib size: %x\n", be32_to_cpu(jnl->jibhdr->size));
+		if (jib_flags & HFSPLUS_JOURNAL_NEED_INIT) {
+			dprint(DBG_JOURNAL, "HFS+-fs: Journal is not created\n");
+			if (hfsplus_journalled_create(sb) == 0) {
+				HFSPLUS_SB(sb).jnl.jibhdr->flags &= be32_to_cpu(~HFSPLUS_JOURNAL_NEED_INIT);
+				/* write it to disk */
+				mark_buffer_dirty(HFSPLUS_SB(sb).jnl.jib_bh);
+				sync_dirty_buffer(HFSPLUS_SB(sb).jnl.jib_bh);
+			} else {
+				printk("HFS+-fs: Fail to create journal\n");
+				goto init_fail;
+			}
+		}
+
+		/* Check already initialize in journal create */
+		if (jnl->jh_bh == NULL) {
+			if (map_journal_header(sb) == HFSPLUS_JOURNAL_FAIL) {
+				printk("HFS+-fs Line=%d: Error in buffer read\n", __LINE__);
+				goto init_fail; 
+			}
+		}
+
+		init_MUTEX(&jnl->jnl_lock);
+		jnl->sbp = sb;
+		jnl->flags = !HFSPLUS_JOURNAL_SWAP;
+		jnl->journaled = HFSPLUS_JOURNAL_PRESENT;
+	}
+
+	return;
+
+init_fail:
+	printk("HFS+-fs: Journal initialization fails\n");
+	if (jnl->jib_bh)
+		brelse(jnl->jib_bh);
+}
+
+/* Deinitialize journal if it is present */
+void hfsplus_journalled_deinit(struct super_block *sb)
+{
+	if (HFSPLUS_SB(sb).jnl.journaled != HFSPLUS_JOURNAL_PRESENT) {
+		return;
+	}
+
+	if (HFSPLUS_SB(sb).jnl.s_journal != NULL) {
+		hfsplus_jbd_destroy(HFSPLUS_SB(sb).jnl.s_journal);
+	}
+
+	if (HFSPLUS_SB(sb).jnl.jib_bh)
+		brelse(HFSPLUS_SB(sb).jnl.jib_bh);
+
+	if (HFSPLUS_SB(sb).jnl.jh_bh)
+		brelse(HFSPLUS_SB(sb).jnl.jh_bh);
+	
+	HFSPLUS_SB(sb).jnl.journaled = !HFSPLUS_JOURNAL_PRESENT;
+}
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/Makefile linux-2.6.32/fs/hfsplus_journal/Makefile
--- linux-2.6.32-old//fs/hfsplus_journal/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/Makefile	2011-11-17 09:00:40.788818402 -0500
@@ -0,0 +1,9 @@
+#
+## Makefile for the linux hfsplus filesystem routines.
+#
+
+obj-$(CONFIG_HFSPLUS_JOURNAL_FS) += hfsplus.o
+
+hfsplus-objs := super.o options.o inode.o ioctl.o extents.o catalog.o dir.o btree.o \
+		bnode.o brec.o bfind.o tables.o unicode.o wrapper.o bitmap.o part_tbl.o journal.o \
+		transaction.o commit.o recovery.o checkpoint.o revoke.o jbd_journal.o
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/options.c linux-2.6.32/fs/hfsplus_journal/options.c
--- linux-2.6.32-old//fs/hfsplus_journal/options.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/options.c	2011-11-17 09:00:40.788818402 -0500
@@ -0,0 +1,189 @@
+/*
+ *  linux/fs/hfsplus/options.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Option parsing
+ */
+
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/parser.h>
+#include <linux/nls.h>
+#include <linux/mount.h>
+#include <linux/seq_file.h>
+#include "hfsplus_fs.h"
+
+enum {
+	opt_creator, opt_type,
+	opt_umask, opt_uid, opt_gid,
+	opt_part, opt_session, opt_nls,
+	opt_nodecompose, opt_decompose,
+	opt_force, opt_err
+};
+
+static const match_table_t tokens = {
+	{ opt_creator, "creator=%s" },
+	{ opt_type, "type=%s" },
+	{ opt_umask, "umask=%o" },
+	{ opt_uid, "uid=%u" },
+	{ opt_gid, "gid=%u" },
+	{ opt_part, "part=%u" },
+	{ opt_session, "session=%u" },
+	{ opt_nls, "nls=%s" },
+	{ opt_decompose, "decompose" },
+	{ opt_nodecompose, "nodecompose" },
+	{ opt_force, "force" },
+	{ opt_err, NULL }
+};
+
+/* Initialize an options object to reasonable defaults */
+void hfsplus_fill_defaults(struct hfsplus_sb_info *opts)
+{
+	if (!opts)
+		return;
+
+	opts->creator = HFSPLUS_DEF_CR_TYPE;
+	opts->type = HFSPLUS_DEF_CR_TYPE;
+	opts->umask = current_umask();
+	opts->uid = current_uid();
+	opts->gid = current_gid();
+	opts->part = -1;
+	opts->session = -1;
+}
+
+/* convert a "four byte character" to a 32 bit int with error checks */
+static inline int match_fourchar(substring_t *arg, u32 *result)
+{
+	if (arg->to - arg->from != 4)
+		return -EINVAL;
+	memcpy(result, arg->from, 4);
+	return 0;
+}
+
+/* Parse options from mount. Returns 0 on failure */
+/* input is the options passed to mount() as a string */
+int hfsplus_parse_options(char *input, struct hfsplus_sb_info *sbi)
+{
+	char *p;
+	substring_t args[MAX_OPT_ARGS];
+	int tmp, token;
+
+	if (!input)
+		goto done;
+
+	while ((p = strsep(&input, ",")) != NULL) {
+		if (!*p)
+			continue;
+
+		token = match_token(p, tokens, args);
+		switch (token) {
+		case opt_creator:
+			if (match_fourchar(&args[0], &sbi->creator)) {
+				printk(KERN_ERR "hfs: creator requires a 4 character value\n");
+				return 0;
+			}
+			break;
+		case opt_type:
+			if (match_fourchar(&args[0], &sbi->type)) {
+				printk(KERN_ERR "hfs: type requires a 4 character value\n");
+				return 0;
+			}
+			break;
+		case opt_umask:
+			if (match_octal(&args[0], &tmp)) {
+				printk(KERN_ERR "hfs: umask requires a value\n");
+				return 0;
+			}
+			sbi->umask = (umode_t)tmp;
+			break;
+		case opt_uid:
+			if (match_int(&args[0], &tmp)) {
+				printk(KERN_ERR "hfs: uid requires an argument\n");
+				return 0;
+			}
+			sbi->uid = (uid_t)tmp;
+			break;
+		case opt_gid:
+			if (match_int(&args[0], &tmp)) {
+				printk(KERN_ERR "hfs: gid requires an argument\n");
+				return 0;
+			}
+			sbi->gid = (gid_t)tmp;
+			break;
+		case opt_part:
+			if (match_int(&args[0], &sbi->part)) {
+				printk(KERN_ERR "hfs: part requires an argument\n");
+				return 0;
+			}
+			break;
+		case opt_session:
+			if (match_int(&args[0], &sbi->session)) {
+				printk(KERN_ERR "hfs: session requires an argument\n");
+				return 0;
+			}
+			break;
+		case opt_nls:
+			if (sbi->nls) {
+				printk(KERN_ERR "hfs: unable to change nls mapping\n");
+				return 0;
+			}
+			p = match_strdup(&args[0]);
+			if (p)
+				sbi->nls = load_nls(p);
+			if (!sbi->nls) {
+				printk(KERN_ERR "hfs: unable to load nls mapping \"%s\"\n", p);
+				kfree(p);
+				return 0;
+			}
+			kfree(p);
+			break;
+		case opt_decompose:
+			sbi->flags &= ~HFSPLUS_SB_NODECOMPOSE;
+			break;
+		case opt_nodecompose:
+			sbi->flags |= HFSPLUS_SB_NODECOMPOSE;
+			break;
+		case opt_force:
+			sbi->flags |= HFSPLUS_SB_FORCE;
+			break;
+		default:
+			return 0;
+		}
+	}
+
+done:
+	if (!sbi->nls) {
+		/* try utf8 first, as this is the old default behaviour */
+		sbi->nls = load_nls("utf8");
+		if (!sbi->nls)
+			sbi->nls = load_nls_default();
+		if (!sbi->nls)
+			return 0;
+	}
+
+	return 1;
+}
+
+int hfsplus_show_options(struct seq_file *seq, struct vfsmount *mnt)
+{
+	struct hfsplus_sb_info *sbi = &HFSPLUS_SB(mnt->mnt_sb);
+
+	if (sbi->creator != HFSPLUS_DEF_CR_TYPE)
+		seq_printf(seq, ",creator=%.4s", (char *)&sbi->creator);
+	if (sbi->type != HFSPLUS_DEF_CR_TYPE)
+		seq_printf(seq, ",type=%.4s", (char *)&sbi->type);
+	seq_printf(seq, ",umask=%o,uid=%u,gid=%u", sbi->umask, sbi->uid, sbi->gid);
+	if (sbi->part >= 0)
+		seq_printf(seq, ",part=%u", sbi->part);
+	if (sbi->session >= 0)
+		seq_printf(seq, ",session=%u", sbi->session);
+	if (sbi->nls)
+		seq_printf(seq, ",nls=%s", sbi->nls->charset);
+	if (sbi->flags & HFSPLUS_SB_NODECOMPOSE)
+		seq_printf(seq, ",nodecompose");
+	return 0;
+}
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/part_tbl.c linux-2.6.32/fs/hfsplus_journal/part_tbl.c
--- linux-2.6.32-old//fs/hfsplus_journal/part_tbl.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/part_tbl.c	2011-11-17 09:00:40.788818402 -0500
@@ -0,0 +1,133 @@
+/*
+ * linux/fs/hfsplus/part_tbl.c
+ *
+ * Copyright (C) 1996-1997  Paul H. Hargrove
+ * This file may be distributed under the terms of the GNU General Public License.
+ *
+ * Original code to handle the new style Mac partition table based on
+ * a patch contributed by Holger Schemel (aeglos@valinor.owl.de).
+ *
+ * In function preconditions the term "valid" applied to a pointer to
+ * a structure means that the pointer is non-NULL and the structure it
+ * points to has all fields initialized to consistent values.
+ *
+ */
+
+#include "hfsplus_fs.h"
+
+/* offsets to various blocks */
+#define HFS_DD_BLK		0 /* Driver Descriptor block */
+#define HFS_PMAP_BLK		1 /* First block of partition map */
+#define HFS_MDB_BLK		2 /* Block (w/i partition) of MDB */
+
+/* magic numbers for various disk blocks */
+#define HFS_DRVR_DESC_MAGIC	0x4552 /* "ER": driver descriptor map */
+#define HFS_OLD_PMAP_MAGIC	0x5453 /* "TS": old-type partition map */
+#define HFS_NEW_PMAP_MAGIC	0x504D /* "PM": new-type partition map */
+#define HFS_SUPER_MAGIC		0x4244 /* "BD": HFS MDB (super block) */
+#define HFS_MFS_SUPER_MAGIC	0xD2D7 /* MFS MDB (super block) */
+
+/*
+ * The new style Mac partition map
+ *
+ * For each partition on the media there is a physical block (512-byte
+ * block) containing one of these structures.  These blocks are
+ * contiguous starting at block 1.
+ */
+struct new_pmap {
+	__be16	pmSig;		/* signature */
+	__be16	reSigPad;	/* padding */
+	__be32	pmMapBlkCnt;	/* partition blocks count */
+	__be32	pmPyPartStart;	/* physical block start of partition */
+	__be32	pmPartBlkCnt;	/* physical block count of partition */
+	u8	pmPartName[32];	/* (null terminated?) string
+				   giving the name of this
+				   partition */
+	u8	pmPartType[32];	/* (null terminated?) string
+				   giving the type of this
+				   partition */
+	/* a bunch more stuff we don't need */
+} __packed;
+
+/*
+ * The old style Mac partition map
+ *
+ * The partition map consists for a 2-byte signature followed by an
+ * array of these structures.  The map is terminated with an all-zero
+ * one of these.
+ */
+struct old_pmap {
+	__be16		pdSig;	/* Signature bytes */
+	struct 	old_pmap_entry {
+		__be32	pdStart;
+		__be32	pdSize;
+		__be32	pdFSID;
+	}	pdEntry[42];
+} __packed;
+
+/*
+ * hfs_part_find()
+ *
+ * Parse the partition map looking for the
+ * start and length of the 'part'th HFS partition.
+ */
+int hfs_part_find(struct super_block *sb,
+		  sector_t *part_start, sector_t *part_size)
+{
+	struct buffer_head *bh;
+	__be16 *data;
+	int i, size, res;
+
+	res = -ENOENT;
+	bh = sb_bread512(sb, *part_start + HFS_PMAP_BLK, data);
+	if (!bh)
+		return -EIO;
+
+	switch (be16_to_cpu(*data)) {
+	case HFS_OLD_PMAP_MAGIC:
+	  {
+		struct old_pmap *pm;
+		struct old_pmap_entry *p;
+
+		pm = (struct old_pmap *)bh->b_data;
+		p = pm->pdEntry;
+		size = 42;
+		for (i = 0; i < size; p++, i++) {
+			if (p->pdStart && p->pdSize &&
+			    p->pdFSID == cpu_to_be32(0x54465331)/*"TFS1"*/ &&
+			    (HFSPLUS_SB(sb).part < 0 || HFSPLUS_SB(sb).part == i)) {
+				*part_start += be32_to_cpu(p->pdStart);
+				*part_size = be32_to_cpu(p->pdSize);
+				res = 0;
+			}
+		}
+		break;
+	  }
+	case HFS_NEW_PMAP_MAGIC:
+	  {
+		struct new_pmap *pm;
+
+		pm = (struct new_pmap *)bh->b_data;
+		size = be32_to_cpu(pm->pmMapBlkCnt);
+		for (i = 0; i < size;) {
+			if (!memcmp(pm->pmPartType,"Apple_HFS", 9) &&
+			    (HFSPLUS_SB(sb).part < 0 || HFSPLUS_SB(sb).part == i)) {
+				*part_start += be32_to_cpu(pm->pmPyPartStart);
+				*part_size = be32_to_cpu(pm->pmPartBlkCnt);
+				res = 0;
+				break;
+			}
+			brelse(bh);
+			bh = sb_bread512(sb, *part_start + HFS_PMAP_BLK + ++i, pm);
+			if (!bh)
+				return -EIO;
+			if (pm->pmSig != cpu_to_be16(HFS_NEW_PMAP_MAGIC))
+				break;
+		}
+		break;
+	  }
+	}
+	brelse(bh);
+
+	return res;
+}
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/recovery.c linux-2.6.32/fs/hfsplus_journal/recovery.c
--- linux-2.6.32-old//fs/hfsplus_journal/recovery.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/recovery.c	2011-11-17 09:00:40.788818402 -0500
@@ -0,0 +1,591 @@
+/*
+ * linux/fs/recovery.c
+ * 
+ * Written by Stephen C. Tweedie <sct@redhat.com>, 1999
+ *
+ * Copyright 1999-2000 Red Hat Software --- All Rights Reserved
+ *
+ * This file is part of the Linux kernel and is made available under
+ * the terms of the GNU General Public License, version 2, or at your
+ * option, any later version, incorporated herein by reference.
+ *
+ * Journal recovery routines for the generic filesystem journaling code;
+ * part of the ext2fs journaling system.  
+ */
+
+#include <linux/time.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include "hfsplus_jbd.h"
+
+/*
+ * Maintain information about the progress of the recovery job, so that
+ * the different passes can carry information between them. 
+ */
+struct recovery_info 
+{
+	hfsplus_jbd_tid_t		start_transaction;
+	hfsplus_jbd_tid_t		end_transaction;
+
+	int		nr_replays;
+	int		nr_revokes;
+	int		nr_revoke_hits;
+};
+
+enum passtype {PASS_SCAN, PASS_REVOKE, PASS_REPLAY};
+static int do_one_pass(hfsplus_jbd_t *journal,
+				struct recovery_info *info, enum passtype pass);
+static int scan_revoke_records(hfsplus_jbd_t *, struct buffer_head *,
+				hfsplus_jbd_tid_t, struct recovery_info *);
+
+#ifdef __KERNEL__
+
+/* Release readahead buffers after use */
+static void hfsplus_jbd_brelse_array(struct buffer_head *b[], int n)
+{
+	while (--n >= 0)
+		brelse (b[n]);
+}
+
+
+/*
+ * When reading from the journal, we are going through the block device
+ * layer directly and so there is no readahead being done for us.  We
+ * need to implement any readahead ourselves if we want it to happen at
+ * all.  Recovery is basically one long sequential read, so make sure we
+ * do the IO in reasonably large chunks.
+ *
+ * This is not so critical that we need to be enormously clever about
+ * the readahead size, though.  128K is a purely arbitrary, good-enough
+ * fixed value.
+ */
+
+#define MAXBUF 8
+static int do_readahead(hfsplus_jbd_t *journal, unsigned int start)
+{
+	int err;
+	unsigned int max, nbufs, next;
+	unsigned int blocknr;
+	struct buffer_head *bh;
+
+	struct buffer_head * bufs[MAXBUF];
+
+	/* Do up to 128K of readahead */
+	max = start + (128 * 1024 / journal->j_blocksize);
+	if (max > journal->j_maxlen)
+		max = journal->j_maxlen;
+
+	/* Do the readahead itself.  We'll submit MAXBUF buffer_heads at
+	 * a time to the block device IO layer. */
+
+	nbufs = 0;
+
+	for (next = start; next < max; next++) {
+		err = hfsplus_jbd_bmap(journal, next, &blocknr);
+
+		if (err) {
+			printk (KERN_ERR "JBD: bad block at offset %u\n",
+				next);
+			goto failed;
+		}
+
+		bh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);
+		if (!bh) {
+			err = -ENOMEM;
+			goto failed;
+		}
+
+		if (!buffer_uptodate(bh) && !buffer_locked(bh)) {
+			bufs[nbufs++] = bh;
+			if (nbufs == MAXBUF) {
+				ll_rw_block(READ, nbufs, bufs);
+				hfsplus_jbd_brelse_array(bufs, nbufs);
+				nbufs = 0;
+			}
+		} else
+			brelse(bh);
+	}
+
+	if (nbufs)
+		ll_rw_block(READ, nbufs, bufs);
+	err = 0;
+
+failed:
+	if (nbufs) 
+		hfsplus_jbd_brelse_array(bufs, nbufs);
+	return err;
+}
+
+#endif /* __KERNEL__ */
+
+
+/*
+ * Read a block from the journal
+ */
+
+static int jread(struct buffer_head **bhp, hfsplus_jbd_t *journal, 
+		 unsigned int offset)
+{
+	int err;
+	unsigned int blocknr;
+	struct buffer_head *bh;
+
+	*bhp = NULL;
+
+	if (offset >= journal->j_maxlen) {
+		printk(KERN_ERR "JBD: corrupted journal superblock\n");
+		return -EIO;
+	}
+
+	err = hfsplus_jbd_bmap(journal, offset, &blocknr);
+
+	if (err) {
+		printk (KERN_ERR "JBD: bad block at offset %u\n",
+			offset);
+		return err;
+	}
+
+	bh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);
+	if (!bh)
+		return -ENOMEM;
+
+	if (!buffer_uptodate(bh)) {
+		/* If this is a brand new buffer, start readahead.
+                   Otherwise, we assume we are already reading it.  */
+		if (!buffer_req(bh))
+			do_readahead(journal, offset);
+		wait_on_buffer(bh);
+	}
+
+	if (!buffer_uptodate(bh)) {
+		printk (KERN_ERR "JBD: Failed to read block at offset %u\n",
+			offset);
+		brelse(bh);
+		return -EIO;
+	}
+
+	*bhp = bh;
+	return 0;
+}
+
+
+/*
+ * Count the number of in-use tags in a journal descriptor block.
+ */
+
+static int count_tags(struct buffer_head *bh, int size)
+{
+	char *			tagp;
+	hfsplus_jbd_block_tag_t *	tag;
+	int			nr = 0;
+
+	tagp = &bh->b_data[sizeof(hfsplus_jbd_header_t)];
+
+	while ((tagp - bh->b_data + sizeof(hfsplus_jbd_block_tag_t)) <= size) {
+		tag = (hfsplus_jbd_block_tag_t *) tagp;
+
+		nr++;
+		tagp += sizeof(hfsplus_jbd_block_tag_t);
+		if (!(tag->t_flags & cpu_to_be32(JFS_FLAG_SAME_UUID)))
+			tagp += 16;
+
+		if (tag->t_flags & cpu_to_be32(JFS_FLAG_LAST_TAG))
+			break;
+	}
+
+	return nr;
+}
+
+
+/* Make sure we wrap around the log correctly! */
+#define wrap(journal, var)						\
+do {									\
+	if (var >= (journal)->j_last)					\
+		var -= ((journal)->j_last - (journal)->j_first);	\
+} while (0)
+
+/**
+ * hfsplus_jbd_recover - recovers a on-disk journal
+ * @journal: the journal to recover
+ * 
+ * The primary function for recovering the log contents when mounting a
+ * journaled device.  
+ *
+ * Recovery is done in three passes.  In the first pass, we look for the
+ * end of the log.  In the second, we assemble the list of revoke
+ * blocks.  In the third and final pass, we replay any un-revoked blocks
+ * in the log.  
+ */
+int hfsplus_jbd_recover(hfsplus_jbd_t *journal)
+{
+	int			err, err2;
+	hfsplus_jbd_superblock_t *	sb;
+
+	struct recovery_info	info;
+
+	memset(&info, 0, sizeof(info));
+	sb = journal->j_superblock;
+
+	/* 
+	 * The journal superblock's s_start field (the current log head)
+	 * is always zero if, and only if, the journal was cleanly
+	 * unmounted.  
+	 */
+
+	if (!sb->s_start) {
+		hfsplus_jbd_debug(1, "No recovery required, last transaction %d\n",
+			  be32_to_cpu(sb->s_sequence));
+		journal->j_transaction_sequence = be32_to_cpu(sb->s_sequence) + 1;
+		return 0;
+	}
+
+	err = do_one_pass(journal, &info, PASS_SCAN);
+	if (!err)
+		err = do_one_pass(journal, &info, PASS_REVOKE);
+	if (!err)
+		err = do_one_pass(journal, &info, PASS_REPLAY);
+
+	hfsplus_jbd_debug(1, "JBD: recovery, exit status %d, "
+		  "recovered transactions %u to %u\n",
+		  err, info.start_transaction, info.end_transaction);
+	hfsplus_jbd_debug(1, "JBD: Replayed %d and revoked %d/%d blocks\n",
+		  info.nr_replays, info.nr_revoke_hits, info.nr_revokes);
+
+	/* Restart the log at the next transaction ID, thus invalidating
+	 * any existing commit records in the log. */
+	journal->j_transaction_sequence = ++info.end_transaction;
+
+	hfsplus_jbd_clear_revoke(journal);
+	err2 = sync_blockdev(journal->j_fs_dev);
+	if (!err)
+		err = err2;
+
+	return err;
+}
+
+/**
+ * hfsplus_jbd_skip_recovery - Start journal and wipe exiting records
+ * @journal: journal to startup
+ * 
+ * Locate any valid recovery information from the journal and set up the
+ * journal structures in memory to ignore it (presumably because the
+ * caller has evidence that it is out of date).  
+ * This function does'nt appear to be exorted..
+ *
+ * We perform one pass over the journal to allow us to tell the user how
+ * much recovery information is being erased, and to let us initialise
+ * the journal transaction sequence numbers to the next unused ID. 
+ */
+int hfsplus_jbd_skip_recovery(hfsplus_jbd_t *journal)
+{
+	int			err;
+	hfsplus_jbd_superblock_t *	sb;
+
+	struct recovery_info	info;
+
+	memset (&info, 0, sizeof(info));
+	sb = journal->j_superblock;
+
+	err = do_one_pass(journal, &info, PASS_SCAN);
+
+	if (err) {
+		printk(KERN_ERR "JBD: error %d scanning journal\n", err);
+		++journal->j_transaction_sequence;
+	} else {
+#ifdef CONFIG_JBD_DEBUG
+		int dropped = info.end_transaction - be32_to_cpu(sb->s_sequence);
+#endif
+		hfsplus_jbd_debug(1,
+			  "JBD: ignoring %d transaction%s from the journal.\n",
+			  dropped, (dropped == 1) ? "" : "s");
+		journal->j_transaction_sequence = ++info.end_transaction;
+	}
+
+	journal->j_tail = 0;
+	return err;
+}
+
+static int do_one_pass(hfsplus_jbd_t *journal,
+			struct recovery_info *info, enum passtype pass)
+{
+	unsigned int		first_commit_ID, next_commit_ID;
+	unsigned int		next_log_block;
+	int			err, success = 0;
+	hfsplus_jbd_superblock_t *	sb;
+	hfsplus_jbd_header_t * 	tmp;
+	struct buffer_head *	bh;
+	unsigned int		sequence;
+	int			blocktype;
+
+	/* Precompute the maximum metadata descriptors in a descriptor block */
+	int			MAX_BLOCKS_PER_DESC;
+	MAX_BLOCKS_PER_DESC = ((journal->j_blocksize-sizeof(hfsplus_jbd_header_t))
+			       / sizeof(hfsplus_jbd_block_tag_t));
+
+	/* 
+	 * First thing is to establish what we expect to find in the log
+	 * (in terms of transaction IDs), and where (in terms of log
+	 * block offsets): query the superblock.  
+	 */
+
+	sb = journal->j_superblock;
+	next_commit_ID = be32_to_cpu(sb->s_sequence);
+	next_log_block = be32_to_cpu(sb->s_start);
+
+	first_commit_ID = next_commit_ID;
+	if (pass == PASS_SCAN)
+		info->start_transaction = first_commit_ID;
+
+	hfsplus_jbd_debug(1, "Starting recovery pass %d\n", pass);
+
+	/*
+	 * Now we walk through the log, transaction by transaction,
+	 * making sure that each transaction has a commit block in the
+	 * expected place.  Each complete transaction gets replayed back
+	 * into the main filesystem. 
+	 */
+
+	while (1) {
+		int			flags;
+		char *			tagp;
+		hfsplus_jbd_block_tag_t *	tag;
+		struct buffer_head *	obh;
+		struct buffer_head *	nbh;
+
+		cond_resched();
+
+		/* If we already know where to stop the log traversal,
+		 * check right now that we haven't gone past the end of
+		 * the log. */
+
+		if (pass != PASS_SCAN)
+			if (hfsplus_tid_geq(next_commit_ID, info->end_transaction))
+				break;
+
+		hfsplus_jbd_debug(2, "Scanning for sequence ID %u at %u/%u\n",
+			  next_commit_ID, next_log_block, journal->j_last);
+
+		/* Skip over each chunk of the transaction looking
+		 * either the next descriptor block or the final commit
+		 * record. */
+
+		hfsplus_jbd_debug(3, "JBD: checking block %u\n", next_log_block);
+		err = jread(&bh, journal, next_log_block);
+		if (err)
+			goto failed;
+
+		next_log_block++;
+		wrap(journal, next_log_block);
+
+		/* What kind of buffer is it? 
+		 * 
+		 * If it is a descriptor block, check that it has the
+		 * expected sequence number.  Otherwise, we're all done
+		 * here. */
+
+		tmp = (hfsplus_jbd_header_t *)bh->b_data;
+
+		if (tmp->h_magic != cpu_to_be32(JFS_MAGIC_NUMBER)) {
+			brelse(bh);
+			break;
+		}
+
+		blocktype = be32_to_cpu(tmp->h_blocktype);
+		sequence = be32_to_cpu(tmp->h_sequence);
+		hfsplus_jbd_debug(3, "Found magic %d, sequence %d\n",
+			  blocktype, sequence);
+
+		if (sequence != next_commit_ID) {
+			brelse(bh);
+			break;
+		}
+
+		/* OK, we have a valid descriptor block which matches
+		 * all of the sequence number checks.  What are we going
+		 * to do with it?  That depends on the pass... */
+
+		switch(blocktype) {
+		case JFS_DESCRIPTOR_BLOCK:
+			/* If it is a valid descriptor block, replay it
+			 * in pass REPLAY; otherwise, just skip over the
+			 * blocks it describes. */
+			if (pass != PASS_REPLAY) {
+				next_log_block +=
+					count_tags(bh, journal->j_blocksize);
+				wrap(journal, next_log_block);
+				brelse(bh);
+				continue;
+			}
+
+			/* A descriptor block: we can now write all of
+			 * the data blocks.  Yay, useful work is finally
+			 * getting done here! */
+
+			tagp = &bh->b_data[sizeof(hfsplus_jbd_header_t)];
+			while ((tagp - bh->b_data +sizeof(hfsplus_jbd_block_tag_t))
+			       <= journal->j_blocksize) {
+				unsigned int io_block;
+
+				tag = (hfsplus_jbd_block_tag_t *) tagp;
+				flags = be32_to_cpu(tag->t_flags);
+
+				io_block = next_log_block++;
+				wrap(journal, next_log_block);
+				err = jread(&obh, journal, io_block);
+				if (err) {
+					/* Recover what we can, but
+					 * report failure at the end. */
+					success = err;
+					printk (KERN_ERR
+						"JBD: IO error %d recovering "
+						"block %u in log\n",
+						err, io_block);
+				} else {
+					unsigned int blocknr;
+
+					HFSPLUS_J_ASSERT(obh != NULL);
+					blocknr = be32_to_cpu(tag->t_blocknr);
+
+					/* If the block has been
+					 * revoked, then we're all done
+					 * here. */
+					if (hfsplus_jbd_test_revoke
+					    (journal, blocknr, 
+					     next_commit_ID)) {
+						brelse(obh);
+						++info->nr_revoke_hits;
+						goto skip_write;
+					}
+
+					/* Find a buffer for the new
+					 * data being restored */
+					nbh = __getblk(journal->j_fs_dev,
+							blocknr,
+							journal->j_blocksize);
+					if (nbh == NULL) {
+						printk(KERN_ERR 
+						       "JBD: Out of memory "
+						       "during recovery.\n");
+						err = -ENOMEM;
+						brelse(bh);
+						brelse(obh);
+						goto failed;
+					}
+
+					lock_buffer(nbh);
+					memcpy(nbh->b_data, obh->b_data,
+							journal->j_blocksize);
+					if (flags & JFS_FLAG_ESCAPE) {
+						*((__be32 *)nbh->b_data) =
+						cpu_to_be32(JFS_MAGIC_NUMBER);
+					}
+
+					HFSPLUS_BUFFER_TRACE(nbh, "marking dirty");
+					set_buffer_uptodate(nbh);
+					mark_buffer_dirty(nbh);
+					HFSPLUS_BUFFER_TRACE(nbh, "marking uptodate");
+					++info->nr_replays;
+					/* ll_rw_block(WRITE, 1, &nbh); */
+					unlock_buffer(nbh);
+					brelse(obh);
+					brelse(nbh);
+				}
+
+			skip_write:
+				tagp += sizeof(hfsplus_jbd_block_tag_t);
+				if (!(flags & JFS_FLAG_SAME_UUID))
+					tagp += 16;
+
+				if (flags & JFS_FLAG_LAST_TAG)
+					break;
+			}
+
+			brelse(bh);
+			continue;
+
+		case JFS_COMMIT_BLOCK:
+			/* Found an expected commit block: not much to
+			 * do other than move on to the next sequence
+			 * number. */
+			brelse(bh);
+			next_commit_ID++;
+			continue;
+
+		case JFS_REVOKE_BLOCK:
+			/* If we aren't in the REVOKE pass, then we can
+			 * just skip over this block. */
+			if (pass != PASS_REVOKE) {
+				brelse(bh);
+				continue;
+			}
+
+			err = scan_revoke_records(journal, bh,
+						  next_commit_ID, info);
+			brelse(bh);
+			if (err)
+				goto failed;
+			continue;
+
+		default:
+			hfsplus_jbd_debug(3, "Unrecognised magic %d, end of scan.\n",
+				  blocktype);
+			brelse(bh);
+			goto done;
+		}
+	}
+
+ done:
+	/* 
+	 * We broke out of the log scan loop: either we came to the
+	 * known end of the log or we found an unexpected block in the
+	 * log.  If the latter happened, then we know that the "current"
+	 * transaction marks the end of the valid log.
+	 */
+
+	if (pass == PASS_SCAN)
+		info->end_transaction = next_commit_ID;
+	else {
+		/* It's really bad news if different passes end up at
+		 * different places (but possible due to IO errors). */
+		if (info->end_transaction != next_commit_ID) {
+			printk (KERN_ERR "JBD: recovery pass %d ended at "
+				"transaction %u, expected %u\n",
+				pass, next_commit_ID, info->end_transaction);
+			if (!success)
+				success = -EIO;
+		}
+	}
+
+	return success;
+
+ failed:
+	return err;
+}
+
+
+/* Scan a revoke record, marking all blocks mentioned as revoked. */
+
+static int scan_revoke_records(hfsplus_jbd_t *journal, struct buffer_head *bh, 
+			       hfsplus_jbd_tid_t sequence, struct recovery_info *info)
+{
+	hfsplus_jbd_revoke_header_t *header;
+	int offset, max;
+
+	header = (hfsplus_jbd_revoke_header_t *) bh->b_data;
+	offset = sizeof(hfsplus_jbd_revoke_header_t);
+	max = be32_to_cpu(header->r_count);
+
+	while (offset < max) {
+		unsigned int blocknr;
+		int err;
+
+		blocknr = be32_to_cpu(* ((__be32 *) (bh->b_data+offset)));
+		offset += 4;
+		err = hfsplus_jbd_set_revoke(journal, blocknr, sequence);
+		if (err)
+			return err;
+		++info->nr_revokes;
+	}
+	return 0;
+}
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/revoke.c linux-2.6.32/fs/hfsplus_journal/revoke.c
--- linux-2.6.32-old//fs/hfsplus_journal/revoke.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/revoke.c	2011-11-17 09:00:40.788818402 -0500
@@ -0,0 +1,703 @@
+/*
+ * linux/fs/revoke.c
+ * 
+ * Written by Stephen C. Tweedie <sct@redhat.com>, 2000
+ *
+ * Copyright 2000 Red Hat corp --- All Rights Reserved
+ *
+ * This file is part of the Linux kernel and is made available under
+ * the terms of the GNU General Public License, version 2, or at your
+ * option, any later version, incorporated herein by reference.
+ *
+ * Journal revoke routines for the generic filesystem journaling code;
+ * part of the ext2fs journaling system.
+ *
+ * Revoke is the mechanism used to prevent old log records for deleted
+ * metadata from being replayed on top of newer data using the same
+ * blocks.  The revoke mechanism is used in two separate places:
+ * 
+ * + Commit: during commit we write the entire list of the current
+ *   transaction's revoked blocks to the journal
+ * 
+ * + Recovery: during recovery we record the transaction ID of all
+ *   revoked blocks.  If there are multiple revoke records in the log
+ *   for a single block, only the last one counts, and if there is a log
+ *   entry for a block beyond the last revoke, then that log entry still
+ *   gets replayed.
+ *
+ * We can get interactions between revokes and new log data within a
+ * single transaction:
+ *
+ * Block is revoked and then journaled:
+ *   The desired end result is the journaling of the new block, so we 
+ *   cancel the revoke before the transaction commits.
+ *
+ * Block is journaled and then revoked:
+ *   The revoke must take precedence over the write of the block, so we
+ *   need either to cancel the journal entry or to write the revoke
+ *   later in the log than the log block.  In this case, we choose the
+ *   latter: journaling a block cancels any revoke record for that block
+ *   in the current transaction, so any revoke for that block in the
+ *   transaction must have happened after the block was journaled and so
+ *   the revoke must take precedence.
+ *
+ * Block is revoked and then written as data: 
+ *   The data write is allowed to succeed, but the revoke is _not_
+ *   cancelled.  We still need to prevent old log records from
+ *   overwriting the new data.  We don't even need to clear the revoke
+ *   bit here.
+ *
+ * Revoke information on buffers is a tri-state value:
+ *
+ * RevokeValid clear:	no cached revoke status, need to look it up
+ * RevokeValid set, Revoked clear:
+ *			buffer has not been revoked, and cancel_revoke
+ *			need do nothing.
+ * RevokeValid set, Revoked set:
+ *			buffer has been revoked.  
+ *
+ * Locking rules:
+ * We keep two hash tables of revoke records. One hashtable belongs to the
+ * running transaction (is pointed to by journal->j_revoke), the other one
+ * belongs to the committing transaction. Accesses to the second hash table
+ * happen only from the kjournald and no other thread touches this table.  Also
+ * journal_switch_revoke_table() which switches which hashtable belongs to the
+ * running and which to the committing transaction is called only from
+ * kjournald. Therefore we need no locks when accessing the hashtable belonging
+ * to the committing transaction.
+ *
+ * All users operating on the hash table belonging to the running transaction
+ * have a handle to the transaction. Therefore they are safe from kjournald
+ * switching hash tables under them. For operations on the lists of entries in
+ * the hash table j_revoke_lock is used.
+ *
+ * Finally, also replay code uses the hash tables but at this moment noone else
+ * can touch them (filesystem isn't mounted yet) and hence no locking is
+ * needed.
+ */
+
+#include <linux/time.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/smp_lock.h>
+#include <linux/init.h>
+#include "hfsplus_jbd.h"
+#include <linux/bio.h>
+#include <linux/log2.h>
+
+static struct kmem_cache *hfsplus_revoke_record_cache;
+static struct kmem_cache *hfsplus_revoke_table_cache;
+
+/* Each revoke record represents one single revoked block.  During
+   journal replay, this involves recording the transaction ID of the
+   last transaction to revoke this block. */
+
+struct hfsplus_jbd_revoke_record_s 
+{
+	struct list_head  hash;
+	hfsplus_jbd_tid_t		  sequence;	/* Used for recovery only */
+	unsigned int	  blocknr;
+};
+
+
+/* The revoke table is just a simple hash table of revoke records. */
+struct hfsplus_jbd_revoke_table_s
+{
+	/* It is conceivable that we might want a larger hash table
+	 * for recovery.  Must be a power of two. */
+	int		  hash_size; 
+	int		  hash_shift; 
+	struct list_head *hash_table;
+};
+
+
+#ifdef __KERNEL__
+static void write_one_revoke_record(hfsplus_jbd_t *, hfsplus_transaction_t *,
+				    struct hfsplus_jbd_head **, int *,
+				    struct hfsplus_jbd_revoke_record_s *, int);
+static void flush_descriptor(hfsplus_jbd_t *, struct hfsplus_jbd_head *, int, int);
+#endif
+
+/* Utility functions to maintain the revoke table */
+
+/* Borrowed from buffer.c: this is a tried and tested block hash function */
+static inline int hash(hfsplus_jbd_t *journal, unsigned int block)
+{
+	struct hfsplus_jbd_revoke_table_s *table = journal->j_revoke;
+	int hash_shift = table->hash_shift;
+
+	return ((block << (hash_shift - 6)) ^
+		(block >> 13) ^
+		(block << (hash_shift - 12))) & (table->hash_size - 1);
+}
+
+static int insert_revoke_hash(hfsplus_jbd_t *journal, unsigned int blocknr,
+			      hfsplus_jbd_tid_t seq)
+{
+	struct list_head *hash_list;
+	struct hfsplus_jbd_revoke_record_s *record;
+
+repeat:
+	record = kmem_cache_alloc(hfsplus_revoke_record_cache, GFP_NOFS);
+	if (!record)
+		goto oom;
+
+	record->sequence = seq;
+	record->blocknr = blocknr;
+	hash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];
+	spin_lock(&journal->j_revoke_lock);
+	list_add(&record->hash, hash_list);
+	spin_unlock(&journal->j_revoke_lock);
+	return 0;
+
+oom:
+	if (!hfsplus_jbd_oom_retry)
+		return -ENOMEM;
+	hfsplus_jbd_debug(1, "ENOMEM in %s, retrying\n", __func__);
+	yield();
+	goto repeat;
+}
+
+/* Find a revoke record in the journal's hash table. */
+
+static struct hfsplus_jbd_revoke_record_s *find_revoke_record(hfsplus_jbd_t *journal,
+						      unsigned int blocknr)
+{
+	struct list_head *hash_list;
+	struct hfsplus_jbd_revoke_record_s *record;
+
+	hash_list = &journal->j_revoke->hash_table[hash(journal, blocknr)];
+
+	spin_lock(&journal->j_revoke_lock);
+	record = (struct hfsplus_jbd_revoke_record_s *) hash_list->next;
+	while (&(record->hash) != hash_list) {
+		if (record->blocknr == blocknr) {
+			spin_unlock(&journal->j_revoke_lock);
+			return record;
+		}
+		record = (struct hfsplus_jbd_revoke_record_s *) record->hash.next;
+	}
+	spin_unlock(&journal->j_revoke_lock);
+	return NULL;
+}
+
+int __init hfsplus_jbd_init_revoke_caches(void)
+{
+	HFSPLUS_J_ASSERT(!hfsplus_revoke_record_cache);
+	HFSPLUS_J_ASSERT(!hfsplus_revoke_table_cache);
+
+	hfsplus_revoke_record_cache = kmem_cache_create("hfsplus_jbd_revoke_record",
+					   sizeof(struct hfsplus_jbd_revoke_record_s),
+					   0,
+					   SLAB_HWCACHE_ALIGN|SLAB_TEMPORARY,
+					   NULL);
+	if (!hfsplus_revoke_record_cache)
+		goto record_cache_failure;
+
+	hfsplus_revoke_table_cache = kmem_cache_create("hfsplus_jbd_revoke_table",
+					   sizeof(struct hfsplus_jbd_revoke_table_s),
+					   0, SLAB_TEMPORARY, NULL);
+	if (!hfsplus_revoke_table_cache)
+		goto table_cache_failure;
+
+	return 0;
+
+table_cache_failure:
+	hfsplus_jbd_destroy_revoke_caches();
+record_cache_failure:
+	return -ENOMEM;
+}
+
+void hfsplus_jbd_destroy_revoke_caches(void)
+{
+	if (hfsplus_revoke_record_cache) {
+		kmem_cache_destroy(hfsplus_revoke_record_cache);
+		hfsplus_revoke_record_cache = NULL;
+	}
+	if (hfsplus_revoke_table_cache) {
+		kmem_cache_destroy(hfsplus_revoke_table_cache);
+		hfsplus_revoke_table_cache = NULL;
+	}
+}
+
+static struct hfsplus_jbd_revoke_table_s *journal_init_revoke_table(int hash_size)
+{
+	int shift = 0;
+	int tmp = hash_size;
+	struct hfsplus_jbd_revoke_table_s *table;
+
+	table = kmem_cache_alloc(hfsplus_revoke_table_cache, GFP_KERNEL);
+	if (!table)
+		goto out;
+
+	while((tmp >>= 1UL) != 0UL)
+		shift++;
+
+	table->hash_size = hash_size;
+	table->hash_shift = shift;
+	table->hash_table =
+		kmalloc(hash_size * sizeof(struct list_head), GFP_KERNEL);
+	if (!table->hash_table) {
+		kmem_cache_free(hfsplus_revoke_table_cache, table);
+		table = NULL;
+		goto out;
+	}
+
+	for (tmp = 0; tmp < hash_size; tmp++)
+		INIT_LIST_HEAD(&table->hash_table[tmp]);
+
+out:
+	return table;
+}
+
+static void journal_destroy_revoke_table(struct hfsplus_jbd_revoke_table_s *table)
+{
+	int i;
+	struct list_head *hash_list;
+
+	for (i = 0; i < table->hash_size; i++) {
+		hash_list = &table->hash_table[i];
+		HFSPLUS_J_ASSERT(list_empty(hash_list));
+	}
+
+	kfree(table->hash_table);
+	kmem_cache_free(hfsplus_revoke_table_cache, table);
+}
+
+/* Initialise the revoke table for a given journal to a given size. */
+int hfsplus_jbd_init_revoke(hfsplus_jbd_t *journal, int hash_size)
+{
+	HFSPLUS_J_ASSERT(journal->j_revoke_table[0] == NULL);
+	HFSPLUS_J_ASSERT(is_power_of_2(hash_size));
+
+	journal->j_revoke_table[0] = journal_init_revoke_table(hash_size);
+	if (!journal->j_revoke_table[0])
+		goto fail0;
+
+	journal->j_revoke_table[1] = journal_init_revoke_table(hash_size);
+	if (!journal->j_revoke_table[1])
+		goto fail1;
+
+	journal->j_revoke = journal->j_revoke_table[1];
+
+	spin_lock_init(&journal->j_revoke_lock);
+
+	return 0;
+
+fail1:
+	journal_destroy_revoke_table(journal->j_revoke_table[0]);
+fail0:
+	return -ENOMEM;
+}
+
+/* Destroy a journal's revoke table.  The table must already be empty! */
+void hfsplus_jbd_destroy_revoke(hfsplus_jbd_t *journal)
+{
+	journal->j_revoke = NULL;
+	if (journal->j_revoke_table[0])
+		journal_destroy_revoke_table(journal->j_revoke_table[0]);
+	if (journal->j_revoke_table[1])
+		journal_destroy_revoke_table(journal->j_revoke_table[1]);
+}
+
+
+#ifdef __KERNEL__
+
+/* 
+ * hfsplus_jbd_revoke: revoke a given buffer_head from the journal.  This
+ * prevents the block from being replayed during recovery if we take a
+ * crash after this current transaction commits.  Any subsequent
+ * metadata writes of the buffer in this transaction cancel the
+ * revoke.  
+ *
+ * Note that this call may block --- it is up to the caller to make
+ * sure that there are no further calls to hfsplus_jbd_write_metadata
+ * before the revoke is complete.  In ext3, this implies calling the
+ * revoke before clearing the block bitmap when we are deleting
+ * metadata. 
+ *
+ * Revoke performs a hfsplus_jbd_forget on any buffer_head passed in as a
+ * parameter, but does _not_ forget the buffer_head if the bh was only
+ * found implicitly. 
+ *
+ * bh_in may not be a journalled buffer - it may have come off
+ * the hash tables without an attached hfsplus_jbd_head.
+ *
+ * If bh_in is non-zero, hfsplus_jbd_revoke() will decrement its b_count
+ * by one.
+ */
+
+int hfsplus_jbd_revoke(hfsplus_jbd_handle_t *handle, unsigned int blocknr,
+		   struct buffer_head *bh_in)
+{
+	struct buffer_head *bh = NULL;
+	hfsplus_jbd_t *journal;
+	struct block_device *bdev;
+	int err;
+
+	might_sleep();
+	if (bh_in)
+		HFSPLUS_BUFFER_TRACE(bh_in, "enter");
+
+	journal = handle->h_transaction->t_journal;
+	if (!hfsplus_jbd_set_features(journal, 0, 0, JFS_FEATURE_INCOMPAT_REVOKE)){
+		HFSPLUS_J_ASSERT (!"Cannot set revoke feature!");
+		return -EINVAL;
+	}
+
+	bdev = journal->j_fs_dev;
+	bh = bh_in;
+
+	if (!bh) {
+		bh = __find_get_block(bdev, blocknr, journal->j_blocksize);
+		if (bh)
+			HFSPLUS_BUFFER_TRACE(bh, "found on hash");
+	}
+#ifdef JBD_EXPENSIVE_CHECKING
+	else {
+		struct buffer_head *bh2;
+
+		/* If there is a different buffer_head lying around in
+		 * memory anywhere... */
+		bh2 = __find_get_block(bdev, blocknr, journal->j_blocksize);
+		if (bh2) {
+			/* ... and it has RevokeValid status... */
+			if (bh2 != bh && buffer_revokevalid(bh2))
+				/* ...then it better be revoked too,
+				 * since it's illegal to create a revoke
+				 * record against a buffer_head which is
+				 * not marked revoked --- that would
+				 * risk missing a subsequent revoke
+				 * cancel. */
+				HFSPLUS_J_ASSERT_BH(bh2, buffer_hfsplus_jbd_revoked(bh2));
+			put_bh(bh2);
+		}
+	}
+#endif
+
+	/* We really ought not ever to revoke twice in a row without
+           first having the revoke cancelled: it's illegal to free a
+           block twice without allocating it in between! */
+	if (bh) {
+		if (!HFSPLUS_J_EXPECT_BH(bh, !buffer_hfsplus_jbd_revoked(bh),
+				 "inconsistent data on disk")) {
+			if (!bh_in)
+				brelse(bh);
+			return -EIO;
+		}
+		set_buffer_hfsplus_jbd_revoked(bh);
+		set_buffer_hfsplus_jbd_revokevalid(bh);
+		if (bh_in) {
+			HFSPLUS_BUFFER_TRACE(bh_in, "call hfsplus_jbd_forget");
+			hfsplus_jbd_forget(handle, bh_in);
+		} else {
+			HFSPLUS_BUFFER_TRACE(bh, "call brelse");
+			__brelse(bh);
+		}
+	}
+
+	hfsplus_jbd_debug(2, "insert revoke for block %u, bh_in=%p\n", blocknr, bh_in);
+	err = insert_revoke_hash(journal, blocknr,
+				handle->h_transaction->t_tid);
+	HFSPLUS_BUFFER_TRACE(bh_in, "exit");
+	return err;
+}
+
+/*
+ * Cancel an outstanding revoke.  For use only internally by the
+ * journaling code (called from hfsplus_jbd_get_write_access).
+ *
+ * We trust buffer_hfsplus_jbd_revoked() on the buffer if the buffer is already
+ * being journaled: if there is no revoke pending on the buffer, then we
+ * don't do anything here.
+ *
+ * This would break if it were possible for a buffer to be revoked and
+ * discarded, and then reallocated within the same transaction.  In such
+ * a case we would have lost the revoked bit, but when we arrived here
+ * the second time we would still have a pending revoke to cancel.  So,
+ * do not trust the Revoked bit on buffers unless RevokeValid is also
+ * set.
+ */
+int hfsplus_jbd_cancel_revoke(hfsplus_jbd_handle_t *handle, struct hfsplus_jbd_head *jh)
+{
+	struct hfsplus_jbd_revoke_record_s *record;
+	hfsplus_jbd_t *journal = handle->h_transaction->t_journal;
+	int need_cancel;
+	int did_revoke = 0;	/* akpm: debug */
+	struct buffer_head *bh = hfsplus_jh2bh(jh);
+
+	hfsplus_jbd_debug(4, "hfsplus_jbd_head %p, cancelling revoke\n", jh);
+
+	/* Is the existing Revoke bit valid?  If so, we trust it, and
+	 * only perform the full cancel if the revoke bit is set.  If
+	 * not, we can't trust the revoke bit, and we need to do the
+	 * full search for a revoke record. */
+	if (test_set_buffer_hfsplus_jbd_revokevalid(bh)) {
+		need_cancel = test_clear_buffer_hfsplus_jbd_revoked(bh);
+	} else {
+		need_cancel = 1;
+		clear_buffer_hfsplus_jbd_revoked(bh);
+	}
+
+	if (need_cancel) {
+		record = find_revoke_record(journal, bh->b_blocknr);
+		if (record) {
+			hfsplus_jbd_debug(4, "cancelled existing revoke on "
+				  "blocknr %llu\n", (unsigned long long)bh->b_blocknr);
+			spin_lock(&journal->j_revoke_lock);
+			list_del(&record->hash);
+			spin_unlock(&journal->j_revoke_lock);
+			kmem_cache_free(hfsplus_revoke_record_cache, record);
+			did_revoke = 1;
+		}
+	}
+
+#ifdef JBD_EXPENSIVE_CHECKING
+	/* There better not be one left behind by now! */
+	record = find_revoke_record(journal, bh->b_blocknr);
+	HFSPLUS_J_ASSERT_JH(jh, record == NULL);
+#endif
+
+	/* Finally, have we just cleared revoke on an unhashed
+	 * buffer_head?  If so, we'd better make sure we clear the
+	 * revoked status on any hashed alias too, otherwise the revoke
+	 * state machine will get very upset later on. */
+	if (need_cancel) {
+		struct buffer_head *bh2;
+		bh2 = __find_get_block(bh->b_bdev, bh->b_blocknr, bh->b_size);
+		if (bh2) {
+			if (bh2 != bh)
+				clear_buffer_hfsplus_jbd_revoked(bh2);
+			__brelse(bh2);
+		}
+	}
+	return did_revoke;
+}
+
+/* hfsplus_jbd_switch_revoke table select j_revoke for next transaction
+ * we do not want to suspend any processing until all revokes are
+ * written -bzzz
+ */
+void hfsplus_jbd_switch_revoke_table(hfsplus_jbd_t *journal)
+{
+	int i;
+
+	if (journal->j_revoke == journal->j_revoke_table[0])
+		journal->j_revoke = journal->j_revoke_table[1];
+	else
+		journal->j_revoke = journal->j_revoke_table[0];
+
+	for (i = 0; i < journal->j_revoke->hash_size; i++) 
+		INIT_LIST_HEAD(&journal->j_revoke->hash_table[i]);
+}
+
+/*
+ * Write revoke records to the journal for all entries in the current
+ * revoke hash, deleting the entries as we go.
+ */
+void hfsplus_jbd_write_revoke_records(hfsplus_jbd_t *journal,
+				  hfsplus_transaction_t *transaction, int write_op)
+{
+	struct hfsplus_jbd_head *descriptor;
+	struct hfsplus_jbd_revoke_record_s *record;
+	struct hfsplus_jbd_revoke_table_s *revoke;
+	struct list_head *hash_list;
+	int i, offset, count;
+
+	descriptor = NULL; 
+	offset = 0;
+	count = 0;
+
+	/* select revoke table for committing transaction */
+	revoke = journal->j_revoke == journal->j_revoke_table[0] ?
+		journal->j_revoke_table[1] : journal->j_revoke_table[0];
+
+	for (i = 0; i < revoke->hash_size; i++) {
+		hash_list = &revoke->hash_table[i];
+
+		while (!list_empty(hash_list)) {
+			record = (struct hfsplus_jbd_revoke_record_s *) 
+				hash_list->next;
+			write_one_revoke_record(journal, transaction,
+						&descriptor, &offset, 
+						record, write_op);
+			count++;
+			list_del(&record->hash);
+			kmem_cache_free(hfsplus_revoke_record_cache, record);
+		}
+	}
+	if (descriptor)
+		flush_descriptor(journal, descriptor, offset, write_op);
+	hfsplus_jbd_debug(1, "Wrote %d revoke records\n", count);
+}
+
+/* 
+ * Write out one revoke record.  We need to create a new descriptor
+ * block if the old one is full or if we have not already created one. 
+ */
+
+static void write_one_revoke_record(hfsplus_jbd_t *journal, 
+				    hfsplus_transaction_t *transaction,
+				    struct hfsplus_jbd_head **descriptorp, 
+				    int *offsetp,
+				    struct hfsplus_jbd_revoke_record_s *record,
+				    int write_op)
+{
+	struct hfsplus_jbd_head *descriptor;
+	int offset;
+	hfsplus_jbd_header_t *header;
+
+	/* If we are already aborting, this all becomes a noop.  We
+           still need to go round the loop in
+           hfsplus_jbd_write_revoke_records in order to free all of the
+           revoke records: only the IO to the journal is omitted. */
+	if (is_hfsplus_jbd_aborted(journal))
+		return;
+
+	descriptor = *descriptorp;
+	offset = *offsetp;
+
+	/* Make sure we have a descriptor with space left for the record */
+	if (descriptor) {
+		if (offset == journal->j_blocksize) {
+			flush_descriptor(journal, descriptor, offset, write_op);
+			descriptor = NULL;
+		}
+	}
+
+	if (!descriptor) {
+		descriptor = hfsplus_jbd_get_descriptor_buffer(journal);
+		if (!descriptor)
+			return;
+		header = (hfsplus_jbd_header_t *) &hfsplus_jh2bh(descriptor)->b_data[0];
+		header->h_magic     = cpu_to_be32(JFS_MAGIC_NUMBER);
+		header->h_blocktype = cpu_to_be32(JFS_REVOKE_BLOCK);
+		header->h_sequence  = cpu_to_be32(transaction->t_tid);
+
+		/* Record it so that we can wait for IO completion later */
+		HFSPLUS_JBUFFER_TRACE(descriptor, "file as HFSPLUS_BJ_LogCtl");
+		hfsplus_jbd_file_buffer(descriptor, transaction, HFSPLUS_BJ_LogCtl);
+
+		offset = sizeof(hfsplus_jbd_revoke_header_t);
+		*descriptorp = descriptor;
+	}
+
+	* ((__be32 *)(&hfsplus_jh2bh(descriptor)->b_data[offset])) = 
+		cpu_to_be32(record->blocknr);
+	offset += 4;
+	*offsetp = offset;
+}
+
+/* 
+ * Flush a revoke descriptor out to the journal.  If we are aborting,
+ * this is a noop; otherwise we are generating a buffer which needs to
+ * be waited for during commit, so it has to go onto the appropriate
+ * journal buffer list.
+ */
+
+static void flush_descriptor(hfsplus_jbd_t *journal, 
+			     struct hfsplus_jbd_head *descriptor, 
+			     int offset, int write_op)
+{
+	hfsplus_jbd_revoke_header_t *header;
+	struct buffer_head *bh = hfsplus_jh2bh(descriptor);
+
+	if (is_hfsplus_jbd_aborted(journal)) {
+		put_bh(bh);
+		return;
+	}
+
+	header = (hfsplus_jbd_revoke_header_t *) hfsplus_jh2bh(descriptor)->b_data;
+	header->r_count = cpu_to_be32(offset);
+	set_buffer_hfsplus_jbd_jwrite(bh);
+	HFSPLUS_BUFFER_TRACE(bh, "write");
+	set_buffer_dirty(bh);
+	ll_rw_block((write_op == WRITE) ? SWRITE : SWRITE_SYNC_PLUG, 1, &bh);
+}
+#endif
+
+/* 
+ * Revoke support for recovery.
+ *
+ * Recovery needs to be able to:
+ *
+ *  record all revoke records, including the tid of the latest instance
+ *  of each revoke in the journal
+ *
+ *  check whether a given block in a given transaction should be replayed
+ *  (ie. has not been revoked by a revoke record in that or a subsequent
+ *  transaction)
+ * 
+ *  empty the revoke table after recovery.
+ */
+
+/*
+ * First, setting revoke records.  We create a new revoke record for
+ * every block ever revoked in the log as we scan it for recovery, and
+ * we update the existing records if we find multiple revokes for a
+ * single block. 
+ */
+
+int hfsplus_jbd_set_revoke(hfsplus_jbd_t *journal, 
+		       unsigned int blocknr,
+		       hfsplus_jbd_tid_t sequence)
+{
+	struct hfsplus_jbd_revoke_record_s *record;
+
+	record = find_revoke_record(journal, blocknr);
+	if (record) {
+		/* If we have multiple occurrences, only record the
+		 * latest sequence number in the hashed record */
+		if (hfsplus_tid_gt(sequence, record->sequence))
+			record->sequence = sequence;
+		return 0;
+	} 
+	return insert_revoke_hash(journal, blocknr, sequence);
+}
+
+/* 
+ * Test revoke records.  For a given block referenced in the log, has
+ * that block been revoked?  A revoke record with a given transaction
+ * sequence number revokes all blocks in that transaction and earlier
+ * ones, but later transactions still need replayed.
+ */
+
+int hfsplus_jbd_test_revoke(hfsplus_jbd_t *journal, 
+			unsigned int blocknr,
+			hfsplus_jbd_tid_t sequence)
+{
+	struct hfsplus_jbd_revoke_record_s *record;
+
+	record = find_revoke_record(journal, blocknr);
+	if (!record)
+		return 0;
+	if (hfsplus_tid_gt(sequence, record->sequence))
+		return 0;
+	return 1;
+}
+
+/*
+ * Finally, once recovery is over, we need to clear the revoke table so
+ * that it can be reused by the running filesystem.
+ */
+
+void hfsplus_jbd_clear_revoke(hfsplus_jbd_t *journal)
+{
+	int i;
+	struct list_head *hash_list;
+	struct hfsplus_jbd_revoke_record_s *record;
+	struct hfsplus_jbd_revoke_table_s *revoke;
+
+	revoke = journal->j_revoke;
+
+	for (i = 0; i < revoke->hash_size; i++) {
+		hash_list = &revoke->hash_table[i];
+		while (!list_empty(hash_list)) {
+			record = (struct hfsplus_jbd_revoke_record_s*) hash_list->next;
+			list_del(&record->hash);
+			kmem_cache_free(hfsplus_revoke_record_cache, record);
+		}
+	}
+}
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/super.c linux-2.6.32/fs/hfsplus_journal/super.c
--- linux-2.6.32-old//fs/hfsplus_journal/super.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/super.c	2011-11-17 09:00:40.788818402 -0500
@@ -0,0 +1,673 @@
+/*
+ *  linux/fs/hfsplus/super.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ */
+
+//#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/vfs.h>
+#include <linux/nls.h>
+
+static struct inode *hfsplus_alloc_inode(struct super_block *sb);
+static void hfsplus_destroy_inode(struct inode *inode);
+
+#include "hfsplus_fs.h"
+
+struct inode *hfsplus_iget(struct super_block *sb, unsigned long ino)
+{
+	struct hfs_find_data fd;
+	struct hfsplus_vh *vhdr;
+	hfsplus_handle_t hfsplus_handle;
+	struct inode *inode;
+	long err = -EIO;
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	INIT_LIST_HEAD(&HFSPLUS_I(inode).open_dir_list);
+	mutex_init(&HFSPLUS_I(inode).extents_lock);
+	HFSPLUS_I(inode).flags = 0;
+	HFSPLUS_I(inode).rsrc_inode = NULL;
+	atomic_set(&HFSPLUS_I(inode).opencnt, 0);
+
+	if (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID) {
+	read_inode:
+		hfs_find_init(HFSPLUS_SB(inode->i_sb).cat_tree, &fd);
+		if (hfsplus_journal_start(__FUNCTION__, inode->i_sb, &hfsplus_handle))
+			goto bad_inode;
+		err = hfsplus_find_cat(&hfsplus_handle, inode->i_sb, inode->i_ino, &fd);
+		if (!err)
+			err = hfsplus_cat_read_inode(inode, &fd);
+		hfs_find_exit(&hfsplus_handle, &fd);
+		hfsplus_journal_stop(&hfsplus_handle);
+		if (err)
+			goto bad_inode;
+		goto done;
+	}
+	vhdr = HFSPLUS_SB(inode->i_sb).s_vhdr;
+	switch(inode->i_ino) {
+	case HFSPLUS_ROOT_CNID:
+		goto read_inode;
+	case HFSPLUS_EXT_CNID:
+		hfsplus_inode_read_fork(inode, &vhdr->ext_file);
+		if (vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_JOURNALED))
+			inode->i_mapping->a_ops = &hfsplus_journalled_btree_aops;
+		else
+			inode->i_mapping->a_ops = &hfsplus_btree_aops;
+		break;
+	case HFSPLUS_CAT_CNID:
+		hfsplus_inode_read_fork(inode, &vhdr->cat_file);
+		if (vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_JOURNALED))
+			inode->i_mapping->a_ops = &hfsplus_journalled_btree_aops;
+		else
+			inode->i_mapping->a_ops = &hfsplus_btree_aops;
+		break;
+	case HFSPLUS_ALLOC_CNID:
+		hfsplus_inode_read_fork(inode, &vhdr->alloc_file);
+		if (vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_JOURNALED))
+			inode->i_mapping->a_ops = &hfsplus_journalled_aops;
+		else
+			inode->i_mapping->a_ops = &hfsplus_aops;
+		break;
+	case HFSPLUS_START_CNID:
+		hfsplus_inode_read_fork(inode, &vhdr->start_file);
+		break;
+	case HFSPLUS_ATTR_CNID:
+		hfsplus_inode_read_fork(inode, &vhdr->attr_file);
+		if (vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_JOURNALED))
+			inode->i_mapping->a_ops = &hfsplus_journalled_btree_aops;
+		else
+			inode->i_mapping->a_ops = &hfsplus_btree_aops;
+		break;
+	default:
+		goto bad_inode;
+	}
+
+done:
+	unlock_new_inode(inode);
+	return inode;
+
+bad_inode:
+	iget_failed(inode);
+	return ERR_PTR(err);
+}
+
+static int hfsplus_write_inode(struct inode *inode, int unused)
+{
+	struct hfsplus_vh *vhdr;
+	hfsplus_handle_t hfsplus_handle;
+	int ret = 0;
+
+	if ((HFSPLUS_SB(inode->i_sb).jnl.journaled == HFSPLUS_JOURNAL_PRESENT) && 
+		((inode->i_mapping->a_ops == &hfsplus_journalled_btree_aops) || 
+		(inode->i_mapping->a_ops == &hfsplus_journalled_aops))) {
+		if (current->flags & PF_MEMALLOC)
+			return 0;
+
+		if (hfsplus_jbd_current_handle()) {
+			hfsplus_jbd_debug(0, "called recursively, non-PF_MEMALLOC!\n");
+			dump_stack();
+			return -EIO;
+ 		}
+
+		if (!unused)
+			return 0;
+
+	return hfsplus_force_commit(inode->i_sb);
+	}
+
+	dprint(DBG_INODE, "hfsplus_write_inode: %lu\n", inode->i_ino);
+	hfsplus_handle.journaled = !HFSPLUS_JOURNAL_PRESENT;
+	hfsplus_ext_write_extent(&hfsplus_handle, inode);
+	if (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID) {
+		ret = hfsplus_cat_write_inode(&hfsplus_handle, inode);
+		return ret;
+	}
+	vhdr = HFSPLUS_SB(inode->i_sb).s_vhdr;
+	switch (inode->i_ino) {
+	case HFSPLUS_ROOT_CNID:
+		ret = hfsplus_cat_write_inode(&hfsplus_handle, inode);
+		break;
+	case HFSPLUS_EXT_CNID:
+		if (vhdr->ext_file.total_size != cpu_to_be64(inode->i_size)) {
+			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
+			inode->i_sb->s_dirt = 1;
+		}
+		hfsplus_inode_write_fork(inode, &vhdr->ext_file);
+		hfs_btree_write(&hfsplus_handle, HFSPLUS_SB(inode->i_sb).ext_tree);
+		break;
+	case HFSPLUS_CAT_CNID:
+		if (vhdr->cat_file.total_size != cpu_to_be64(inode->i_size)) {
+			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
+			inode->i_sb->s_dirt = 1;
+		}
+		hfsplus_inode_write_fork(inode, &vhdr->cat_file);
+		hfs_btree_write(&hfsplus_handle, HFSPLUS_SB(inode->i_sb).cat_tree);
+		break;
+	case HFSPLUS_ALLOC_CNID:
+		if (vhdr->alloc_file.total_size != cpu_to_be64(inode->i_size)) {
+			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
+			inode->i_sb->s_dirt = 1;
+		}
+		hfsplus_inode_write_fork(inode, &vhdr->alloc_file);
+		break;
+	case HFSPLUS_START_CNID:
+		if (vhdr->start_file.total_size != cpu_to_be64(inode->i_size)) {
+			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
+			inode->i_sb->s_dirt = 1;
+		}
+		hfsplus_inode_write_fork(inode, &vhdr->start_file);
+		break;
+	case HFSPLUS_ATTR_CNID:
+		if (vhdr->attr_file.total_size != cpu_to_be64(inode->i_size)) {
+			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
+			inode->i_sb->s_dirt = 1;
+		}
+		hfsplus_inode_write_fork(inode, &vhdr->attr_file);
+		hfs_btree_write(&hfsplus_handle, HFSPLUS_SB(inode->i_sb).attr_tree);
+		break;
+	}
+	return ret;
+}
+
+static void hfsplus_clear_inode(struct inode *inode)
+{
+	dprint(DBG_INODE, "hfsplus_clear_inode: %lu\n", inode->i_ino);
+	if (HFSPLUS_IS_RSRC(inode)) {
+		HFSPLUS_I(HFSPLUS_I(inode).rsrc_inode).rsrc_inode = NULL;
+		iput(HFSPLUS_I(inode).rsrc_inode);
+	}
+}
+
+static int hfsplus_sync_fs(struct super_block *sb, int wait)
+{
+	struct hfsplus_vh *vhdr = HFSPLUS_SB(sb).s_vhdr;
+	hfsplus_handle_t hfsplus_handle;
+
+	dprint(DBG_SUPER, "hfsplus_write_super\n");
+
+	lock_super(sb);
+	sb->s_dirt = 0;
+
+	if (hfsplus_journal_start(__FUNCTION__, sb, &hfsplus_handle))
+		return 0;
+	vhdr->free_blocks = cpu_to_be32(HFSPLUS_SB(sb).free_blocks);
+	vhdr->next_alloc = cpu_to_be32(HFSPLUS_SB(sb).next_alloc);
+	vhdr->next_cnid = cpu_to_be32(HFSPLUS_SB(sb).next_cnid);
+	vhdr->folder_count = cpu_to_be32(HFSPLUS_SB(sb).folder_count);
+	vhdr->file_count = cpu_to_be32(HFSPLUS_SB(sb).file_count);
+
+	if (hfsplus_handle.journaled == HFSPLUS_JOURNAL_PRESENT) {
+		int err;
+
+		BUG_ON(!buffer_mapped(HFSPLUS_SB(sb).s_vhbh));
+
+		err = hfsplus_journal_get_write_access(__FUNCTION__, &hfsplus_handle, HFSPLUS_SB(sb).s_vhbh);
+		if (err) {
+			printk(KERN_ERR "%s: Error in journal_get_write_access\n", __FUNCTION__);
+			goto write_super_out;
+		}
+		err = hfsplus_jbd_dirty_metadata(hfsplus_handle.handle, HFSPLUS_SB(sb).s_vhbh);
+		if (err) {
+			printk(KERN_ERR "%s: Error in hfsplus_jbd_dirty_metadata\n", __FUNCTION__);
+			goto write_super_out;
+		}
+	}
+	else
+		mark_buffer_dirty(HFSPLUS_SB(sb).s_vhbh);
+	if (HFSPLUS_SB(sb).flags & HFSPLUS_SB_WRITEBACKUP) {
+		if (HFSPLUS_SB(sb).sect_count) {
+			struct buffer_head *bh;
+			u32 block, offset;
+
+			block = HFSPLUS_SB(sb).blockoffset;
+			block += (HFSPLUS_SB(sb).sect_count - 2) >> (sb->s_blocksize_bits - 9);
+			offset = ((HFSPLUS_SB(sb).sect_count - 2) << 9) & (sb->s_blocksize - 1);
+			printk(KERN_DEBUG "hfs: backup: %u,%u,%u,%u\n", HFSPLUS_SB(sb).blockoffset,
+				HFSPLUS_SB(sb).sect_count, block, offset);
+			bh = sb_bread(sb, block);
+			if (bh) {
+				vhdr = (struct hfsplus_vh *)(bh->b_data + offset);
+				if (be16_to_cpu(vhdr->signature) == HFSPLUS_VOLHEAD_SIG) {
+					memcpy(vhdr, HFSPLUS_SB(sb).s_vhdr, sizeof(*vhdr));
+					if (hfsplus_handle.journaled == HFSPLUS_JOURNAL_PRESENT)
+						hfsplus_jbd_dirty_metadata(hfsplus_handle.handle, bh);
+					else
+						mark_buffer_dirty(bh);
+					brelse(bh);
+				} else
+					printk(KERN_WARNING "hfs: backup not found!\n");
+			}
+		}
+		HFSPLUS_SB(sb).flags &= ~HFSPLUS_SB_WRITEBACKUP;
+	}
+write_super_out:
+	hfsplus_journal_stop(&hfsplus_handle);
+	unlock_super(sb);
+	return 0;
+}
+
+static void hfsplus_write_super(struct super_block *sb)
+{
+	if (!(sb->s_flags & MS_RDONLY))
+		hfsplus_sync_fs(sb, 1);
+	else
+		sb->s_dirt = 0;
+}
+
+static void hfsplus_put_super(struct super_block *sb)
+{
+	dprint(DBG_SUPER, "hfsplus_put_super\n");
+	if (!sb->s_fs_info)
+		return;
+
+	hfsplus_journalled_deinit(sb);
+	lock_kernel();
+
+	if (sb->s_dirt)
+		hfsplus_write_super(sb);
+	if (!(sb->s_flags & MS_RDONLY) && HFSPLUS_SB(sb).s_vhdr) {
+		struct hfsplus_vh *vhdr = HFSPLUS_SB(sb).s_vhdr;
+
+		vhdr->modify_date = hfsp_now2mt();
+		vhdr->attributes |= cpu_to_be32(HFSPLUS_VOL_UNMNT);
+		vhdr->attributes &= cpu_to_be32(~HFSPLUS_VOL_INCNSTNT);
+		mark_buffer_dirty(HFSPLUS_SB(sb).s_vhbh);
+		sync_dirty_buffer(HFSPLUS_SB(sb).s_vhbh);
+	}
+
+	hfs_btree_close(HFSPLUS_SB(sb).cat_tree);
+	hfs_btree_close(HFSPLUS_SB(sb).ext_tree);
+	iput(HFSPLUS_SB(sb).alloc_file);
+	iput(HFSPLUS_SB(sb).hidden_dir);
+	if (HFSPLUS_SB(sb).s_vhbh)
+		brelse(HFSPLUS_SB(sb).s_vhbh);
+	if (HFSPLUS_SB(sb).nls)
+		unload_nls(HFSPLUS_SB(sb).nls);
+	kfree(sb->s_fs_info);
+	sb->s_fs_info = NULL;
+
+	unlock_kernel();
+}
+
+static int hfsplus_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	struct super_block *sb = dentry->d_sb;
+	u64 id = huge_encode_dev(sb->s_bdev->bd_dev);
+
+	buf->f_type = HFSPLUS_SUPER_MAGIC;
+	buf->f_bsize = sb->s_blocksize;
+	buf->f_blocks = HFSPLUS_SB(sb).total_blocks << HFSPLUS_SB(sb).fs_shift;
+	buf->f_bfree = HFSPLUS_SB(sb).free_blocks << HFSPLUS_SB(sb).fs_shift;
+	buf->f_bavail = buf->f_bfree;
+	buf->f_files = 0xFFFFFFFF;
+	buf->f_ffree = 0xFFFFFFFF - HFSPLUS_SB(sb).next_cnid;
+	buf->f_fsid.val[0] = (u32)id;
+	buf->f_fsid.val[1] = (u32)(id >> 32);
+	buf->f_namelen = HFSPLUS_MAX_STRLEN;
+
+	return 0;
+}
+
+static int hfsplus_remount(struct super_block *sb, int *flags, char *data)
+{
+	if ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))
+		return 0;
+	if (!(*flags & MS_RDONLY)) {
+		struct hfsplus_vh *vhdr = HFSPLUS_SB(sb).s_vhdr;
+		struct hfsplus_sb_info sbi;
+
+		memset(&sbi, 0, sizeof(struct hfsplus_sb_info));
+		sbi.nls = HFSPLUS_SB(sb).nls;
+		if (!hfsplus_parse_options(data, &sbi))
+			return -EINVAL;
+
+		if (!(vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_UNMNT))) {
+			printk(KERN_WARNING "hfs: filesystem was not cleanly unmounted, "
+			       "running fsck.hfsplus is recommended.  leaving read-only.\n");
+			//sb->s_flags |= MS_RDONLY;
+			//*flags |= MS_RDONLY;
+		} else if (sbi.flags & HFSPLUS_SB_FORCE) {
+			/* nothing */
+		} else if (vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_SOFTLOCK)) {
+			printk(KERN_WARNING "hfs: filesystem is marked locked, leaving read-only.\n");
+			sb->s_flags |= MS_RDONLY;
+			*flags |= MS_RDONLY;
+		} else if (vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_JOURNALED)) {
+			if (hfsplus_journalled_check(sb)) {
+				printk(KERN_WARNING "hfs: filesystem is marked journaled, leaving read-only.\n");
+				sb->s_flags |= MS_RDONLY;
+				*flags |= MS_RDONLY;
+			} else
+				printk("HFS+-fs: Able to mount journaled hfsplus volume in read-write mode\n");
+		}
+	}
+	return 0;
+}
+
+static const struct super_operations hfsplus_sops = {
+	.alloc_inode	= hfsplus_alloc_inode,
+	.destroy_inode	= hfsplus_destroy_inode,
+	.write_inode	= hfsplus_write_inode,
+	.clear_inode	= hfsplus_clear_inode,
+	.put_super	= hfsplus_put_super,
+	.write_super	= hfsplus_write_super,
+	.sync_fs	= hfsplus_sync_fs,
+	.statfs		= hfsplus_statfs,
+	.remount_fs	= hfsplus_remount,
+	.show_options	= hfsplus_show_options,
+};
+
+static int hfsplus_fill_super(struct super_block *sb, void *data, int silent)
+{
+	struct hfsplus_vh *vhdr;
+	struct hfsplus_sb_info *sbi;
+	hfsplus_cat_entry entry;
+	struct hfs_find_data fd;
+	struct inode *root, *inode;
+	struct qstr str;
+	struct nls_table *nls = NULL;
+	hfsplus_handle_t hfsplus_handle;
+	int err = -EINVAL;
+
+	sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);
+	if (!sbi)
+		return -ENOMEM;
+
+	sb->s_fs_info = sbi;
+	INIT_HLIST_HEAD(&sbi->rsrc_inodes);
+	hfsplus_fill_defaults(sbi);
+	if (!hfsplus_parse_options(data, sbi)) {
+		printk(KERN_ERR "hfs: unable to parse mount options\n");
+		err = -EINVAL;
+		goto cleanup;
+	}
+
+	/* temporarily use utf8 to correctly find the hidden dir below */
+	nls = sbi->nls;
+	sbi->nls = load_nls("utf8");
+	if (!sbi->nls) {
+		printk(KERN_ERR "hfs: unable to load nls for utf8\n");
+		err = -EINVAL;
+		goto cleanup;
+	}
+
+	/* Grab the volume header */
+	if (hfsplus_read_wrapper(sb)) {
+		if (!silent)
+			printk(KERN_WARNING "hfs: unable to find HFS+ superblock\n");
+		err = -EINVAL;
+		goto cleanup;
+	}
+	vhdr = HFSPLUS_SB(sb).s_vhdr;
+
+	/* Copy parts of the volume header into the superblock */
+	sb->s_magic = HFSPLUS_VOLHEAD_SIG;
+	if (be16_to_cpu(vhdr->version) < HFSPLUS_MIN_VERSION ||
+	    be16_to_cpu(vhdr->version) > HFSPLUS_CURRENT_VERSION) {
+		printk(KERN_ERR "hfs: wrong filesystem version\n");
+		goto cleanup;
+	}
+
+	hfsplus_journalled_init(sb, vhdr);
+	HFSPLUS_SB(sb).jnl.s_journal = NULL;
+	if (HFSPLUS_SB(sb).jnl.journaled == HFSPLUS_JOURNAL_PRESENT) {
+		if (hfsplus_journalled_check(sb)) {
+			if (!silent)
+				printk("HFS+-fs: Error in journal, use the force option at your own risk, mounting read-only.\n");
+			if (HFSPLUS_SB(sb).s_vhdr == NULL) {
+				printk("HFS+-fs: Error in Volume Header\n");
+				goto cleanup;
+			}
+			sb->s_flags |= MS_RDONLY;
+		} else {
+			hfsplus_jbd_t *journal;
+
+			journal = hfsplus_get_dev_journal(sb);
+			if (journal == NULL) {
+				printk("HFS+-fs: Error in getting journal device from JBD layer\n");
+				sb->s_flags |= MS_RDONLY;
+			} else {
+				int err;
+				err = hfsplus_jbd_load(journal);
+				if (err == 0) {
+					dprint(DBG_JOURNAL, "HFS+-fs: Successfully load journal\n");
+					HFSPLUS_SB(sb).jnl.s_journal = journal;
+				} else {
+					printk("HFS+-fs: Error in loading journal\n");
+					hfsplus_jbd_destroy(journal);
+					sb->s_flags |= MS_RDONLY;
+				}
+			}
+			if (sb->s_flags & MS_RDONLY)
+				printk("HFS+-fs: Error in journal, mounting read-only.\n");
+			else
+				dprint(DBG_JOURNAL, "HFS+-fs: No problem in journal. Should be able to mount hfsplus volume in read-write mode\n");
+		}
+	}
+
+	HFSPLUS_SB(sb).total_blocks = be32_to_cpu(vhdr->total_blocks);
+	HFSPLUS_SB(sb).free_blocks = be32_to_cpu(vhdr->free_blocks);
+	HFSPLUS_SB(sb).next_alloc = be32_to_cpu(vhdr->next_alloc);
+	HFSPLUS_SB(sb).next_cnid = be32_to_cpu(vhdr->next_cnid);
+	HFSPLUS_SB(sb).file_count = be32_to_cpu(vhdr->file_count);
+	HFSPLUS_SB(sb).folder_count = be32_to_cpu(vhdr->folder_count);
+	HFSPLUS_SB(sb).data_clump_blocks = be32_to_cpu(vhdr->data_clump_sz) >> HFSPLUS_SB(sb).alloc_blksz_shift;
+	if (!HFSPLUS_SB(sb).data_clump_blocks)
+		HFSPLUS_SB(sb).data_clump_blocks = 1;
+	HFSPLUS_SB(sb).rsrc_clump_blocks = be32_to_cpu(vhdr->rsrc_clump_sz) >> HFSPLUS_SB(sb).alloc_blksz_shift;
+	if (!HFSPLUS_SB(sb).rsrc_clump_blocks)
+		HFSPLUS_SB(sb).rsrc_clump_blocks = 1;
+
+	/* Set up operations so we can load metadata */
+	sb->s_op = &hfsplus_sops;
+	sb->s_maxbytes = MAX_LFS_FILESIZE;
+
+	if (!(vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_UNMNT))) {
+		printk(KERN_WARNING "hfs: Filesystem was not cleanly unmounted, "
+		       "running fsck.hfsplus is recommended.  mounting read-only.\n");
+		//sb->s_flags |= MS_RDONLY;
+	} else 
+	if (sbi->flags & HFSPLUS_SB_FORCE) {
+		/* nothing */
+	} else if (vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_SOFTLOCK)) {
+		printk(KERN_WARNING "hfs: Filesystem is marked locked, mounting read-only.\n");
+		sb->s_flags |= MS_RDONLY;
+	}
+	//} else if ((vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_JOURNALED)) && !(sb->s_flags & MS_RDONLY)) {
+	//	printk(KERN_WARNING "hfs: write access to a journaled filesystem is not supported, "
+	//	       "use the force option at your own risk, mounting read-only.\n");
+	//	sb->s_flags |= MS_RDONLY;
+	//}
+	sbi->flags &= ~HFSPLUS_SB_FORCE;
+
+	/* Load metadata objects (B*Trees) */
+	HFSPLUS_SB(sb).ext_tree = hfs_btree_open(sb, HFSPLUS_EXT_CNID);
+	if (!HFSPLUS_SB(sb).ext_tree) {
+		printk(KERN_ERR "hfs: failed to load extents file\n");
+		goto cleanup;
+	}
+	HFSPLUS_SB(sb).cat_tree = hfs_btree_open(sb, HFSPLUS_CAT_CNID);
+	if (!HFSPLUS_SB(sb).cat_tree) {
+		printk(KERN_ERR "hfs: failed to load catalog file\n");
+		goto cleanup;
+	}
+
+	inode = hfsplus_iget(sb, HFSPLUS_ALLOC_CNID);
+	if (IS_ERR(inode)) {
+		printk(KERN_ERR "hfs: failed to load allocation file\n");
+		err = PTR_ERR(inode);
+		goto cleanup;
+	}
+	HFSPLUS_SB(sb).alloc_file = inode;
+
+	/* Load the root directory */
+	root = hfsplus_iget(sb, HFSPLUS_ROOT_CNID);
+	if (IS_ERR(root)) {
+		printk(KERN_ERR "hfs: failed to load root directory\n");
+		err = PTR_ERR(root);
+		goto cleanup;
+	}
+	sb->s_root = d_alloc_root(root);
+	if (!sb->s_root) {
+		iput(root);
+		err = -ENOMEM;
+		goto cleanup;
+	}
+	sb->s_root->d_op = &hfsplus_dentry_operations;
+
+	str.len = sizeof(HFSP_HIDDENDIR_NAME) - 1;
+	str.name = HFSP_HIDDENDIR_NAME;
+	hfs_find_init(HFSPLUS_SB(sb).cat_tree, &fd);
+	hfsplus_cat_build_key(sb, fd.search_key, HFSPLUS_ROOT_CNID, &str);
+	if (hfsplus_journal_start(__FUNCTION__, sb, &hfsplus_handle))
+		goto cleanup;
+	if (!hfs_brec_read(&hfsplus_handle, &fd, &entry, sizeof(entry))) { 
+		hfs_find_exit(&hfsplus_handle, &fd);
+		if (entry.type != cpu_to_be16(HFSPLUS_FOLDER)) {
+			hfsplus_journal_stop(&hfsplus_handle);
+			goto cleanup;
+		}
+		inode = hfsplus_iget(sb, be32_to_cpu(entry.folder.id));
+		if (IS_ERR(inode)) {
+			err = PTR_ERR(inode);
+			hfsplus_journal_stop(&hfsplus_handle);
+			goto cleanup;
+		}
+		HFSPLUS_SB(sb).hidden_dir = inode;
+		hfsplus_journal_stop(&hfsplus_handle);
+	} else {
+		hfsplus_journal_stop(&hfsplus_handle);
+		hfs_find_exit(NULL, &fd);
+	}
+
+	if (sb->s_flags & MS_RDONLY)
+		goto out;
+
+	/* H+LX == hfsplusutils, H+Lx == this driver, H+lx is unused
+	 * all three are registered with Apple for our use
+	 */
+	if (HFSPLUS_SB(sb).jnl.journaled == HFSPLUS_JOURNAL_PRESENT)
+		vhdr->last_mount_vers = cpu_to_be32(HFSP_MOUNT_JOURNALED_VERSION);
+	else
+		vhdr->last_mount_vers = cpu_to_be32(HFSP_MOUNT_VERSION);
+	vhdr->modify_date = hfsp_now2mt();
+	be32_add_cpu(&vhdr->write_count, 1);
+	vhdr->attributes &= cpu_to_be32(~HFSPLUS_VOL_UNMNT);
+	vhdr->attributes |= cpu_to_be32(HFSPLUS_VOL_INCNSTNT);
+	mark_buffer_dirty(HFSPLUS_SB(sb).s_vhbh);
+	sync_dirty_buffer(HFSPLUS_SB(sb).s_vhbh);
+
+	if (!HFSPLUS_SB(sb).hidden_dir) {
+		printk(KERN_DEBUG "hfs: create hidden dir...\n");
+		if (hfsplus_journal_start(__FUNCTION__, sb, &hfsplus_handle))
+			goto out;
+		HFSPLUS_SB(sb).hidden_dir = hfsplus_new_inode(&hfsplus_handle, sb, S_IFDIR);
+		hfsplus_create_cat(&hfsplus_handle, HFSPLUS_SB(sb).hidden_dir->i_ino, sb->s_root->d_inode,
+				   &str, HFSPLUS_SB(sb).hidden_dir);
+		hfsplus_journalled_mark_inode_dirty(__FUNCTION__, &hfsplus_handle, HFSPLUS_SB(sb).hidden_dir);
+		hfsplus_journal_stop(&hfsplus_handle);
+	}
+out:
+	unload_nls(sbi->nls);
+	sbi->nls = nls;
+	return 0;
+
+cleanup:
+	if (HFSPLUS_SB(sb).jnl.s_journal != NULL)
+		HFSPLUS_SB(sb).jnl.s_journal->j_flags |= JFS_ABORT;
+	hfsplus_put_super(sb);
+	if (nls)
+		unload_nls(nls);
+	return err;
+}
+
+MODULE_AUTHOR("Brad Boyer");
+MODULE_DESCRIPTION("Extended Macintosh Filesystem");
+MODULE_LICENSE("GPL");
+
+static struct kmem_cache *hfsplus_inode_cachep;
+
+static struct inode *hfsplus_alloc_inode(struct super_block *sb)
+{
+	struct hfsplus_inode_info *i;
+
+	i = kmem_cache_alloc(hfsplus_inode_cachep, GFP_KERNEL);
+	return i ? &i->vfs_inode : NULL;
+}
+
+static void hfsplus_destroy_inode(struct inode *inode)
+{
+	kmem_cache_free(hfsplus_inode_cachep, &HFSPLUS_I(inode));
+}
+
+#define HFSPLUS_INODE_SIZE	sizeof(struct hfsplus_inode_info)
+
+static int hfsplus_get_sb(struct file_system_type *fs_type,
+			  int flags, const char *dev_name, void *data,
+			  struct vfsmount *mnt)
+{
+	return get_sb_bdev(fs_type, flags, dev_name, data, hfsplus_fill_super,
+			   mnt);
+}
+
+static struct file_system_type hfsplus_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= "hfsplus",
+	.get_sb		= hfsplus_get_sb,
+	.kill_sb	= kill_block_super,
+	.fs_flags	= FS_REQUIRES_DEV,
+};
+
+static void hfsplus_init_once(void *p)
+{
+	struct hfsplus_inode_info *i = p;
+
+	inode_init_once(&i->vfs_inode);
+}
+
+static int __init init_hfsplus_fs(void)
+{
+	int err;
+
+	hfsplus_inode_cachep = kmem_cache_create("hfsplus_icache",
+		HFSPLUS_INODE_SIZE, 0, SLAB_HWCACHE_ALIGN,
+		hfsplus_init_once);
+	if (!hfsplus_inode_cachep)
+		return -ENOMEM;
+	err = hfsplus_jbd_init();
+	if (err) {
+		printk(KERN_ERR "Error in initializing hfsplus-jbd caches\n");
+		kmem_cache_destroy(hfsplus_inode_cachep);
+		return -ENOMEM;
+	}
+	err = register_filesystem(&hfsplus_fs_type);
+	if (err) {
+		hfsplus_jbd_exit();
+		kmem_cache_destroy(hfsplus_inode_cachep);
+	}
+	return err;
+}
+
+static void __exit exit_hfsplus_fs(void)
+{
+	unregister_filesystem(&hfsplus_fs_type);
+	hfsplus_jbd_exit();
+	kmem_cache_destroy(hfsplus_inode_cachep);
+}
+
+module_init(init_hfsplus_fs)
+module_exit(exit_hfsplus_fs)
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/tables.c linux-2.6.32/fs/hfsplus_journal/tables.c
--- linux-2.6.32-old//fs/hfsplus_journal/tables.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/tables.c	2011-11-17 09:00:40.788818402 -0500
@@ -0,0 +1,3245 @@
+/*
+ * linux/fs/hfsplus/tables.c
+ *
+ * Various data tables
+ */
+
+#include "hfsplus_fs.h"
+
+/*
+ *  Unicode case folding table taken from Apple Technote #1150
+ *  (HFS Plus Volume Format)
+ */
+
+u16 hfsplus_case_fold_table[] = {
+/*
+ *  The lower case table consists of a 256-entry high-byte table followed by
+ *  some number of 256-entry subtables. The high-byte table contains either an
+ *  offset to the subtable for characters with that high byte or zero, which
+ *  means that there are no case mappings or ignored characters in that block.
+ *  Ignored characters are mapped to zero.
+ */
+
+    // High-byte indices ( == 0 iff no case mapping and no ignorables )
+
+
+    /* 0 */ 0x0100, 0x0200, 0x0000, 0x0300, 0x0400, 0x0500, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 1 */ 0x0600, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 2 */ 0x0700, 0x0800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 3 */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 4 */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 5 */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 6 */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 7 */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 8 */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 9 */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* A */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* B */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* C */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* D */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* E */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* F */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0900, 0x0A00,
+
+    // Table 1 (for high byte 0x00)
+
+    /* 0 */ 0xFFFF, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
+            0x0008, 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F,
+    /* 1 */ 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
+            0x0018, 0x0019, 0x001A, 0x001B, 0x001C, 0x001D, 0x001E, 0x001F,
+    /* 2 */ 0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
+            0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,
+    /* 3 */ 0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
+            0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,
+    /* 4 */ 0x0040, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
+            0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
+    /* 5 */ 0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
+            0x0078, 0x0079, 0x007A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F,
+    /* 6 */ 0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
+            0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
+    /* 7 */ 0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
+            0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x007F,
+    /* 8 */ 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+            0x0088, 0x0089, 0x008A, 0x008B, 0x008C, 0x008D, 0x008E, 0x008F,
+    /* 9 */ 0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+            0x0098, 0x0099, 0x009A, 0x009B, 0x009C, 0x009D, 0x009E, 0x009F,
+    /* A */ 0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7,
+            0x00A8, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
+    /* B */ 0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
+            0x00B8, 0x00B9, 0x00BA, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF,
+    /* C */ 0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00E6, 0x00C7,
+            0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF,
+    /* D */ 0x00F0, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7,
+            0x00F8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x00DD, 0x00FE, 0x00DF,
+    /* E */ 0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7,
+            0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF,
+    /* F */ 0x00F0, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7,
+            0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x00FF,
+
+    // Table 2 (for high byte 0x01)
+
+    /* 0 */ 0x0100, 0x0101, 0x0102, 0x0103, 0x0104, 0x0105, 0x0106, 0x0107,
+            0x0108, 0x0109, 0x010A, 0x010B, 0x010C, 0x010D, 0x010E, 0x010F,
+    /* 1 */ 0x0111, 0x0111, 0x0112, 0x0113, 0x0114, 0x0115, 0x0116, 0x0117,
+            0x0118, 0x0119, 0x011A, 0x011B, 0x011C, 0x011D, 0x011E, 0x011F,
+    /* 2 */ 0x0120, 0x0121, 0x0122, 0x0123, 0x0124, 0x0125, 0x0127, 0x0127,
+            0x0128, 0x0129, 0x012A, 0x012B, 0x012C, 0x012D, 0x012E, 0x012F,
+    /* 3 */ 0x0130, 0x0131, 0x0133, 0x0133, 0x0134, 0x0135, 0x0136, 0x0137,
+            0x0138, 0x0139, 0x013A, 0x013B, 0x013C, 0x013D, 0x013E, 0x0140,
+    /* 4 */ 0x0140, 0x0142, 0x0142, 0x0143, 0x0144, 0x0145, 0x0146, 0x0147,
+            0x0148, 0x0149, 0x014B, 0x014B, 0x014C, 0x014D, 0x014E, 0x014F,
+    /* 5 */ 0x0150, 0x0151, 0x0153, 0x0153, 0x0154, 0x0155, 0x0156, 0x0157,
+            0x0158, 0x0159, 0x015A, 0x015B, 0x015C, 0x015D, 0x015E, 0x015F,
+    /* 6 */ 0x0160, 0x0161, 0x0162, 0x0163, 0x0164, 0x0165, 0x0167, 0x0167,
+            0x0168, 0x0169, 0x016A, 0x016B, 0x016C, 0x016D, 0x016E, 0x016F,
+    /* 7 */ 0x0170, 0x0171, 0x0172, 0x0173, 0x0174, 0x0175, 0x0176, 0x0177,
+            0x0178, 0x0179, 0x017A, 0x017B, 0x017C, 0x017D, 0x017E, 0x017F,
+    /* 8 */ 0x0180, 0x0253, 0x0183, 0x0183, 0x0185, 0x0185, 0x0254, 0x0188,
+            0x0188, 0x0256, 0x0257, 0x018C, 0x018C, 0x018D, 0x01DD, 0x0259,
+    /* 9 */ 0x025B, 0x0192, 0x0192, 0x0260, 0x0263, 0x0195, 0x0269, 0x0268,
+            0x0199, 0x0199, 0x019A, 0x019B, 0x026F, 0x0272, 0x019E, 0x0275,
+    /* A */ 0x01A0, 0x01A1, 0x01A3, 0x01A3, 0x01A5, 0x01A5, 0x01A6, 0x01A8,
+            0x01A8, 0x0283, 0x01AA, 0x01AB, 0x01AD, 0x01AD, 0x0288, 0x01AF,
+    /* B */ 0x01B0, 0x028A, 0x028B, 0x01B4, 0x01B4, 0x01B6, 0x01B6, 0x0292,
+            0x01B9, 0x01B9, 0x01BA, 0x01BB, 0x01BD, 0x01BD, 0x01BE, 0x01BF,
+    /* C */ 0x01C0, 0x01C1, 0x01C2, 0x01C3, 0x01C6, 0x01C6, 0x01C6, 0x01C9,
+            0x01C9, 0x01C9, 0x01CC, 0x01CC, 0x01CC, 0x01CD, 0x01CE, 0x01CF,
+    /* D */ 0x01D0, 0x01D1, 0x01D2, 0x01D3, 0x01D4, 0x01D5, 0x01D6, 0x01D7,
+            0x01D8, 0x01D9, 0x01DA, 0x01DB, 0x01DC, 0x01DD, 0x01DE, 0x01DF,
+    /* E */ 0x01E0, 0x01E1, 0x01E2, 0x01E3, 0x01E5, 0x01E5, 0x01E6, 0x01E7,
+            0x01E8, 0x01E9, 0x01EA, 0x01EB, 0x01EC, 0x01ED, 0x01EE, 0x01EF,
+    /* F */ 0x01F0, 0x01F3, 0x01F3, 0x01F3, 0x01F4, 0x01F5, 0x01F6, 0x01F7,
+            0x01F8, 0x01F9, 0x01FA, 0x01FB, 0x01FC, 0x01FD, 0x01FE, 0x01FF,
+
+    // Table 3 (for high byte 0x03)
+
+    /* 0 */ 0x0300, 0x0301, 0x0302, 0x0303, 0x0304, 0x0305, 0x0306, 0x0307,
+            0x0308, 0x0309, 0x030A, 0x030B, 0x030C, 0x030D, 0x030E, 0x030F,
+    /* 1 */ 0x0310, 0x0311, 0x0312, 0x0313, 0x0314, 0x0315, 0x0316, 0x0317,
+            0x0318, 0x0319, 0x031A, 0x031B, 0x031C, 0x031D, 0x031E, 0x031F,
+    /* 2 */ 0x0320, 0x0321, 0x0322, 0x0323, 0x0324, 0x0325, 0x0326, 0x0327,
+            0x0328, 0x0329, 0x032A, 0x032B, 0x032C, 0x032D, 0x032E, 0x032F,
+    /* 3 */ 0x0330, 0x0331, 0x0332, 0x0333, 0x0334, 0x0335, 0x0336, 0x0337,
+            0x0338, 0x0339, 0x033A, 0x033B, 0x033C, 0x033D, 0x033E, 0x033F,
+    /* 4 */ 0x0340, 0x0341, 0x0342, 0x0343, 0x0344, 0x0345, 0x0346, 0x0347,
+            0x0348, 0x0349, 0x034A, 0x034B, 0x034C, 0x034D, 0x034E, 0x034F,
+    /* 5 */ 0x0350, 0x0351, 0x0352, 0x0353, 0x0354, 0x0355, 0x0356, 0x0357,
+            0x0358, 0x0359, 0x035A, 0x035B, 0x035C, 0x035D, 0x035E, 0x035F,
+    /* 6 */ 0x0360, 0x0361, 0x0362, 0x0363, 0x0364, 0x0365, 0x0366, 0x0367,
+            0x0368, 0x0369, 0x036A, 0x036B, 0x036C, 0x036D, 0x036E, 0x036F,
+    /* 7 */ 0x0370, 0x0371, 0x0372, 0x0373, 0x0374, 0x0375, 0x0376, 0x0377,
+            0x0378, 0x0379, 0x037A, 0x037B, 0x037C, 0x037D, 0x037E, 0x037F,
+    /* 8 */ 0x0380, 0x0381, 0x0382, 0x0383, 0x0384, 0x0385, 0x0386, 0x0387,
+            0x0388, 0x0389, 0x038A, 0x038B, 0x038C, 0x038D, 0x038E, 0x038F,
+    /* 9 */ 0x0390, 0x03B1, 0x03B2, 0x03B3, 0x03B4, 0x03B5, 0x03B6, 0x03B7,
+            0x03B8, 0x03B9, 0x03BA, 0x03BB, 0x03BC, 0x03BD, 0x03BE, 0x03BF,
+    /* A */ 0x03C0, 0x03C1, 0x03A2, 0x03C3, 0x03C4, 0x03C5, 0x03C6, 0x03C7,
+            0x03C8, 0x03C9, 0x03AA, 0x03AB, 0x03AC, 0x03AD, 0x03AE, 0x03AF,
+    /* B */ 0x03B0, 0x03B1, 0x03B2, 0x03B3, 0x03B4, 0x03B5, 0x03B6, 0x03B7,
+            0x03B8, 0x03B9, 0x03BA, 0x03BB, 0x03BC, 0x03BD, 0x03BE, 0x03BF,
+    /* C */ 0x03C0, 0x03C1, 0x03C2, 0x03C3, 0x03C4, 0x03C5, 0x03C6, 0x03C7,
+            0x03C8, 0x03C9, 0x03CA, 0x03CB, 0x03CC, 0x03CD, 0x03CE, 0x03CF,
+    /* D */ 0x03D0, 0x03D1, 0x03D2, 0x03D3, 0x03D4, 0x03D5, 0x03D6, 0x03D7,
+            0x03D8, 0x03D9, 0x03DA, 0x03DB, 0x03DC, 0x03DD, 0x03DE, 0x03DF,
+    /* E */ 0x03E0, 0x03E1, 0x03E3, 0x03E3, 0x03E5, 0x03E5, 0x03E7, 0x03E7,
+            0x03E9, 0x03E9, 0x03EB, 0x03EB, 0x03ED, 0x03ED, 0x03EF, 0x03EF,
+    /* F */ 0x03F0, 0x03F1, 0x03F2, 0x03F3, 0x03F4, 0x03F5, 0x03F6, 0x03F7,
+            0x03F8, 0x03F9, 0x03FA, 0x03FB, 0x03FC, 0x03FD, 0x03FE, 0x03FF,
+
+    // Table 4 (for high byte 0x04)
+
+    /* 0 */ 0x0400, 0x0401, 0x0452, 0x0403, 0x0454, 0x0455, 0x0456, 0x0407,
+            0x0458, 0x0459, 0x045A, 0x045B, 0x040C, 0x040D, 0x040E, 0x045F,
+    /* 1 */ 0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437,
+            0x0438, 0x0419, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F,
+    /* 2 */ 0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447,
+            0x0448, 0x0449, 0x044A, 0x044B, 0x044C, 0x044D, 0x044E, 0x044F,
+    /* 3 */ 0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437,
+            0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F,
+    /* 4 */ 0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447,
+            0x0448, 0x0449, 0x044A, 0x044B, 0x044C, 0x044D, 0x044E, 0x044F,
+    /* 5 */ 0x0450, 0x0451, 0x0452, 0x0453, 0x0454, 0x0455, 0x0456, 0x0457,
+            0x0458, 0x0459, 0x045A, 0x045B, 0x045C, 0x045D, 0x045E, 0x045F,
+    /* 6 */ 0x0461, 0x0461, 0x0463, 0x0463, 0x0465, 0x0465, 0x0467, 0x0467,
+            0x0469, 0x0469, 0x046B, 0x046B, 0x046D, 0x046D, 0x046F, 0x046F,
+    /* 7 */ 0x0471, 0x0471, 0x0473, 0x0473, 0x0475, 0x0475, 0x0476, 0x0477,
+            0x0479, 0x0479, 0x047B, 0x047B, 0x047D, 0x047D, 0x047F, 0x047F,
+    /* 8 */ 0x0481, 0x0481, 0x0482, 0x0483, 0x0484, 0x0485, 0x0486, 0x0487,
+            0x0488, 0x0489, 0x048A, 0x048B, 0x048C, 0x048D, 0x048E, 0x048F,
+    /* 9 */ 0x0491, 0x0491, 0x0493, 0x0493, 0x0495, 0x0495, 0x0497, 0x0497,
+            0x0499, 0x0499, 0x049B, 0x049B, 0x049D, 0x049D, 0x049F, 0x049F,
+    /* A */ 0x04A1, 0x04A1, 0x04A3, 0x04A3, 0x04A5, 0x04A5, 0x04A7, 0x04A7,
+            0x04A9, 0x04A9, 0x04AB, 0x04AB, 0x04AD, 0x04AD, 0x04AF, 0x04AF,
+    /* B */ 0x04B1, 0x04B1, 0x04B3, 0x04B3, 0x04B5, 0x04B5, 0x04B7, 0x04B7,
+            0x04B9, 0x04B9, 0x04BB, 0x04BB, 0x04BD, 0x04BD, 0x04BF, 0x04BF,
+    /* C */ 0x04C0, 0x04C1, 0x04C2, 0x04C4, 0x04C4, 0x04C5, 0x04C6, 0x04C8,
+            0x04C8, 0x04C9, 0x04CA, 0x04CC, 0x04CC, 0x04CD, 0x04CE, 0x04CF,
+    /* D */ 0x04D0, 0x04D1, 0x04D2, 0x04D3, 0x04D4, 0x04D5, 0x04D6, 0x04D7,
+            0x04D8, 0x04D9, 0x04DA, 0x04DB, 0x04DC, 0x04DD, 0x04DE, 0x04DF,
+    /* E */ 0x04E0, 0x04E1, 0x04E2, 0x04E3, 0x04E4, 0x04E5, 0x04E6, 0x04E7,
+            0x04E8, 0x04E9, 0x04EA, 0x04EB, 0x04EC, 0x04ED, 0x04EE, 0x04EF,
+    /* F */ 0x04F0, 0x04F1, 0x04F2, 0x04F3, 0x04F4, 0x04F5, 0x04F6, 0x04F7,
+            0x04F8, 0x04F9, 0x04FA, 0x04FB, 0x04FC, 0x04FD, 0x04FE, 0x04FF,
+
+    // Table 5 (for high byte 0x05)
+
+    /* 0 */ 0x0500, 0x0501, 0x0502, 0x0503, 0x0504, 0x0505, 0x0506, 0x0507,
+            0x0508, 0x0509, 0x050A, 0x050B, 0x050C, 0x050D, 0x050E, 0x050F,
+    /* 1 */ 0x0510, 0x0511, 0x0512, 0x0513, 0x0514, 0x0515, 0x0516, 0x0517,
+            0x0518, 0x0519, 0x051A, 0x051B, 0x051C, 0x051D, 0x051E, 0x051F,
+    /* 2 */ 0x0520, 0x0521, 0x0522, 0x0523, 0x0524, 0x0525, 0x0526, 0x0527,
+            0x0528, 0x0529, 0x052A, 0x052B, 0x052C, 0x052D, 0x052E, 0x052F,
+    /* 3 */ 0x0530, 0x0561, 0x0562, 0x0563, 0x0564, 0x0565, 0x0566, 0x0567,
+            0x0568, 0x0569, 0x056A, 0x056B, 0x056C, 0x056D, 0x056E, 0x056F,
+    /* 4 */ 0x0570, 0x0571, 0x0572, 0x0573, 0x0574, 0x0575, 0x0576, 0x0577,
+            0x0578, 0x0579, 0x057A, 0x057B, 0x057C, 0x057D, 0x057E, 0x057F,
+    /* 5 */ 0x0580, 0x0581, 0x0582, 0x0583, 0x0584, 0x0585, 0x0586, 0x0557,
+            0x0558, 0x0559, 0x055A, 0x055B, 0x055C, 0x055D, 0x055E, 0x055F,
+    /* 6 */ 0x0560, 0x0561, 0x0562, 0x0563, 0x0564, 0x0565, 0x0566, 0x0567,
+            0x0568, 0x0569, 0x056A, 0x056B, 0x056C, 0x056D, 0x056E, 0x056F,
+    /* 7 */ 0x0570, 0x0571, 0x0572, 0x0573, 0x0574, 0x0575, 0x0576, 0x0577,
+            0x0578, 0x0579, 0x057A, 0x057B, 0x057C, 0x057D, 0x057E, 0x057F,
+    /* 8 */ 0x0580, 0x0581, 0x0582, 0x0583, 0x0584, 0x0585, 0x0586, 0x0587,
+            0x0588, 0x0589, 0x058A, 0x058B, 0x058C, 0x058D, 0x058E, 0x058F,
+    /* 9 */ 0x0590, 0x0591, 0x0592, 0x0593, 0x0594, 0x0595, 0x0596, 0x0597,
+            0x0598, 0x0599, 0x059A, 0x059B, 0x059C, 0x059D, 0x059E, 0x059F,
+    /* A */ 0x05A0, 0x05A1, 0x05A2, 0x05A3, 0x05A4, 0x05A5, 0x05A6, 0x05A7,
+            0x05A8, 0x05A9, 0x05AA, 0x05AB, 0x05AC, 0x05AD, 0x05AE, 0x05AF,
+    /* B */ 0x05B0, 0x05B1, 0x05B2, 0x05B3, 0x05B4, 0x05B5, 0x05B6, 0x05B7,
+            0x05B8, 0x05B9, 0x05BA, 0x05BB, 0x05BC, 0x05BD, 0x05BE, 0x05BF,
+    /* C */ 0x05C0, 0x05C1, 0x05C2, 0x05C3, 0x05C4, 0x05C5, 0x05C6, 0x05C7,
+            0x05C8, 0x05C9, 0x05CA, 0x05CB, 0x05CC, 0x05CD, 0x05CE, 0x05CF,
+    /* D */ 0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7,
+            0x05D8, 0x05D9, 0x05DA, 0x05DB, 0x05DC, 0x05DD, 0x05DE, 0x05DF,
+    /* E */ 0x05E0, 0x05E1, 0x05E2, 0x05E3, 0x05E4, 0x05E5, 0x05E6, 0x05E7,
+            0x05E8, 0x05E9, 0x05EA, 0x05EB, 0x05EC, 0x05ED, 0x05EE, 0x05EF,
+    /* F */ 0x05F0, 0x05F1, 0x05F2, 0x05F3, 0x05F4, 0x05F5, 0x05F6, 0x05F7,
+            0x05F8, 0x05F9, 0x05FA, 0x05FB, 0x05FC, 0x05FD, 0x05FE, 0x05FF,
+
+    // Table 6 (for high byte 0x10)
+
+    /* 0 */ 0x1000, 0x1001, 0x1002, 0x1003, 0x1004, 0x1005, 0x1006, 0x1007,
+            0x1008, 0x1009, 0x100A, 0x100B, 0x100C, 0x100D, 0x100E, 0x100F,
+    /* 1 */ 0x1010, 0x1011, 0x1012, 0x1013, 0x1014, 0x1015, 0x1016, 0x1017,
+            0x1018, 0x1019, 0x101A, 0x101B, 0x101C, 0x101D, 0x101E, 0x101F,
+    /* 2 */ 0x1020, 0x1021, 0x1022, 0x1023, 0x1024, 0x1025, 0x1026, 0x1027,
+            0x1028, 0x1029, 0x102A, 0x102B, 0x102C, 0x102D, 0x102E, 0x102F,
+    /* 3 */ 0x1030, 0x1031, 0x1032, 0x1033, 0x1034, 0x1035, 0x1036, 0x1037,
+            0x1038, 0x1039, 0x103A, 0x103B, 0x103C, 0x103D, 0x103E, 0x103F,
+    /* 4 */ 0x1040, 0x1041, 0x1042, 0x1043, 0x1044, 0x1045, 0x1046, 0x1047,
+            0x1048, 0x1049, 0x104A, 0x104B, 0x104C, 0x104D, 0x104E, 0x104F,
+    /* 5 */ 0x1050, 0x1051, 0x1052, 0x1053, 0x1054, 0x1055, 0x1056, 0x1057,
+            0x1058, 0x1059, 0x105A, 0x105B, 0x105C, 0x105D, 0x105E, 0x105F,
+    /* 6 */ 0x1060, 0x1061, 0x1062, 0x1063, 0x1064, 0x1065, 0x1066, 0x1067,
+            0x1068, 0x1069, 0x106A, 0x106B, 0x106C, 0x106D, 0x106E, 0x106F,
+    /* 7 */ 0x1070, 0x1071, 0x1072, 0x1073, 0x1074, 0x1075, 0x1076, 0x1077,
+            0x1078, 0x1079, 0x107A, 0x107B, 0x107C, 0x107D, 0x107E, 0x107F,
+    /* 8 */ 0x1080, 0x1081, 0x1082, 0x1083, 0x1084, 0x1085, 0x1086, 0x1087,
+            0x1088, 0x1089, 0x108A, 0x108B, 0x108C, 0x108D, 0x108E, 0x108F,
+    /* 9 */ 0x1090, 0x1091, 0x1092, 0x1093, 0x1094, 0x1095, 0x1096, 0x1097,
+            0x1098, 0x1099, 0x109A, 0x109B, 0x109C, 0x109D, 0x109E, 0x109F,
+    /* A */ 0x10D0, 0x10D1, 0x10D2, 0x10D3, 0x10D4, 0x10D5, 0x10D6, 0x10D7,
+            0x10D8, 0x10D9, 0x10DA, 0x10DB, 0x10DC, 0x10DD, 0x10DE, 0x10DF,
+    /* B */ 0x10E0, 0x10E1, 0x10E2, 0x10E3, 0x10E4, 0x10E5, 0x10E6, 0x10E7,
+            0x10E8, 0x10E9, 0x10EA, 0x10EB, 0x10EC, 0x10ED, 0x10EE, 0x10EF,
+    /* C */ 0x10F0, 0x10F1, 0x10F2, 0x10F3, 0x10F4, 0x10F5, 0x10C6, 0x10C7,
+            0x10C8, 0x10C9, 0x10CA, 0x10CB, 0x10CC, 0x10CD, 0x10CE, 0x10CF,
+    /* D */ 0x10D0, 0x10D1, 0x10D2, 0x10D3, 0x10D4, 0x10D5, 0x10D6, 0x10D7,
+            0x10D8, 0x10D9, 0x10DA, 0x10DB, 0x10DC, 0x10DD, 0x10DE, 0x10DF,
+    /* E */ 0x10E0, 0x10E1, 0x10E2, 0x10E3, 0x10E4, 0x10E5, 0x10E6, 0x10E7,
+            0x10E8, 0x10E9, 0x10EA, 0x10EB, 0x10EC, 0x10ED, 0x10EE, 0x10EF,
+    /* F */ 0x10F0, 0x10F1, 0x10F2, 0x10F3, 0x10F4, 0x10F5, 0x10F6, 0x10F7,
+            0x10F8, 0x10F9, 0x10FA, 0x10FB, 0x10FC, 0x10FD, 0x10FE, 0x10FF,
+
+    // Table 7 (for high byte 0x20)
+
+    /* 0 */ 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007,
+            0x2008, 0x2009, 0x200A, 0x200B, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 1 */ 0x2010, 0x2011, 0x2012, 0x2013, 0x2014, 0x2015, 0x2016, 0x2017,
+            0x2018, 0x2019, 0x201A, 0x201B, 0x201C, 0x201D, 0x201E, 0x201F,
+    /* 2 */ 0x2020, 0x2021, 0x2022, 0x2023, 0x2024, 0x2025, 0x2026, 0x2027,
+            0x2028, 0x2029, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x202F,
+    /* 3 */ 0x2030, 0x2031, 0x2032, 0x2033, 0x2034, 0x2035, 0x2036, 0x2037,
+            0x2038, 0x2039, 0x203A, 0x203B, 0x203C, 0x203D, 0x203E, 0x203F,
+    /* 4 */ 0x2040, 0x2041, 0x2042, 0x2043, 0x2044, 0x2045, 0x2046, 0x2047,
+            0x2048, 0x2049, 0x204A, 0x204B, 0x204C, 0x204D, 0x204E, 0x204F,
+    /* 5 */ 0x2050, 0x2051, 0x2052, 0x2053, 0x2054, 0x2055, 0x2056, 0x2057,
+            0x2058, 0x2059, 0x205A, 0x205B, 0x205C, 0x205D, 0x205E, 0x205F,
+    /* 6 */ 0x2060, 0x2061, 0x2062, 0x2063, 0x2064, 0x2065, 0x2066, 0x2067,
+            0x2068, 0x2069, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 7 */ 0x2070, 0x2071, 0x2072, 0x2073, 0x2074, 0x2075, 0x2076, 0x2077,
+            0x2078, 0x2079, 0x207A, 0x207B, 0x207C, 0x207D, 0x207E, 0x207F,
+    /* 8 */ 0x2080, 0x2081, 0x2082, 0x2083, 0x2084, 0x2085, 0x2086, 0x2087,
+            0x2088, 0x2089, 0x208A, 0x208B, 0x208C, 0x208D, 0x208E, 0x208F,
+    /* 9 */ 0x2090, 0x2091, 0x2092, 0x2093, 0x2094, 0x2095, 0x2096, 0x2097,
+            0x2098, 0x2099, 0x209A, 0x209B, 0x209C, 0x209D, 0x209E, 0x209F,
+    /* A */ 0x20A0, 0x20A1, 0x20A2, 0x20A3, 0x20A4, 0x20A5, 0x20A6, 0x20A7,
+            0x20A8, 0x20A9, 0x20AA, 0x20AB, 0x20AC, 0x20AD, 0x20AE, 0x20AF,
+    /* B */ 0x20B0, 0x20B1, 0x20B2, 0x20B3, 0x20B4, 0x20B5, 0x20B6, 0x20B7,
+            0x20B8, 0x20B9, 0x20BA, 0x20BB, 0x20BC, 0x20BD, 0x20BE, 0x20BF,
+    /* C */ 0x20C0, 0x20C1, 0x20C2, 0x20C3, 0x20C4, 0x20C5, 0x20C6, 0x20C7,
+            0x20C8, 0x20C9, 0x20CA, 0x20CB, 0x20CC, 0x20CD, 0x20CE, 0x20CF,
+    /* D */ 0x20D0, 0x20D1, 0x20D2, 0x20D3, 0x20D4, 0x20D5, 0x20D6, 0x20D7,
+            0x20D8, 0x20D9, 0x20DA, 0x20DB, 0x20DC, 0x20DD, 0x20DE, 0x20DF,
+    /* E */ 0x20E0, 0x20E1, 0x20E2, 0x20E3, 0x20E4, 0x20E5, 0x20E6, 0x20E7,
+            0x20E8, 0x20E9, 0x20EA, 0x20EB, 0x20EC, 0x20ED, 0x20EE, 0x20EF,
+    /* F */ 0x20F0, 0x20F1, 0x20F2, 0x20F3, 0x20F4, 0x20F5, 0x20F6, 0x20F7,
+            0x20F8, 0x20F9, 0x20FA, 0x20FB, 0x20FC, 0x20FD, 0x20FE, 0x20FF,
+
+    // Table 8 (for high byte 0x21)
+
+    /* 0 */ 0x2100, 0x2101, 0x2102, 0x2103, 0x2104, 0x2105, 0x2106, 0x2107,
+            0x2108, 0x2109, 0x210A, 0x210B, 0x210C, 0x210D, 0x210E, 0x210F,
+    /* 1 */ 0x2110, 0x2111, 0x2112, 0x2113, 0x2114, 0x2115, 0x2116, 0x2117,
+            0x2118, 0x2119, 0x211A, 0x211B, 0x211C, 0x211D, 0x211E, 0x211F,
+    /* 2 */ 0x2120, 0x2121, 0x2122, 0x2123, 0x2124, 0x2125, 0x2126, 0x2127,
+            0x2128, 0x2129, 0x212A, 0x212B, 0x212C, 0x212D, 0x212E, 0x212F,
+    /* 3 */ 0x2130, 0x2131, 0x2132, 0x2133, 0x2134, 0x2135, 0x2136, 0x2137,
+            0x2138, 0x2139, 0x213A, 0x213B, 0x213C, 0x213D, 0x213E, 0x213F,
+    /* 4 */ 0x2140, 0x2141, 0x2142, 0x2143, 0x2144, 0x2145, 0x2146, 0x2147,
+            0x2148, 0x2149, 0x214A, 0x214B, 0x214C, 0x214D, 0x214E, 0x214F,
+    /* 5 */ 0x2150, 0x2151, 0x2152, 0x2153, 0x2154, 0x2155, 0x2156, 0x2157,
+            0x2158, 0x2159, 0x215A, 0x215B, 0x215C, 0x215D, 0x215E, 0x215F,
+    /* 6 */ 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177,
+            0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F,
+    /* 7 */ 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177,
+            0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F,
+    /* 8 */ 0x2180, 0x2181, 0x2182, 0x2183, 0x2184, 0x2185, 0x2186, 0x2187,
+            0x2188, 0x2189, 0x218A, 0x218B, 0x218C, 0x218D, 0x218E, 0x218F,
+    /* 9 */ 0x2190, 0x2191, 0x2192, 0x2193, 0x2194, 0x2195, 0x2196, 0x2197,
+            0x2198, 0x2199, 0x219A, 0x219B, 0x219C, 0x219D, 0x219E, 0x219F,
+    /* A */ 0x21A0, 0x21A1, 0x21A2, 0x21A3, 0x21A4, 0x21A5, 0x21A6, 0x21A7,
+            0x21A8, 0x21A9, 0x21AA, 0x21AB, 0x21AC, 0x21AD, 0x21AE, 0x21AF,
+    /* B */ 0x21B0, 0x21B1, 0x21B2, 0x21B3, 0x21B4, 0x21B5, 0x21B6, 0x21B7,
+            0x21B8, 0x21B9, 0x21BA, 0x21BB, 0x21BC, 0x21BD, 0x21BE, 0x21BF,
+    /* C */ 0x21C0, 0x21C1, 0x21C2, 0x21C3, 0x21C4, 0x21C5, 0x21C6, 0x21C7,
+            0x21C8, 0x21C9, 0x21CA, 0x21CB, 0x21CC, 0x21CD, 0x21CE, 0x21CF,
+    /* D */ 0x21D0, 0x21D1, 0x21D2, 0x21D3, 0x21D4, 0x21D5, 0x21D6, 0x21D7,
+            0x21D8, 0x21D9, 0x21DA, 0x21DB, 0x21DC, 0x21DD, 0x21DE, 0x21DF,
+    /* E */ 0x21E0, 0x21E1, 0x21E2, 0x21E3, 0x21E4, 0x21E5, 0x21E6, 0x21E7,
+            0x21E8, 0x21E9, 0x21EA, 0x21EB, 0x21EC, 0x21ED, 0x21EE, 0x21EF,
+    /* F */ 0x21F0, 0x21F1, 0x21F2, 0x21F3, 0x21F4, 0x21F5, 0x21F6, 0x21F7,
+            0x21F8, 0x21F9, 0x21FA, 0x21FB, 0x21FC, 0x21FD, 0x21FE, 0x21FF,
+
+    // Table 9 (for high byte 0xFE)
+
+    /* 0 */ 0xFE00, 0xFE01, 0xFE02, 0xFE03, 0xFE04, 0xFE05, 0xFE06, 0xFE07,
+            0xFE08, 0xFE09, 0xFE0A, 0xFE0B, 0xFE0C, 0xFE0D, 0xFE0E, 0xFE0F,
+    /* 1 */ 0xFE10, 0xFE11, 0xFE12, 0xFE13, 0xFE14, 0xFE15, 0xFE16, 0xFE17,
+            0xFE18, 0xFE19, 0xFE1A, 0xFE1B, 0xFE1C, 0xFE1D, 0xFE1E, 0xFE1F,
+    /* 2 */ 0xFE20, 0xFE21, 0xFE22, 0xFE23, 0xFE24, 0xFE25, 0xFE26, 0xFE27,
+            0xFE28, 0xFE29, 0xFE2A, 0xFE2B, 0xFE2C, 0xFE2D, 0xFE2E, 0xFE2F,
+    /* 3 */ 0xFE30, 0xFE31, 0xFE32, 0xFE33, 0xFE34, 0xFE35, 0xFE36, 0xFE37,
+            0xFE38, 0xFE39, 0xFE3A, 0xFE3B, 0xFE3C, 0xFE3D, 0xFE3E, 0xFE3F,
+    /* 4 */ 0xFE40, 0xFE41, 0xFE42, 0xFE43, 0xFE44, 0xFE45, 0xFE46, 0xFE47,
+            0xFE48, 0xFE49, 0xFE4A, 0xFE4B, 0xFE4C, 0xFE4D, 0xFE4E, 0xFE4F,
+    /* 5 */ 0xFE50, 0xFE51, 0xFE52, 0xFE53, 0xFE54, 0xFE55, 0xFE56, 0xFE57,
+            0xFE58, 0xFE59, 0xFE5A, 0xFE5B, 0xFE5C, 0xFE5D, 0xFE5E, 0xFE5F,
+    /* 6 */ 0xFE60, 0xFE61, 0xFE62, 0xFE63, 0xFE64, 0xFE65, 0xFE66, 0xFE67,
+            0xFE68, 0xFE69, 0xFE6A, 0xFE6B, 0xFE6C, 0xFE6D, 0xFE6E, 0xFE6F,
+    /* 7 */ 0xFE70, 0xFE71, 0xFE72, 0xFE73, 0xFE74, 0xFE75, 0xFE76, 0xFE77,
+            0xFE78, 0xFE79, 0xFE7A, 0xFE7B, 0xFE7C, 0xFE7D, 0xFE7E, 0xFE7F,
+    /* 8 */ 0xFE80, 0xFE81, 0xFE82, 0xFE83, 0xFE84, 0xFE85, 0xFE86, 0xFE87,
+            0xFE88, 0xFE89, 0xFE8A, 0xFE8B, 0xFE8C, 0xFE8D, 0xFE8E, 0xFE8F,
+    /* 9 */ 0xFE90, 0xFE91, 0xFE92, 0xFE93, 0xFE94, 0xFE95, 0xFE96, 0xFE97,
+            0xFE98, 0xFE99, 0xFE9A, 0xFE9B, 0xFE9C, 0xFE9D, 0xFE9E, 0xFE9F,
+    /* A */ 0xFEA0, 0xFEA1, 0xFEA2, 0xFEA3, 0xFEA4, 0xFEA5, 0xFEA6, 0xFEA7,
+            0xFEA8, 0xFEA9, 0xFEAA, 0xFEAB, 0xFEAC, 0xFEAD, 0xFEAE, 0xFEAF,
+    /* B */ 0xFEB0, 0xFEB1, 0xFEB2, 0xFEB3, 0xFEB4, 0xFEB5, 0xFEB6, 0xFEB7,
+            0xFEB8, 0xFEB9, 0xFEBA, 0xFEBB, 0xFEBC, 0xFEBD, 0xFEBE, 0xFEBF,
+    /* C */ 0xFEC0, 0xFEC1, 0xFEC2, 0xFEC3, 0xFEC4, 0xFEC5, 0xFEC6, 0xFEC7,
+            0xFEC8, 0xFEC9, 0xFECA, 0xFECB, 0xFECC, 0xFECD, 0xFECE, 0xFECF,
+    /* D */ 0xFED0, 0xFED1, 0xFED2, 0xFED3, 0xFED4, 0xFED5, 0xFED6, 0xFED7,
+            0xFED8, 0xFED9, 0xFEDA, 0xFEDB, 0xFEDC, 0xFEDD, 0xFEDE, 0xFEDF,
+    /* E */ 0xFEE0, 0xFEE1, 0xFEE2, 0xFEE3, 0xFEE4, 0xFEE5, 0xFEE6, 0xFEE7,
+            0xFEE8, 0xFEE9, 0xFEEA, 0xFEEB, 0xFEEC, 0xFEED, 0xFEEE, 0xFEEF,
+    /* F */ 0xFEF0, 0xFEF1, 0xFEF2, 0xFEF3, 0xFEF4, 0xFEF5, 0xFEF6, 0xFEF7,
+            0xFEF8, 0xFEF9, 0xFEFA, 0xFEFB, 0xFEFC, 0xFEFD, 0xFEFE, 0x0000,
+
+    // Table 10 (for high byte 0xFF)
+
+    /* 0 */ 0xFF00, 0xFF01, 0xFF02, 0xFF03, 0xFF04, 0xFF05, 0xFF06, 0xFF07,
+            0xFF08, 0xFF09, 0xFF0A, 0xFF0B, 0xFF0C, 0xFF0D, 0xFF0E, 0xFF0F,
+    /* 1 */ 0xFF10, 0xFF11, 0xFF12, 0xFF13, 0xFF14, 0xFF15, 0xFF16, 0xFF17,
+            0xFF18, 0xFF19, 0xFF1A, 0xFF1B, 0xFF1C, 0xFF1D, 0xFF1E, 0xFF1F,
+    /* 2 */ 0xFF20, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47,
+            0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F,
+    /* 3 */ 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57,
+            0xFF58, 0xFF59, 0xFF5A, 0xFF3B, 0xFF3C, 0xFF3D, 0xFF3E, 0xFF3F,
+    /* 4 */ 0xFF40, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47,
+            0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F,
+    /* 5 */ 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57,
+            0xFF58, 0xFF59, 0xFF5A, 0xFF5B, 0xFF5C, 0xFF5D, 0xFF5E, 0xFF5F,
+    /* 6 */ 0xFF60, 0xFF61, 0xFF62, 0xFF63, 0xFF64, 0xFF65, 0xFF66, 0xFF67,
+            0xFF68, 0xFF69, 0xFF6A, 0xFF6B, 0xFF6C, 0xFF6D, 0xFF6E, 0xFF6F,
+    /* 7 */ 0xFF70, 0xFF71, 0xFF72, 0xFF73, 0xFF74, 0xFF75, 0xFF76, 0xFF77,
+            0xFF78, 0xFF79, 0xFF7A, 0xFF7B, 0xFF7C, 0xFF7D, 0xFF7E, 0xFF7F,
+    /* 8 */ 0xFF80, 0xFF81, 0xFF82, 0xFF83, 0xFF84, 0xFF85, 0xFF86, 0xFF87,
+            0xFF88, 0xFF89, 0xFF8A, 0xFF8B, 0xFF8C, 0xFF8D, 0xFF8E, 0xFF8F,
+    /* 9 */ 0xFF90, 0xFF91, 0xFF92, 0xFF93, 0xFF94, 0xFF95, 0xFF96, 0xFF97,
+            0xFF98, 0xFF99, 0xFF9A, 0xFF9B, 0xFF9C, 0xFF9D, 0xFF9E, 0xFF9F,
+    /* A */ 0xFFA0, 0xFFA1, 0xFFA2, 0xFFA3, 0xFFA4, 0xFFA5, 0xFFA6, 0xFFA7,
+            0xFFA8, 0xFFA9, 0xFFAA, 0xFFAB, 0xFFAC, 0xFFAD, 0xFFAE, 0xFFAF,
+    /* B */ 0xFFB0, 0xFFB1, 0xFFB2, 0xFFB3, 0xFFB4, 0xFFB5, 0xFFB6, 0xFFB7,
+            0xFFB8, 0xFFB9, 0xFFBA, 0xFFBB, 0xFFBC, 0xFFBD, 0xFFBE, 0xFFBF,
+    /* C */ 0xFFC0, 0xFFC1, 0xFFC2, 0xFFC3, 0xFFC4, 0xFFC5, 0xFFC6, 0xFFC7,
+            0xFFC8, 0xFFC9, 0xFFCA, 0xFFCB, 0xFFCC, 0xFFCD, 0xFFCE, 0xFFCF,
+    /* D */ 0xFFD0, 0xFFD1, 0xFFD2, 0xFFD3, 0xFFD4, 0xFFD5, 0xFFD6, 0xFFD7,
+            0xFFD8, 0xFFD9, 0xFFDA, 0xFFDB, 0xFFDC, 0xFFDD, 0xFFDE, 0xFFDF,
+    /* E */ 0xFFE0, 0xFFE1, 0xFFE2, 0xFFE3, 0xFFE4, 0xFFE5, 0xFFE6, 0xFFE7,
+            0xFFE8, 0xFFE9, 0xFFEA, 0xFFEB, 0xFFEC, 0xFFED, 0xFFEE, 0xFFEF,
+    /* F */ 0xFFF0, 0xFFF1, 0xFFF2, 0xFFF3, 0xFFF4, 0xFFF5, 0xFFF6, 0xFFF7,
+            0xFFF8, 0xFFF9, 0xFFFA, 0xFFFB, 0xFFFC, 0xFFFD, 0xFFFE, 0xFFFF,
+};
+
+u16 hfsplus_decompose_table[] = {
+	/* base table */
+	0x0010, 0x04c0, 0x0000, 0x06f0, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0x07b0,
+	/* char table 0x0___ */
+	0x0020, 0x0070, 0x0160, 0x0190, 0x0230, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x02d0, 0x0340, 0x0360, 0x03b0, 0x03e0, 0x0400, 0x0430,
+	/* char table 0x00__ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0030, 0x0040, 0x0050, 0x0060,
+	/* char values 0x00c_ */
+	0x2042, 0x204a, 0x2052, 0x205a, 0x2062, 0x206a, 0x0000, 0x2072,
+	0x207a, 0x2082, 0x208a, 0x2092, 0x209a, 0x20a2, 0x20aa, 0x20b2,
+	/* char values 0x00d_ */
+	0x0000, 0x20ba, 0x20c2, 0x20ca, 0x20d2, 0x20da, 0x20e2, 0x0000,
+	0x0000, 0x20ea, 0x20f2, 0x20fa, 0x2102, 0x210a, 0x0000, 0x0000,
+	/* char values 0x00e_ */
+	0x2112, 0x211a, 0x2122, 0x212a, 0x2132, 0x213a, 0x0000, 0x2142,
+	0x214a, 0x2152, 0x215a, 0x2162, 0x216a, 0x2172, 0x217a, 0x2182,
+	/* char values 0x00f_ */
+	0x0000, 0x218a, 0x2192, 0x219a, 0x21a2, 0x21aa, 0x21b2, 0x0000,
+	0x0000, 0x21ba, 0x21c2, 0x21ca, 0x21d2, 0x21da, 0x0000, 0x21e2,
+	/* char table 0x01__ */
+	0x0080, 0x0090, 0x00a0, 0x00b0, 0x00c0, 0x00d0, 0x00e0, 0x00f0,
+	0x0000, 0x0000, 0x0100, 0x0110, 0x0120, 0x0130, 0x0140, 0x0150,
+	/* char values 0x010_ */
+	0x21ea, 0x21f2, 0x21fa, 0x2202, 0x220a, 0x2212, 0x221a, 0x2222,
+	0x222a, 0x2232, 0x223a, 0x2242, 0x224a, 0x2252, 0x225a, 0x2262,
+	/* char values 0x011_ */
+	0x0000, 0x0000, 0x226a, 0x2272, 0x227a, 0x2282, 0x228a, 0x2292,
+	0x229a, 0x22a2, 0x22aa, 0x22b2, 0x22ba, 0x22c2, 0x22ca, 0x22d2,
+	/* char values 0x012_ */
+	0x22da, 0x22e2, 0x22ea, 0x22f2, 0x22fa, 0x2302, 0x0000, 0x0000,
+	0x230a, 0x2312, 0x231a, 0x2322, 0x232a, 0x2332, 0x233a, 0x2342,
+	/* char values 0x013_ */
+	0x234a, 0x0000, 0x0000, 0x0000, 0x2352, 0x235a, 0x2362, 0x236a,
+	0x0000, 0x2372, 0x237a, 0x2382, 0x238a, 0x2392, 0x239a, 0x0000,
+	/* char values 0x014_ */
+	0x0000, 0x0000, 0x0000, 0x23a2, 0x23aa, 0x23b2, 0x23ba, 0x23c2,
+	0x23ca, 0x0000, 0x0000, 0x0000, 0x23d2, 0x23da, 0x23e2, 0x23ea,
+	/* char values 0x015_ */
+	0x23f2, 0x23fa, 0x0000, 0x0000, 0x2402, 0x240a, 0x2412, 0x241a,
+	0x2422, 0x242a, 0x2432, 0x243a, 0x2442, 0x244a, 0x2452, 0x245a,
+	/* char values 0x016_ */
+	0x2462, 0x246a, 0x2472, 0x247a, 0x2482, 0x248a, 0x0000, 0x0000,
+	0x2492, 0x249a, 0x24a2, 0x24aa, 0x24b2, 0x24ba, 0x24c2, 0x24ca,
+	/* char values 0x017_ */
+	0x24d2, 0x24da, 0x24e2, 0x24ea, 0x24f2, 0x24fa, 0x2502, 0x250a,
+	0x2512, 0x251a, 0x2522, 0x252a, 0x2532, 0x253a, 0x2542, 0x0000,
+	/* char values 0x01a_ */
+	0x254a, 0x2552, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x255a,
+	/* char values 0x01b_ */
+	0x2562, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x01c_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x256a, 0x2572, 0x257a,
+	/* char values 0x01d_ */
+	0x2582, 0x258a, 0x2592, 0x259a, 0x25a2, 0x25ab, 0x25b7, 0x25c3,
+	0x25cf, 0x25db, 0x25e7, 0x25f3, 0x25ff, 0x0000, 0x260b, 0x2617,
+	/* char values 0x01e_ */
+	0x2623, 0x262f, 0x263a, 0x2642, 0x0000, 0x0000, 0x264a, 0x2652,
+	0x265a, 0x2662, 0x266a, 0x2672, 0x267b, 0x2687, 0x2692, 0x269a,
+	/* char values 0x01f_ */
+	0x26a2, 0x0000, 0x0000, 0x0000, 0x26aa, 0x26b2, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x26bb, 0x26c7, 0x26d2, 0x26da, 0x26e2, 0x26ea,
+	/* char table 0x02__ */
+	0x0170, 0x0180, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x020_ */
+	0x26f2, 0x26fa, 0x2702, 0x270a, 0x2712, 0x271a, 0x2722, 0x272a,
+	0x2732, 0x273a, 0x2742, 0x274a, 0x2752, 0x275a, 0x2762, 0x276a,
+	/* char values 0x021_ */
+	0x2772, 0x277a, 0x2782, 0x278a, 0x2792, 0x279a, 0x27a2, 0x27aa,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char table 0x03__ */
+	0x0000, 0x01a0, 0x0000, 0x0000, 0x01b0, 0x0000, 0x0000, 0x01c0,
+	0x01d0, 0x01e0, 0x01f0, 0x0200, 0x0210, 0x0220, 0x0000, 0x0000,
+	/* char values 0x031_ */
+	0x27b2, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x034_ */
+	0x27b9, 0x27bd, 0x0000, 0x27c1, 0x27c6, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x037_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x27cd, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x27d1, 0x0000,
+	/* char values 0x038_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x27d6, 0x27de, 0x27e5,
+	0x27ea, 0x27f2, 0x27fa, 0x0000, 0x2802, 0x0000, 0x280a, 0x2812,
+	/* char values 0x039_ */
+	0x281b, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x03a_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x2826, 0x282e, 0x2836, 0x283e, 0x2846, 0x284e,
+	/* char values 0x03b_ */
+	0x2857, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x03c_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x2862, 0x286a, 0x2872, 0x287a, 0x2882, 0x0000,
+	/* char values 0x03d_ */
+	0x0000, 0x0000, 0x0000, 0x288a, 0x2892, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char table 0x04__ */
+	0x0240, 0x0250, 0x0000, 0x0260, 0x0000, 0x0270, 0x0000, 0x0280,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0290, 0x02a0, 0x02b0, 0x02c0,
+	/* char values 0x040_ */
+	0x0000, 0x289a, 0x0000, 0x28a2, 0x0000, 0x0000, 0x0000, 0x28aa,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x28b2, 0x0000, 0x28ba, 0x0000,
+	/* char values 0x041_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x28c2, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x043_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x28ca, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x045_ */
+	0x0000, 0x28d2, 0x0000, 0x28da, 0x0000, 0x0000, 0x0000, 0x28e2,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x28ea, 0x0000, 0x28f2, 0x0000,
+	/* char values 0x047_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x28fa, 0x2902,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x04c_ */
+	0x0000, 0x290a, 0x2912, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x04d_ */
+	0x291a, 0x2922, 0x292a, 0x2932, 0x2939, 0x293d, 0x2942, 0x294a,
+	0x2951, 0x2955, 0x295a, 0x2962, 0x296a, 0x2972, 0x297a, 0x2982,
+	/* char values 0x04e_ */
+	0x2989, 0x298d, 0x2992, 0x299a, 0x29a2, 0x29aa, 0x29b2, 0x29ba,
+	0x29c1, 0x29c5, 0x29ca, 0x29d2, 0x0000, 0x0000, 0x29da, 0x29e2,
+	/* char values 0x04f_ */
+	0x29ea, 0x29f2, 0x29fa, 0x2a02, 0x2a0a, 0x2a12, 0x0000, 0x0000,
+	0x2a1a, 0x2a22, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char table 0x09__ */
+	0x0000, 0x0000, 0x02e0, 0x02f0, 0x0000, 0x0300, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0310, 0x0320, 0x0330, 0x0000, 0x0000,
+	/* char values 0x092_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x2a2a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x093_ */
+	0x0000, 0x2a32, 0x0000, 0x0000, 0x2a3a, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x095_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x2a42, 0x2a4a, 0x2a52, 0x2a5a, 0x2a62, 0x2a6a, 0x2a72, 0x2a7a,
+	/* char values 0x09b_ */
+	0x2a82, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x09c_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x2a8a, 0x2a92, 0x0000, 0x0000, 0x0000,
+	/* char values 0x09d_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x2a9a, 0x2aa2, 0x0000, 0x2aaa,
+	/* char table 0x0a__ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0350, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x0a5_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x2ab2, 0x2aba, 0x2ac2, 0x2aca, 0x0000, 0x2ad2, 0x0000,
+	/* char table 0x0b__ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0370, 0x0380, 0x0000, 0x0000,
+	0x0000, 0x0390, 0x0000, 0x0000, 0x03a0, 0x0000, 0x0000, 0x0000,
+	/* char values 0x0b4_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x2ada, 0x0000, 0x0000, 0x2ae2, 0x2aea, 0x0000, 0x0000, 0x0000,
+	/* char values 0x0b5_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x2af2, 0x2afa, 0x0000, 0x2b02,
+	/* char values 0x0b9_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x2b0a, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x0bc_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x2b12, 0x2b1a, 0x2b22, 0x0000, 0x0000, 0x0000,
+	/* char table 0x0c__ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x03c0, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x03d0, 0x0000, 0x0000, 0x0000,
+	/* char values 0x0c4_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x2b2a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x0cc_ */
+	0x2b32, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2b3a,
+	0x2b42, 0x0000, 0x2b4a, 0x2b53, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char table 0x0d__ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x03f0, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x0d4_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x2b5e, 0x2b66, 0x2b6e, 0x0000, 0x0000, 0x0000,
+	/* char table 0x0e__ */
+	0x0000, 0x0000, 0x0000, 0x0410, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0420, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x0e3_ */
+	0x0000, 0x0000, 0x0000, 0x2b76, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x0eb_ */
+	0x0000, 0x0000, 0x0000, 0x2b7e, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char table 0x0f__ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0440, 0x0450, 0x0460, 0x0470,
+	0x0480, 0x0490, 0x04a0, 0x04b0, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x0f4_ */
+	0x0000, 0x0000, 0x0000, 0x2b86, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2b8e, 0x0000, 0x0000,
+	/* char values 0x0f5_ */
+	0x0000, 0x0000, 0x2b96, 0x0000, 0x0000, 0x0000, 0x0000, 0x2b9e,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x2ba6, 0x0000, 0x0000, 0x0000,
+	/* char values 0x0f6_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x2bae, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x0f7_ */
+	0x0000, 0x0000, 0x0000, 0x2bb6, 0x0000, 0x2bbe, 0x2bc6, 0x2bcf,
+	0x2bda, 0x2be3, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x0f8_ */
+	0x0000, 0x2bee, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x0f9_ */
+	0x0000, 0x0000, 0x0000, 0x2bf6, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2bfe, 0x0000, 0x0000,
+	/* char values 0x0fa_ */
+	0x0000, 0x0000, 0x2c06, 0x0000, 0x0000, 0x0000, 0x0000, 0x2c0e,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x2c16, 0x0000, 0x0000, 0x0000,
+	/* char values 0x0fb_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x2c1e, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char table 0x1___ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x04d0, 0x05e0,
+	/* char table 0x1e__ */
+	0x04e0, 0x04f0, 0x0500, 0x0510, 0x0520, 0x0530, 0x0540, 0x0550,
+	0x0560, 0x0570, 0x0580, 0x0590, 0x05a0, 0x05b0, 0x05c0, 0x05d0,
+	/* char values 0x1e0_ */
+	0x2c26, 0x2c2e, 0x2c36, 0x2c3e, 0x2c46, 0x2c4e, 0x2c56, 0x2c5e,
+	0x2c67, 0x2c73, 0x2c7e, 0x2c86, 0x2c8e, 0x2c96, 0x2c9e, 0x2ca6,
+	/* char values 0x1e1_ */
+	0x2cae, 0x2cb6, 0x2cbe, 0x2cc6, 0x2ccf, 0x2cdb, 0x2ce7, 0x2cf3,
+	0x2cfe, 0x2d06, 0x2d0e, 0x2d16, 0x2d1f, 0x2d2b, 0x2d36, 0x2d3e,
+	/* char values 0x1e2_ */
+	0x2d46, 0x2d4e, 0x2d56, 0x2d5e, 0x2d66, 0x2d6e, 0x2d76, 0x2d7e,
+	0x2d86, 0x2d8e, 0x2d96, 0x2d9e, 0x2da6, 0x2dae, 0x2db7, 0x2dc3,
+	/* char values 0x1e3_ */
+	0x2dce, 0x2dd6, 0x2dde, 0x2de6, 0x2dee, 0x2df6, 0x2dfe, 0x2e06,
+	0x2e0f, 0x2e1b, 0x2e26, 0x2e2e, 0x2e36, 0x2e3e, 0x2e46, 0x2e4e,
+	/* char values 0x1e4_ */
+	0x2e56, 0x2e5e, 0x2e66, 0x2e6e, 0x2e76, 0x2e7e, 0x2e86, 0x2e8e,
+	0x2e96, 0x2e9e, 0x2ea6, 0x2eae, 0x2eb7, 0x2ec3, 0x2ecf, 0x2edb,
+	/* char values 0x1e5_ */
+	0x2ee7, 0x2ef3, 0x2eff, 0x2f0b, 0x2f16, 0x2f1e, 0x2f26, 0x2f2e,
+	0x2f36, 0x2f3e, 0x2f46, 0x2f4e, 0x2f57, 0x2f63, 0x2f6e, 0x2f76,
+	/* char values 0x1e6_ */
+	0x2f7e, 0x2f86, 0x2f8e, 0x2f96, 0x2f9f, 0x2fab, 0x2fb7, 0x2fc3,
+	0x2fcf, 0x2fdb, 0x2fe6, 0x2fee, 0x2ff6, 0x2ffe, 0x3006, 0x300e,
+	/* char values 0x1e7_ */
+	0x3016, 0x301e, 0x3026, 0x302e, 0x3036, 0x303e, 0x3046, 0x304e,
+	0x3057, 0x3063, 0x306f, 0x307b, 0x3086, 0x308e, 0x3096, 0x309e,
+	/* char values 0x1e8_ */
+	0x30a6, 0x30ae, 0x30b6, 0x30be, 0x30c6, 0x30ce, 0x30d6, 0x30de,
+	0x30e6, 0x30ee, 0x30f6, 0x30fe, 0x3106, 0x310e, 0x3116, 0x311e,
+	/* char values 0x1e9_ */
+	0x3126, 0x312e, 0x3136, 0x313e, 0x3146, 0x314e, 0x3156, 0x315e,
+	0x3166, 0x316e, 0x0000, 0x3176, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x1ea_ */
+	0x317e, 0x3186, 0x318e, 0x3196, 0x319f, 0x31ab, 0x31b7, 0x31c3,
+	0x31cf, 0x31db, 0x31e7, 0x31f3, 0x31ff, 0x320b, 0x3217, 0x3223,
+	/* char values 0x1eb_ */
+	0x322f, 0x323b, 0x3247, 0x3253, 0x325f, 0x326b, 0x3277, 0x3283,
+	0x328e, 0x3296, 0x329e, 0x32a6, 0x32ae, 0x32b6, 0x32bf, 0x32cb,
+	/* char values 0x1ec_ */
+	0x32d7, 0x32e3, 0x32ef, 0x32fb, 0x3307, 0x3313, 0x331f, 0x332b,
+	0x3336, 0x333e, 0x3346, 0x334e, 0x3356, 0x335e, 0x3366, 0x336e,
+	/* char values 0x1ed_ */
+	0x3377, 0x3383, 0x338f, 0x339b, 0x33a7, 0x33b3, 0x33bf, 0x33cb,
+	0x33d7, 0x33e3, 0x33ef, 0x33fb, 0x3407, 0x3413, 0x341f, 0x342b,
+	/* char values 0x1ee_ */
+	0x3437, 0x3443, 0x344f, 0x345b, 0x3466, 0x346e, 0x3476, 0x347e,
+	0x3487, 0x3493, 0x349f, 0x34ab, 0x34b7, 0x34c3, 0x34cf, 0x34db,
+	/* char values 0x1ef_ */
+	0x34e7, 0x34f3, 0x34fe, 0x3506, 0x350e, 0x3516, 0x351e, 0x3526,
+	0x352e, 0x3536, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char table 0x1f__ */
+	0x05f0, 0x0600, 0x0610, 0x0620, 0x0630, 0x0640, 0x0650, 0x0660,
+	0x0670, 0x0680, 0x0690, 0x06a0, 0x06b0, 0x06c0, 0x06d0, 0x06e0,
+	/* char values 0x1f0_ */
+	0x353e, 0x3546, 0x354f, 0x355b, 0x3567, 0x3573, 0x357f, 0x358b,
+	0x3596, 0x359e, 0x35a7, 0x35b3, 0x35bf, 0x35cb, 0x35d7, 0x35e3,
+	/* char values 0x1f1_ */
+	0x35ee, 0x35f6, 0x35ff, 0x360b, 0x3617, 0x3623, 0x0000, 0x0000,
+	0x362e, 0x3636, 0x363f, 0x364b, 0x3657, 0x3663, 0x0000, 0x0000,
+	/* char values 0x1f2_ */
+	0x366e, 0x3676, 0x367f, 0x368b, 0x3697, 0x36a3, 0x36af, 0x36bb,
+	0x36c6, 0x36ce, 0x36d7, 0x36e3, 0x36ef, 0x36fb, 0x3707, 0x3713,
+	/* char values 0x1f3_ */
+	0x371e, 0x3726, 0x372f, 0x373b, 0x3747, 0x3753, 0x375f, 0x376b,
+	0x3776, 0x377e, 0x3787, 0x3793, 0x379f, 0x37ab, 0x37b7, 0x37c3,
+	/* char values 0x1f4_ */
+	0x37ce, 0x37d6, 0x37df, 0x37eb, 0x37f7, 0x3803, 0x0000, 0x0000,
+	0x380e, 0x3816, 0x381f, 0x382b, 0x3837, 0x3843, 0x0000, 0x0000,
+	/* char values 0x1f5_ */
+	0x384e, 0x3856, 0x385f, 0x386b, 0x3877, 0x3883, 0x388f, 0x389b,
+	0x0000, 0x38a6, 0x0000, 0x38af, 0x0000, 0x38bb, 0x0000, 0x38c7,
+	/* char values 0x1f6_ */
+	0x38d2, 0x38da, 0x38e3, 0x38ef, 0x38fb, 0x3907, 0x3913, 0x391f,
+	0x392a, 0x3932, 0x393b, 0x3947, 0x3953, 0x395f, 0x396b, 0x3977,
+	/* char values 0x1f7_ */
+	0x3982, 0x398a, 0x3992, 0x399a, 0x39a2, 0x39aa, 0x39b2, 0x39ba,
+	0x39c2, 0x39ca, 0x39d2, 0x39da, 0x39e2, 0x39ea, 0x0000, 0x0000,
+	/* char values 0x1f8_ */
+	0x39f3, 0x39ff, 0x3a0c, 0x3a1c, 0x3a2c, 0x3a3c, 0x3a4c, 0x3a5c,
+	0x3a6b, 0x3a77, 0x3a84, 0x3a94, 0x3aa4, 0x3ab4, 0x3ac4, 0x3ad4,
+	/* char values 0x1f9_ */
+	0x3ae3, 0x3aef, 0x3afc, 0x3b0c, 0x3b1c, 0x3b2c, 0x3b3c, 0x3b4c,
+	0x3b5b, 0x3b67, 0x3b74, 0x3b84, 0x3b94, 0x3ba4, 0x3bb4, 0x3bc4,
+	/* char values 0x1fa_ */
+	0x3bd3, 0x3bdf, 0x3bec, 0x3bfc, 0x3c0c, 0x3c1c, 0x3c2c, 0x3c3c,
+	0x3c4b, 0x3c57, 0x3c64, 0x3c74, 0x3c84, 0x3c94, 0x3ca4, 0x3cb4,
+	/* char values 0x1fb_ */
+	0x3cc2, 0x3cca, 0x3cd3, 0x3cde, 0x3ce7, 0x0000, 0x3cf2, 0x3cfb,
+	0x3d06, 0x3d0e, 0x3d16, 0x3d1e, 0x3d26, 0x0000, 0x3d2d, 0x0000,
+	/* char values 0x1fc_ */
+	0x0000, 0x3d32, 0x3d3b, 0x3d46, 0x3d4f, 0x0000, 0x3d5a, 0x3d63,
+	0x3d6e, 0x3d76, 0x3d7e, 0x3d86, 0x3d8e, 0x3d96, 0x3d9e, 0x3da6,
+	/* char values 0x1fd_ */
+	0x3dae, 0x3db6, 0x3dbf, 0x3dcb, 0x0000, 0x0000, 0x3dd6, 0x3ddf,
+	0x3dea, 0x3df2, 0x3dfa, 0x3e02, 0x0000, 0x3e0a, 0x3e12, 0x3e1a,
+	/* char values 0x1fe_ */
+	0x3e22, 0x3e2a, 0x3e33, 0x3e3f, 0x3e4a, 0x3e52, 0x3e5a, 0x3e63,
+	0x3e6e, 0x3e76, 0x3e7e, 0x3e86, 0x3e8e, 0x3e96, 0x3e9e, 0x3ea5,
+	/* char values 0x1ff_ */
+	0x0000, 0x0000, 0x3eab, 0x3eb6, 0x3ebf, 0x0000, 0x3eca, 0x3ed3,
+	0x3ede, 0x3ee6, 0x3eee, 0x3ef6, 0x3efe, 0x3f05, 0x0000, 0x0000,
+	/* char table 0x3___ */
+	0x0700, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char table 0x30__ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0710, 0x0720, 0x0730, 0x0740,
+	0x0000, 0x0750, 0x0760, 0x0770, 0x0780, 0x0790, 0x0000, 0x07a0,
+	/* char values 0x304_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x3f0a, 0x0000, 0x3f12, 0x0000,
+	/* char values 0x305_ */
+	0x3f1a, 0x0000, 0x3f22, 0x0000, 0x3f2a, 0x0000, 0x3f32, 0x0000,
+	0x3f3a, 0x0000, 0x3f42, 0x0000, 0x3f4a, 0x0000, 0x3f52, 0x0000,
+	/* char values 0x306_ */
+	0x3f5a, 0x0000, 0x3f62, 0x0000, 0x0000, 0x3f6a, 0x0000, 0x3f72,
+	0x0000, 0x3f7a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x307_ */
+	0x3f82, 0x3f8a, 0x0000, 0x3f92, 0x3f9a, 0x0000, 0x3fa2, 0x3faa,
+	0x0000, 0x3fb2, 0x3fba, 0x0000, 0x3fc2, 0x3fca, 0x0000, 0x0000,
+	/* char values 0x309_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x3fd2, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3fda, 0x0000,
+	/* char values 0x30a_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x3fe2, 0x0000, 0x3fea, 0x0000,
+	/* char values 0x30b_ */
+	0x3ff2, 0x0000, 0x3ffa, 0x0000, 0x4002, 0x0000, 0x400a, 0x0000,
+	0x4012, 0x0000, 0x401a, 0x0000, 0x4022, 0x0000, 0x402a, 0x0000,
+	/* char values 0x30c_ */
+	0x4032, 0x0000, 0x403a, 0x0000, 0x0000, 0x4042, 0x0000, 0x404a,
+	0x0000, 0x4052, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0x30d_ */
+	0x405a, 0x4062, 0x0000, 0x406a, 0x4072, 0x0000, 0x407a, 0x4082,
+	0x0000, 0x408a, 0x4092, 0x0000, 0x409a, 0x40a2, 0x0000, 0x0000,
+	/* char values 0x30f_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x40aa, 0x0000, 0x0000, 0x40b2,
+	0x40ba, 0x40c2, 0x40ca, 0x0000, 0x0000, 0x0000, 0x40d2, 0x0000,
+	/* char table 0xf___ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x07c0, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char table 0xfb__ */
+	0x0000, 0x07d0, 0x07e0, 0x07f0, 0x0800, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	/* char values 0xfb1_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x40da,
+	/* char values 0xfb2_ */
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x40e2, 0x40ea, 0x40f3, 0x40ff, 0x410a, 0x4112,
+	/* char values 0xfb3_ */
+	0x411a, 0x4122, 0x412a, 0x4132, 0x413a, 0x4142, 0x414a, 0x0000,
+	0x4152, 0x415a, 0x4162, 0x416a, 0x4172, 0x0000, 0x417a, 0x0000,
+	/* char values 0xfb4_ */
+	0x4182, 0x418a, 0x0000, 0x4192, 0x419a, 0x0000, 0x41a2, 0x41aa,
+	0x41b2, 0x41ba, 0x41c2, 0x41ca, 0x41d2, 0x41da, 0x41e2, 0x0000,
+	/* decomposed characters */
+	0x0041, 0x0300, 0x0041, 0x0301, 0x0041, 0x0302, 0x0041, 0x0303,
+	0x0041, 0x0308, 0x0041, 0x030a, 0x0043, 0x0327, 0x0045, 0x0300,
+	0x0045, 0x0301, 0x0045, 0x0302, 0x0045, 0x0308, 0x0049, 0x0300,
+	0x0049, 0x0301, 0x0049, 0x0302, 0x0049, 0x0308, 0x004e, 0x0303,
+	0x004f, 0x0300, 0x004f, 0x0301, 0x004f, 0x0302, 0x004f, 0x0303,
+	0x004f, 0x0308, 0x0055, 0x0300, 0x0055, 0x0301, 0x0055, 0x0302,
+	0x0055, 0x0308, 0x0059, 0x0301, 0x0061, 0x0300, 0x0061, 0x0301,
+	0x0061, 0x0302, 0x0061, 0x0303, 0x0061, 0x0308, 0x0061, 0x030a,
+	0x0063, 0x0327, 0x0065, 0x0300, 0x0065, 0x0301, 0x0065, 0x0302,
+	0x0065, 0x0308, 0x0069, 0x0300, 0x0069, 0x0301, 0x0069, 0x0302,
+	0x0069, 0x0308, 0x006e, 0x0303, 0x006f, 0x0300, 0x006f, 0x0301,
+	0x006f, 0x0302, 0x006f, 0x0303, 0x006f, 0x0308, 0x0075, 0x0300,
+	0x0075, 0x0301, 0x0075, 0x0302, 0x0075, 0x0308, 0x0079, 0x0301,
+	0x0079, 0x0308, 0x0041, 0x0304, 0x0061, 0x0304, 0x0041, 0x0306,
+	0x0061, 0x0306, 0x0041, 0x0328, 0x0061, 0x0328, 0x0043, 0x0301,
+	0x0063, 0x0301, 0x0043, 0x0302, 0x0063, 0x0302, 0x0043, 0x0307,
+	0x0063, 0x0307, 0x0043, 0x030c, 0x0063, 0x030c, 0x0044, 0x030c,
+	0x0064, 0x030c, 0x0045, 0x0304, 0x0065, 0x0304, 0x0045, 0x0306,
+	0x0065, 0x0306, 0x0045, 0x0307, 0x0065, 0x0307, 0x0045, 0x0328,
+	0x0065, 0x0328, 0x0045, 0x030c, 0x0065, 0x030c, 0x0047, 0x0302,
+	0x0067, 0x0302, 0x0047, 0x0306, 0x0067, 0x0306, 0x0047, 0x0307,
+	0x0067, 0x0307, 0x0047, 0x0327, 0x0067, 0x0327, 0x0048, 0x0302,
+	0x0068, 0x0302, 0x0049, 0x0303, 0x0069, 0x0303, 0x0049, 0x0304,
+	0x0069, 0x0304, 0x0049, 0x0306, 0x0069, 0x0306, 0x0049, 0x0328,
+	0x0069, 0x0328, 0x0049, 0x0307, 0x004a, 0x0302, 0x006a, 0x0302,
+	0x004b, 0x0327, 0x006b, 0x0327, 0x004c, 0x0301, 0x006c, 0x0301,
+	0x004c, 0x0327, 0x006c, 0x0327, 0x004c, 0x030c, 0x006c, 0x030c,
+	0x004e, 0x0301, 0x006e, 0x0301, 0x004e, 0x0327, 0x006e, 0x0327,
+	0x004e, 0x030c, 0x006e, 0x030c, 0x004f, 0x0304, 0x006f, 0x0304,
+	0x004f, 0x0306, 0x006f, 0x0306, 0x004f, 0x030b, 0x006f, 0x030b,
+	0x0052, 0x0301, 0x0072, 0x0301, 0x0052, 0x0327, 0x0072, 0x0327,
+	0x0052, 0x030c, 0x0072, 0x030c, 0x0053, 0x0301, 0x0073, 0x0301,
+	0x0053, 0x0302, 0x0073, 0x0302, 0x0053, 0x0327, 0x0073, 0x0327,
+	0x0053, 0x030c, 0x0073, 0x030c, 0x0054, 0x0327, 0x0074, 0x0327,
+	0x0054, 0x030c, 0x0074, 0x030c, 0x0055, 0x0303, 0x0075, 0x0303,
+	0x0055, 0x0304, 0x0075, 0x0304, 0x0055, 0x0306, 0x0075, 0x0306,
+	0x0055, 0x030a, 0x0075, 0x030a, 0x0055, 0x030b, 0x0075, 0x030b,
+	0x0055, 0x0328, 0x0075, 0x0328, 0x0057, 0x0302, 0x0077, 0x0302,
+	0x0059, 0x0302, 0x0079, 0x0302, 0x0059, 0x0308, 0x005a, 0x0301,
+	0x007a, 0x0301, 0x005a, 0x0307, 0x007a, 0x0307, 0x005a, 0x030c,
+	0x007a, 0x030c, 0x004f, 0x031b, 0x006f, 0x031b, 0x0055, 0x031b,
+	0x0075, 0x031b, 0x0041, 0x030c, 0x0061, 0x030c, 0x0049, 0x030c,
+	0x0069, 0x030c, 0x004f, 0x030c, 0x006f, 0x030c, 0x0055, 0x030c,
+	0x0075, 0x030c, 0x0055, 0x0308, 0x0304, 0x0075, 0x0308, 0x0304,
+	0x0055, 0x0308, 0x0301, 0x0075, 0x0308, 0x0301, 0x0055, 0x0308,
+	0x030c, 0x0075, 0x0308, 0x030c, 0x0055, 0x0308, 0x0300, 0x0075,
+	0x0308, 0x0300, 0x0041, 0x0308, 0x0304, 0x0061, 0x0308, 0x0304,
+	0x0041, 0x0307, 0x0304, 0x0061, 0x0307, 0x0304, 0x00c6, 0x0304,
+	0x00e6, 0x0304, 0x0047, 0x030c, 0x0067, 0x030c, 0x004b, 0x030c,
+	0x006b, 0x030c, 0x004f, 0x0328, 0x006f, 0x0328, 0x004f, 0x0328,
+	0x0304, 0x006f, 0x0328, 0x0304, 0x01b7, 0x030c, 0x0292, 0x030c,
+	0x006a, 0x030c, 0x0047, 0x0301, 0x0067, 0x0301, 0x0041, 0x030a,
+	0x0301, 0x0061, 0x030a, 0x0301, 0x00c6, 0x0301, 0x00e6, 0x0301,
+	0x00d8, 0x0301, 0x00f8, 0x0301, 0x0041, 0x030f, 0x0061, 0x030f,
+	0x0041, 0x0311, 0x0061, 0x0311, 0x0045, 0x030f, 0x0065, 0x030f,
+	0x0045, 0x0311, 0x0065, 0x0311, 0x0049, 0x030f, 0x0069, 0x030f,
+	0x0049, 0x0311, 0x0069, 0x0311, 0x004f, 0x030f, 0x006f, 0x030f,
+	0x004f, 0x0311, 0x006f, 0x0311, 0x0052, 0x030f, 0x0072, 0x030f,
+	0x0052, 0x0311, 0x0072, 0x0311, 0x0055, 0x030f, 0x0075, 0x030f,
+	0x0055, 0x0311, 0x0075, 0x0311, 0x0306, 0x0307, 0x0300, 0x0301,
+	0x0313, 0x0308, 0x030d, 0x02b9, 0x003b, 0x00a8, 0x030d, 0x0391,
+	0x030d, 0x00b7, 0x0395, 0x030d, 0x0397, 0x030d, 0x0399, 0x030d,
+	0x039f, 0x030d, 0x03a5, 0x030d, 0x03a9, 0x030d, 0x03b9, 0x0308,
+	0x030d, 0x0399, 0x0308, 0x03a5, 0x0308, 0x03b1, 0x030d, 0x03b5,
+	0x030d, 0x03b7, 0x030d, 0x03b9, 0x030d, 0x03c5, 0x0308, 0x030d,
+	0x03b9, 0x0308, 0x03c5, 0x0308, 0x03bf, 0x030d, 0x03c5, 0x030d,
+	0x03c9, 0x030d, 0x03d2, 0x030d, 0x03d2, 0x0308, 0x0415, 0x0308,
+	0x0413, 0x0301, 0x0406, 0x0308, 0x041a, 0x0301, 0x0423, 0x0306,
+	0x0418, 0x0306, 0x0438, 0x0306, 0x0435, 0x0308, 0x0433, 0x0301,
+	0x0456, 0x0308, 0x043a, 0x0301, 0x0443, 0x0306, 0x0474, 0x030f,
+	0x0475, 0x030f, 0x0416, 0x0306, 0x0436, 0x0306, 0x0410, 0x0306,
+	0x0430, 0x0306, 0x0410, 0x0308, 0x0430, 0x0308, 0x00c6, 0x00e6,
+	0x0415, 0x0306, 0x0435, 0x0306, 0x018f, 0x0259, 0x018f, 0x0308,
+	0x0259, 0x0308, 0x0416, 0x0308, 0x0436, 0x0308, 0x0417, 0x0308,
+	0x0437, 0x0308, 0x01b7, 0x0292, 0x0418, 0x0304, 0x0438, 0x0304,
+	0x0418, 0x0308, 0x0438, 0x0308, 0x041e, 0x0308, 0x043e, 0x0308,
+	0x019f, 0x0275, 0x019f, 0x0308, 0x0275, 0x0308, 0x0423, 0x0304,
+	0x0443, 0x0304, 0x0423, 0x0308, 0x0443, 0x0308, 0x0423, 0x030b,
+	0x0443, 0x030b, 0x0427, 0x0308, 0x0447, 0x0308, 0x042b, 0x0308,
+	0x044b, 0x0308, 0x0928, 0x093c, 0x0930, 0x093c, 0x0933, 0x093c,
+	0x0915, 0x093c, 0x0916, 0x093c, 0x0917, 0x093c, 0x091c, 0x093c,
+	0x0921, 0x093c, 0x0922, 0x093c, 0x092b, 0x093c, 0x092f, 0x093c,
+	0x09ac, 0x09bc, 0x09c7, 0x09be, 0x09c7, 0x09d7, 0x09a1, 0x09bc,
+	0x09a2, 0x09bc, 0x09af, 0x09bc, 0x0a16, 0x0a3c, 0x0a17, 0x0a3c,
+	0x0a1c, 0x0a3c, 0x0a21, 0x0a3c, 0x0a2b, 0x0a3c, 0x0b47, 0x0b56,
+	0x0b47, 0x0b3e, 0x0b47, 0x0b57, 0x0b21, 0x0b3c, 0x0b22, 0x0b3c,
+	0x0b2f, 0x0b3c, 0x0b92, 0x0bd7, 0x0bc6, 0x0bbe, 0x0bc7, 0x0bbe,
+	0x0bc6, 0x0bd7, 0x0c46, 0x0c56, 0x0cbf, 0x0cd5, 0x0cc6, 0x0cd5,
+	0x0cc6, 0x0cd6, 0x0cc6, 0x0cc2, 0x0cc6, 0x0cc2, 0x0cd5, 0x0d46,
+	0x0d3e, 0x0d47, 0x0d3e, 0x0d46, 0x0d57, 0x0e4d, 0x0e32, 0x0ecd,
+	0x0eb2, 0x0f42, 0x0fb7, 0x0f4c, 0x0fb7, 0x0f51, 0x0fb7, 0x0f56,
+	0x0fb7, 0x0f5b, 0x0fb7, 0x0f40, 0x0fb5, 0x0f72, 0x0f71, 0x0f74,
+	0x0f71, 0x0fb2, 0x0f80, 0x0fb2, 0x0f80, 0x0f71, 0x0fb3, 0x0f80,
+	0x0fb3, 0x0f80, 0x0f71, 0x0f80, 0x0f71, 0x0f92, 0x0fb7, 0x0f9c,
+	0x0fb7, 0x0fa1, 0x0fb7, 0x0fa6, 0x0fb7, 0x0fab, 0x0fb7, 0x0f90,
+	0x0fb5, 0x0041, 0x0325, 0x0061, 0x0325, 0x0042, 0x0307, 0x0062,
+	0x0307, 0x0042, 0x0323, 0x0062, 0x0323, 0x0042, 0x0331, 0x0062,
+	0x0331, 0x0043, 0x0327, 0x0301, 0x0063, 0x0327, 0x0301, 0x0044,
+	0x0307, 0x0064, 0x0307, 0x0044, 0x0323, 0x0064, 0x0323, 0x0044,
+	0x0331, 0x0064, 0x0331, 0x0044, 0x0327, 0x0064, 0x0327, 0x0044,
+	0x032d, 0x0064, 0x032d, 0x0045, 0x0304, 0x0300, 0x0065, 0x0304,
+	0x0300, 0x0045, 0x0304, 0x0301, 0x0065, 0x0304, 0x0301, 0x0045,
+	0x032d, 0x0065, 0x032d, 0x0045, 0x0330, 0x0065, 0x0330, 0x0045,
+	0x0327, 0x0306, 0x0065, 0x0327, 0x0306, 0x0046, 0x0307, 0x0066,
+	0x0307, 0x0047, 0x0304, 0x0067, 0x0304, 0x0048, 0x0307, 0x0068,
+	0x0307, 0x0048, 0x0323, 0x0068, 0x0323, 0x0048, 0x0308, 0x0068,
+	0x0308, 0x0048, 0x0327, 0x0068, 0x0327, 0x0048, 0x032e, 0x0068,
+	0x032e, 0x0049, 0x0330, 0x0069, 0x0330, 0x0049, 0x0308, 0x0301,
+	0x0069, 0x0308, 0x0301, 0x004b, 0x0301, 0x006b, 0x0301, 0x004b,
+	0x0323, 0x006b, 0x0323, 0x004b, 0x0331, 0x006b, 0x0331, 0x004c,
+	0x0323, 0x006c, 0x0323, 0x004c, 0x0323, 0x0304, 0x006c, 0x0323,
+	0x0304, 0x004c, 0x0331, 0x006c, 0x0331, 0x004c, 0x032d, 0x006c,
+	0x032d, 0x004d, 0x0301, 0x006d, 0x0301, 0x004d, 0x0307, 0x006d,
+	0x0307, 0x004d, 0x0323, 0x006d, 0x0323, 0x004e, 0x0307, 0x006e,
+	0x0307, 0x004e, 0x0323, 0x006e, 0x0323, 0x004e, 0x0331, 0x006e,
+	0x0331, 0x004e, 0x032d, 0x006e, 0x032d, 0x004f, 0x0303, 0x0301,
+	0x006f, 0x0303, 0x0301, 0x004f, 0x0303, 0x0308, 0x006f, 0x0303,
+	0x0308, 0x004f, 0x0304, 0x0300, 0x006f, 0x0304, 0x0300, 0x004f,
+	0x0304, 0x0301, 0x006f, 0x0304, 0x0301, 0x0050, 0x0301, 0x0070,
+	0x0301, 0x0050, 0x0307, 0x0070, 0x0307, 0x0052, 0x0307, 0x0072,
+	0x0307, 0x0052, 0x0323, 0x0072, 0x0323, 0x0052, 0x0323, 0x0304,
+	0x0072, 0x0323, 0x0304, 0x0052, 0x0331, 0x0072, 0x0331, 0x0053,
+	0x0307, 0x0073, 0x0307, 0x0053, 0x0323, 0x0073, 0x0323, 0x0053,
+	0x0301, 0x0307, 0x0073, 0x0301, 0x0307, 0x0053, 0x030c, 0x0307,
+	0x0073, 0x030c, 0x0307, 0x0053, 0x0323, 0x0307, 0x0073, 0x0323,
+	0x0307, 0x0054, 0x0307, 0x0074, 0x0307, 0x0054, 0x0323, 0x0074,
+	0x0323, 0x0054, 0x0331, 0x0074, 0x0331, 0x0054, 0x032d, 0x0074,
+	0x032d, 0x0055, 0x0324, 0x0075, 0x0324, 0x0055, 0x0330, 0x0075,
+	0x0330, 0x0055, 0x032d, 0x0075, 0x032d, 0x0055, 0x0303, 0x0301,
+	0x0075, 0x0303, 0x0301, 0x0055, 0x0304, 0x0308, 0x0075, 0x0304,
+	0x0308, 0x0056, 0x0303, 0x0076, 0x0303, 0x0056, 0x0323, 0x0076,
+	0x0323, 0x0057, 0x0300, 0x0077, 0x0300, 0x0057, 0x0301, 0x0077,
+	0x0301, 0x0057, 0x0308, 0x0077, 0x0308, 0x0057, 0x0307, 0x0077,
+	0x0307, 0x0057, 0x0323, 0x0077, 0x0323, 0x0058, 0x0307, 0x0078,
+	0x0307, 0x0058, 0x0308, 0x0078, 0x0308, 0x0059, 0x0307, 0x0079,
+	0x0307, 0x005a, 0x0302, 0x007a, 0x0302, 0x005a, 0x0323, 0x007a,
+	0x0323, 0x005a, 0x0331, 0x007a, 0x0331, 0x0068, 0x0331, 0x0074,
+	0x0308, 0x0077, 0x030a, 0x0079, 0x030a, 0x017f, 0x0307, 0x0041,
+	0x0323, 0x0061, 0x0323, 0x0041, 0x0309, 0x0061, 0x0309, 0x0041,
+	0x0302, 0x0301, 0x0061, 0x0302, 0x0301, 0x0041, 0x0302, 0x0300,
+	0x0061, 0x0302, 0x0300, 0x0041, 0x0302, 0x0309, 0x0061, 0x0302,
+	0x0309, 0x0041, 0x0302, 0x0303, 0x0061, 0x0302, 0x0303, 0x0041,
+	0x0323, 0x0302, 0x0061, 0x0323, 0x0302, 0x0041, 0x0306, 0x0301,
+	0x0061, 0x0306, 0x0301, 0x0041, 0x0306, 0x0300, 0x0061, 0x0306,
+	0x0300, 0x0041, 0x0306, 0x0309, 0x0061, 0x0306, 0x0309, 0x0041,
+	0x0306, 0x0303, 0x0061, 0x0306, 0x0303, 0x0041, 0x0323, 0x0306,
+	0x0061, 0x0323, 0x0306, 0x0045, 0x0323, 0x0065, 0x0323, 0x0045,
+	0x0309, 0x0065, 0x0309, 0x0045, 0x0303, 0x0065, 0x0303, 0x0045,
+	0x0302, 0x0301, 0x0065, 0x0302, 0x0301, 0x0045, 0x0302, 0x0300,
+	0x0065, 0x0302, 0x0300, 0x0045, 0x0302, 0x0309, 0x0065, 0x0302,
+	0x0309, 0x0045, 0x0302, 0x0303, 0x0065, 0x0302, 0x0303, 0x0045,
+	0x0323, 0x0302, 0x0065, 0x0323, 0x0302, 0x0049, 0x0309, 0x0069,
+	0x0309, 0x0049, 0x0323, 0x0069, 0x0323, 0x004f, 0x0323, 0x006f,
+	0x0323, 0x004f, 0x0309, 0x006f, 0x0309, 0x004f, 0x0302, 0x0301,
+	0x006f, 0x0302, 0x0301, 0x004f, 0x0302, 0x0300, 0x006f, 0x0302,
+	0x0300, 0x004f, 0x0302, 0x0309, 0x006f, 0x0302, 0x0309, 0x004f,
+	0x0302, 0x0303, 0x006f, 0x0302, 0x0303, 0x004f, 0x0323, 0x0302,
+	0x006f, 0x0323, 0x0302, 0x004f, 0x031b, 0x0301, 0x006f, 0x031b,
+	0x0301, 0x004f, 0x031b, 0x0300, 0x006f, 0x031b, 0x0300, 0x004f,
+	0x031b, 0x0309, 0x006f, 0x031b, 0x0309, 0x004f, 0x031b, 0x0303,
+	0x006f, 0x031b, 0x0303, 0x004f, 0x031b, 0x0323, 0x006f, 0x031b,
+	0x0323, 0x0055, 0x0323, 0x0075, 0x0323, 0x0055, 0x0309, 0x0075,
+	0x0309, 0x0055, 0x031b, 0x0301, 0x0075, 0x031b, 0x0301, 0x0055,
+	0x031b, 0x0300, 0x0075, 0x031b, 0x0300, 0x0055, 0x031b, 0x0309,
+	0x0075, 0x031b, 0x0309, 0x0055, 0x031b, 0x0303, 0x0075, 0x031b,
+	0x0303, 0x0055, 0x031b, 0x0323, 0x0075, 0x031b, 0x0323, 0x0059,
+	0x0300, 0x0079, 0x0300, 0x0059, 0x0323, 0x0079, 0x0323, 0x0059,
+	0x0309, 0x0079, 0x0309, 0x0059, 0x0303, 0x0079, 0x0303, 0x03b1,
+	0x0313, 0x03b1, 0x0314, 0x03b1, 0x0313, 0x0300, 0x03b1, 0x0314,
+	0x0300, 0x03b1, 0x0313, 0x0301, 0x03b1, 0x0314, 0x0301, 0x03b1,
+	0x0313, 0x0342, 0x03b1, 0x0314, 0x0342, 0x0391, 0x0313, 0x0391,
+	0x0314, 0x0391, 0x0313, 0x0300, 0x0391, 0x0314, 0x0300, 0x0391,
+	0x0313, 0x0301, 0x0391, 0x0314, 0x0301, 0x0391, 0x0313, 0x0342,
+	0x0391, 0x0314, 0x0342, 0x03b5, 0x0313, 0x03b5, 0x0314, 0x03b5,
+	0x0313, 0x0300, 0x03b5, 0x0314, 0x0300, 0x03b5, 0x0313, 0x0301,
+	0x03b5, 0x0314, 0x0301, 0x0395, 0x0313, 0x0395, 0x0314, 0x0395,
+	0x0313, 0x0300, 0x0395, 0x0314, 0x0300, 0x0395, 0x0313, 0x0301,
+	0x0395, 0x0314, 0x0301, 0x03b7, 0x0313, 0x03b7, 0x0314, 0x03b7,
+	0x0313, 0x0300, 0x03b7, 0x0314, 0x0300, 0x03b7, 0x0313, 0x0301,
+	0x03b7, 0x0314, 0x0301, 0x03b7, 0x0313, 0x0342, 0x03b7, 0x0314,
+	0x0342, 0x0397, 0x0313, 0x0397, 0x0314, 0x0397, 0x0313, 0x0300,
+	0x0397, 0x0314, 0x0300, 0x0397, 0x0313, 0x0301, 0x0397, 0x0314,
+	0x0301, 0x0397, 0x0313, 0x0342, 0x0397, 0x0314, 0x0342, 0x03b9,
+	0x0313, 0x03b9, 0x0314, 0x03b9, 0x0313, 0x0300, 0x03b9, 0x0314,
+	0x0300, 0x03b9, 0x0313, 0x0301, 0x03b9, 0x0314, 0x0301, 0x03b9,
+	0x0313, 0x0342, 0x03b9, 0x0314, 0x0342, 0x0399, 0x0313, 0x0399,
+	0x0314, 0x0399, 0x0313, 0x0300, 0x0399, 0x0314, 0x0300, 0x0399,
+	0x0313, 0x0301, 0x0399, 0x0314, 0x0301, 0x0399, 0x0313, 0x0342,
+	0x0399, 0x0314, 0x0342, 0x03bf, 0x0313, 0x03bf, 0x0314, 0x03bf,
+	0x0313, 0x0300, 0x03bf, 0x0314, 0x0300, 0x03bf, 0x0313, 0x0301,
+	0x03bf, 0x0314, 0x0301, 0x039f, 0x0313, 0x039f, 0x0314, 0x039f,
+	0x0313, 0x0300, 0x039f, 0x0314, 0x0300, 0x039f, 0x0313, 0x0301,
+	0x039f, 0x0314, 0x0301, 0x03c5, 0x0313, 0x03c5, 0x0314, 0x03c5,
+	0x0313, 0x0300, 0x03c5, 0x0314, 0x0300, 0x03c5, 0x0313, 0x0301,
+	0x03c5, 0x0314, 0x0301, 0x03c5, 0x0313, 0x0342, 0x03c5, 0x0314,
+	0x0342, 0x03a5, 0x0314, 0x03a5, 0x0314, 0x0300, 0x03a5, 0x0314,
+	0x0301, 0x03a5, 0x0314, 0x0342, 0x03c9, 0x0313, 0x03c9, 0x0314,
+	0x03c9, 0x0313, 0x0300, 0x03c9, 0x0314, 0x0300, 0x03c9, 0x0313,
+	0x0301, 0x03c9, 0x0314, 0x0301, 0x03c9, 0x0313, 0x0342, 0x03c9,
+	0x0314, 0x0342, 0x03a9, 0x0313, 0x03a9, 0x0314, 0x03a9, 0x0313,
+	0x0300, 0x03a9, 0x0314, 0x0300, 0x03a9, 0x0313, 0x0301, 0x03a9,
+	0x0314, 0x0301, 0x03a9, 0x0313, 0x0342, 0x03a9, 0x0314, 0x0342,
+	0x03b1, 0x0300, 0x03b1, 0x0301, 0x03b5, 0x0300, 0x03b5, 0x0301,
+	0x03b7, 0x0300, 0x03b7, 0x0301, 0x03b9, 0x0300, 0x03b9, 0x0301,
+	0x03bf, 0x0300, 0x03bf, 0x0301, 0x03c5, 0x0300, 0x03c5, 0x0301,
+	0x03c9, 0x0300, 0x03c9, 0x0301, 0x03b1, 0x0345, 0x0313, 0x03b1,
+	0x0345, 0x0314, 0x03b1, 0x0345, 0x0313, 0x0300, 0x03b1, 0x0345,
+	0x0314, 0x0300, 0x03b1, 0x0345, 0x0313, 0x0301, 0x03b1, 0x0345,
+	0x0314, 0x0301, 0x03b1, 0x0345, 0x0313, 0x0342, 0x03b1, 0x0345,
+	0x0314, 0x0342, 0x0391, 0x0345, 0x0313, 0x0391, 0x0345, 0x0314,
+	0x0391, 0x0345, 0x0313, 0x0300, 0x0391, 0x0345, 0x0314, 0x0300,
+	0x0391, 0x0345, 0x0313, 0x0301, 0x0391, 0x0345, 0x0314, 0x0301,
+	0x0391, 0x0345, 0x0313, 0x0342, 0x0391, 0x0345, 0x0314, 0x0342,
+	0x03b7, 0x0345, 0x0313, 0x03b7, 0x0345, 0x0314, 0x03b7, 0x0345,
+	0x0313, 0x0300, 0x03b7, 0x0345, 0x0314, 0x0300, 0x03b7, 0x0345,
+	0x0313, 0x0301, 0x03b7, 0x0345, 0x0314, 0x0301, 0x03b7, 0x0345,
+	0x0313, 0x0342, 0x03b7, 0x0345, 0x0314, 0x0342, 0x0397, 0x0345,
+	0x0313, 0x0397, 0x0345, 0x0314, 0x0397, 0x0345, 0x0313, 0x0300,
+	0x0397, 0x0345, 0x0314, 0x0300, 0x0397, 0x0345, 0x0313, 0x0301,
+	0x0397, 0x0345, 0x0314, 0x0301, 0x0397, 0x0345, 0x0313, 0x0342,
+	0x0397, 0x0345, 0x0314, 0x0342, 0x03c9, 0x0345, 0x0313, 0x03c9,
+	0x0345, 0x0314, 0x03c9, 0x0345, 0x0313, 0x0300, 0x03c9, 0x0345,
+	0x0314, 0x0300, 0x03c9, 0x0345, 0x0313, 0x0301, 0x03c9, 0x0345,
+	0x0314, 0x0301, 0x03c9, 0x0345, 0x0313, 0x0342, 0x03c9, 0x0345,
+	0x0314, 0x0342, 0x03a9, 0x0345, 0x0313, 0x03a9, 0x0345, 0x0314,
+	0x03a9, 0x0345, 0x0313, 0x0300, 0x03a9, 0x0345, 0x0314, 0x0300,
+	0x03a9, 0x0345, 0x0313, 0x0301, 0x03a9, 0x0345, 0x0314, 0x0301,
+	0x03a9, 0x0345, 0x0313, 0x0342, 0x03a9, 0x0345, 0x0314, 0x0342,
+	0x03b1, 0x0306, 0x03b1, 0x0304, 0x03b1, 0x0345, 0x0300, 0x03b1,
+	0x0345, 0x03b1, 0x0345, 0x0301, 0x03b1, 0x0342, 0x03b1, 0x0345,
+	0x0342, 0x0391, 0x0306, 0x0391, 0x0304, 0x0391, 0x0300, 0x0391,
+	0x0301, 0x0391, 0x0345, 0x03b9, 0x00a8, 0x0342, 0x03b7, 0x0345,
+	0x0300, 0x03b7, 0x0345, 0x03b7, 0x0345, 0x0301, 0x03b7, 0x0342,
+	0x03b7, 0x0345, 0x0342, 0x0395, 0x0300, 0x0395, 0x0301, 0x0397,
+	0x0300, 0x0397, 0x0301, 0x0397, 0x0345, 0x1fbf, 0x0300, 0x1fbf,
+	0x0301, 0x1fbf, 0x0342, 0x03b9, 0x0306, 0x03b9, 0x0304, 0x03b9,
+	0x0308, 0x0300, 0x03b9, 0x0308, 0x0301, 0x03b9, 0x0342, 0x03b9,
+	0x0308, 0x0342, 0x0399, 0x0306, 0x0399, 0x0304, 0x0399, 0x0300,
+	0x0399, 0x0301, 0x1ffe, 0x0300, 0x1ffe, 0x0301, 0x1ffe, 0x0342,
+	0x03c5, 0x0306, 0x03c5, 0x0304, 0x03c5, 0x0308, 0x0300, 0x03c5,
+	0x0308, 0x0301, 0x03c1, 0x0313, 0x03c1, 0x0314, 0x03c5, 0x0342,
+	0x03c5, 0x0308, 0x0342, 0x03a5, 0x0306, 0x03a5, 0x0304, 0x03a5,
+	0x0300, 0x03a5, 0x0301, 0x03a1, 0x0314, 0x00a8, 0x0300, 0x00a8,
+	0x0301, 0x0060, 0x03c9, 0x0345, 0x0300, 0x03c9, 0x0345, 0x03bf,
+	0x0345, 0x0301, 0x03c9, 0x0342, 0x03c9, 0x0345, 0x0342, 0x039f,
+	0x0300, 0x039f, 0x0301, 0x03a9, 0x0300, 0x03a9, 0x0301, 0x03a9,
+	0x0345, 0x00b4, 0x304b, 0x3099, 0x304d, 0x3099, 0x304f, 0x3099,
+	0x3051, 0x3099, 0x3053, 0x3099, 0x3055, 0x3099, 0x3057, 0x3099,
+	0x3059, 0x3099, 0x305b, 0x3099, 0x305d, 0x3099, 0x305f, 0x3099,
+	0x3061, 0x3099, 0x3064, 0x3099, 0x3066, 0x3099, 0x3068, 0x3099,
+	0x306f, 0x3099, 0x306f, 0x309a, 0x3072, 0x3099, 0x3072, 0x309a,
+	0x3075, 0x3099, 0x3075, 0x309a, 0x3078, 0x3099, 0x3078, 0x309a,
+	0x307b, 0x3099, 0x307b, 0x309a, 0x3046, 0x3099, 0x309d, 0x3099,
+	0x30ab, 0x3099, 0x30ad, 0x3099, 0x30af, 0x3099, 0x30b1, 0x3099,
+	0x30b3, 0x3099, 0x30b5, 0x3099, 0x30b7, 0x3099, 0x30b9, 0x3099,
+	0x30bb, 0x3099, 0x30bd, 0x3099, 0x30bf, 0x3099, 0x30c1, 0x3099,
+	0x30c4, 0x3099, 0x30c6, 0x3099, 0x30c8, 0x3099, 0x30cf, 0x3099,
+	0x30cf, 0x309a, 0x30d2, 0x3099, 0x30d2, 0x309a, 0x30d5, 0x3099,
+	0x30d5, 0x309a, 0x30d8, 0x3099, 0x30d8, 0x309a, 0x30db, 0x3099,
+	0x30db, 0x309a, 0x30a6, 0x3099, 0x30ef, 0x3099, 0x30f0, 0x3099,
+	0x30f1, 0x3099, 0x30f2, 0x3099, 0x30fd, 0x3099, 0x05f2, 0x05b7,
+	0x05e9, 0x05c1, 0x05e9, 0x05c2, 0x05e9, 0x05bc, 0x05c1, 0x05e9,
+	0x05bc, 0x05c2, 0x05d0, 0x05b7, 0x05d0, 0x05b8, 0x05d0, 0x05bc,
+	0x05d1, 0x05bc, 0x05d2, 0x05bc, 0x05d3, 0x05bc, 0x05d4, 0x05bc,
+	0x05d5, 0x05bc, 0x05d6, 0x05bc, 0x05d8, 0x05bc, 0x05d9, 0x05bc,
+	0x05da, 0x05bc, 0x05db, 0x05bc, 0x05dc, 0x05bc, 0x05de, 0x05bc,
+	0x05e0, 0x05bc, 0x05e1, 0x05bc, 0x05e3, 0x05bc, 0x05e4, 0x05bc,
+	0x05e6, 0x05bc, 0x05e7, 0x05bc, 0x05e8, 0x05bc, 0x05e9, 0x05bc,
+	0x05ea, 0x05bc, 0x05d5, 0x05b9, 0x05d1, 0x05bf, 0x05db, 0x05bf,
+	0x05e4, 0x05bf
+};
+
+u16 hfsplus_compose_table[] = {
+	/* base */
+	0x0000, 0x0050,  0x0300, 0x00a4,  0x0301, 0x00e4,  0x0302, 0x015c,
+	0x0303, 0x0192,  0x0304, 0x01b4,  0x0306, 0x01e6,  0x0307, 0x0220,
+	0x0308, 0x0270,  0x0309, 0x02d2,  0x030a, 0x02ec,  0x030b, 0x02fa,
+	0x030c, 0x0308,  0x030d, 0x034c,  0x030f, 0x0370,  0x0311, 0x038e,
+	0x0313, 0x03a8,  0x0314, 0x03c6,  0x031b, 0x03e8,  0x0323, 0x03f2,
+	0x0324, 0x0440,  0x0325, 0x0446,  0x0327, 0x044c,  0x0328, 0x047a,
+	0x032d, 0x0490,  0x032e, 0x04aa,  0x0330, 0x04b0,  0x0331, 0x04be,
+	0x0342, 0x04e2,  0x0345, 0x04f4,  0x05b7, 0x0504,  0x05b8, 0x050a,
+	0x05b9, 0x050e,  0x05bc, 0x0512,  0x05bf, 0x0540,  0x05c1, 0x0548,
+	0x05c2, 0x054c,  0x093c, 0x0550,  0x09bc, 0x0568,  0x09be, 0x0572,
+	0x09d7, 0x0576,  0x0a3c, 0x057a,  0x0b3c, 0x0586,  0x0b3e, 0x058e,
+	0x0b56, 0x0592,  0x0b57, 0x0596,  0x0bbe, 0x059a,  0x0bd7, 0x05a0,
+	0x0c56, 0x05a6,  0x0cc2, 0x05aa,  0x0cd5, 0x05ae,  0x0cd6, 0x05b4,
+	0x0d3e, 0x05b8,  0x0d57, 0x05be,  0x0e32, 0x05c2,  0x0eb2, 0x05c6,
+	0x0f71, 0x05ca,  0x0f80, 0x05d2,  0x0fb5, 0x05d8,  0x0fb7, 0x05de,
+	0x1100, 0x00a2,  0x1101, 0x00a2,  0x1102, 0x00a2,  0x1103, 0x00a2,
+	0x1104, 0x00a2,  0x1105, 0x00a2,  0x1106, 0x00a2,  0x1107, 0x00a2,
+	0x1108, 0x00a2,  0x1109, 0x00a2,  0x110a, 0x00a2,  0x110b, 0x00a2,
+	0x110c, 0x00a2,  0x110d, 0x00a2,  0x110e, 0x00a2,  0x110f, 0x00a2,
+	0x1110, 0x00a2,  0x1111, 0x00a2,  0x1112, 0x00a2,  0x3099, 0x05f4,
+	0x309a, 0x0656,
+	/* hangul marker */
+	0xffff, 0x0000,
+	/* 0x0300 */
+	0x0340, 0x001f,  0x0041, 0x066c,  0x0045, 0x066e,  0x0049, 0x0670,
+	0x004f, 0x0672,  0x0055, 0x0674,  0x0057, 0x0676,  0x0059, 0x0678,
+	0x0061, 0x067a,  0x0065, 0x067c,  0x0069, 0x067e,  0x006f, 0x0680,
+	0x0075, 0x0682,  0x0077, 0x0684,  0x0079, 0x0686,  0x00a8, 0x0688,
+	0x0391, 0x068a,  0x0395, 0x068c,  0x0397, 0x068e,  0x0399, 0x0690,
+	0x039f, 0x0692,  0x03a5, 0x0694,  0x03a9, 0x0696,  0x03b1, 0x0698,
+	0x03b5, 0x069a,  0x03b7, 0x069c,  0x03b9, 0x069e,  0x03bf, 0x06a0,
+	0x03c5, 0x06a2,  0x03c9, 0x06a4,  0x1fbf, 0x06a6,  0x1ffe, 0x06a8,
+	/* 0x0301 */
+	0x0341, 0x003b,  0x0041, 0x06aa,  0x0043, 0x06ac,  0x0045, 0x06ae,
+	0x0047, 0x06b0,  0x0049, 0x06b2,  0x004b, 0x06b4,  0x004c, 0x06b6,
+	0x004d, 0x06b8,  0x004e, 0x06ba,  0x004f, 0x06bc,  0x0050, 0x06be,
+	0x0052, 0x06c0,  0x0053, 0x06c2,  0x0055, 0x06c6,  0x0057, 0x06c8,
+	0x0059, 0x06ca,  0x005a, 0x06cc,  0x0061, 0x06ce,  0x0063, 0x06d0,
+	0x0065, 0x06d2,  0x0067, 0x06d4,  0x0069, 0x06d6,  0x006b, 0x06d8,
+	0x006c, 0x06da,  0x006d, 0x06dc,  0x006e, 0x06de,  0x006f, 0x06e0,
+	0x0070, 0x06e2,  0x0072, 0x06e4,  0x0073, 0x06e6,  0x0075, 0x06ea,
+	0x0077, 0x06ec,  0x0079, 0x06ee,  0x007a, 0x06f0,  0x00a8, 0x06f2,
+	0x00c6, 0x06f4,  0x00d8, 0x06f6,  0x00e6, 0x06f8,  0x00f8, 0x06fa,
+	0x0391, 0x06fc,  0x0395, 0x06fe,  0x0397, 0x0700,  0x0399, 0x0702,
+	0x039f, 0x0704,  0x03a5, 0x0706,  0x03a9, 0x0708,  0x03b1, 0x070a,
+	0x03b5, 0x070c,  0x03b7, 0x070e,  0x03b9, 0x0710,  0x03bf, 0x0712,
+	0x03c5, 0x0714,  0x03c9, 0x0716,  0x0413, 0x0718,  0x041a, 0x071a,
+	0x0433, 0x071c,  0x043a, 0x071e,  0x1fbf, 0x0720,  0x1ffe, 0x0722,
+	/* 0x0302 */
+	0x0000, 0x001a,  0x0041, 0x0724,  0x0043, 0x072e,  0x0045, 0x0730,
+	0x0047, 0x073a,  0x0048, 0x073c,  0x0049, 0x073e,  0x004a, 0x0740,
+	0x004f, 0x0742,  0x0053, 0x074c,  0x0055, 0x074e,  0x0057, 0x0750,
+	0x0059, 0x0752,  0x005a, 0x0754,  0x0061, 0x0756,  0x0063, 0x0760,
+	0x0065, 0x0762,  0x0067, 0x076c,  0x0068, 0x076e,  0x0069, 0x0770,
+	0x006a, 0x0772,  0x006f, 0x0774,  0x0073, 0x077e,  0x0075, 0x0780,
+	0x0077, 0x0782,  0x0079, 0x0784,  0x007a, 0x0786,
+	/* 0x0303 */
+	0x0000, 0x0010,  0x0041, 0x0788,  0x0045, 0x078a,  0x0049, 0x078c,
+	0x004e, 0x078e,  0x004f, 0x0790,  0x0055, 0x0796,  0x0056, 0x079a,
+	0x0059, 0x079c,  0x0061, 0x079e,  0x0065, 0x07a0,  0x0069, 0x07a2,
+	0x006e, 0x07a4,  0x006f, 0x07a6,  0x0075, 0x07ac,  0x0076, 0x07b0,
+	0x0079, 0x07b2,
+	/* 0x0304 */
+	0x0000, 0x0018,  0x0041, 0x07b4,  0x0045, 0x07b6,  0x0047, 0x07bc,
+	0x0049, 0x07be,  0x004f, 0x07c0,  0x0055, 0x07c6,  0x0061, 0x07ca,
+	0x0065, 0x07cc,  0x0067, 0x07d2,  0x0069, 0x07d4,  0x006f, 0x07d6,
+	0x0075, 0x07dc,  0x00c6, 0x07e0,  0x00e6, 0x07e2,  0x0391, 0x07e4,
+	0x0399, 0x07e6,  0x03a5, 0x07e8,  0x03b1, 0x07ea,  0x03b9, 0x07ec,
+	0x03c5, 0x07ee,  0x0418, 0x07f0,  0x0423, 0x07f2,  0x0438, 0x07f4,
+	0x0443, 0x07f6,
+	/* 0x0306 */
+	0x0000, 0x001c,  0x0041, 0x07f8,  0x0045, 0x0802,  0x0047, 0x0804,
+	0x0049, 0x0806,  0x004f, 0x0808,  0x0055, 0x080a,  0x0061, 0x080c,
+	0x0065, 0x0816,  0x0067, 0x0818,  0x0069, 0x081a,  0x006f, 0x081c,
+	0x0075, 0x081e,  0x0391, 0x0820,  0x0399, 0x0822,  0x03a5, 0x0824,
+	0x03b1, 0x0826,  0x03b9, 0x0828,  0x03c5, 0x082a,  0x0410, 0x082c,
+	0x0415, 0x082e,  0x0416, 0x0830,  0x0418, 0x0832,  0x0423, 0x0834,
+	0x0430, 0x0836,  0x0435, 0x0838,  0x0436, 0x083a,  0x0438, 0x083c,
+	0x0443, 0x083e,
+	/* 0x0307 */
+	0x0000, 0x0027,  0x0041, 0x0840,  0x0042, 0x0844,  0x0043, 0x0846,
+	0x0044, 0x0848,  0x0045, 0x084a,  0x0046, 0x084c,  0x0047, 0x084e,
+	0x0048, 0x0850,  0x0049, 0x0852,  0x004d, 0x0854,  0x004e, 0x0856,
+	0x0050, 0x0858,  0x0052, 0x085a,  0x0053, 0x085c,  0x0054, 0x085e,
+	0x0057, 0x0860,  0x0058, 0x0862,  0x0059, 0x0864,  0x005a, 0x0866,
+	0x0061, 0x0868,  0x0062, 0x086c,  0x0063, 0x086e,  0x0064, 0x0870,
+	0x0065, 0x0872,  0x0066, 0x0874,  0x0067, 0x0876,  0x0068, 0x0878,
+	0x006d, 0x087a,  0x006e, 0x087c,  0x0070, 0x087e,  0x0072, 0x0880,
+	0x0073, 0x0882,  0x0074, 0x0884,  0x0077, 0x0886,  0x0078, 0x0888,
+	0x0079, 0x088a,  0x007a, 0x088c,  0x017f, 0x088e,  0x0306, 0x0890,
+	/* 0x0308 */
+	0x0000, 0x0030,  0x0041, 0x0892,  0x0045, 0x0896,  0x0048, 0x0898,
+	0x0049, 0x089a,  0x004f, 0x089e,  0x0055, 0x08a0,  0x0057, 0x08aa,
+	0x0058, 0x08ac,  0x0059, 0x08ae,  0x0061, 0x08b0,  0x0065, 0x08b4,
+	0x0068, 0x08b6,  0x0069, 0x08b8,  0x006f, 0x08bc,  0x0074, 0x08be,
+	0x0075, 0x08c0,  0x0077, 0x08ca,  0x0078, 0x08cc,  0x0079, 0x08ce,
+	0x018f, 0x08d0,  0x019f, 0x08d2,  0x0259, 0x08d4,  0x0275, 0x08d6,
+	0x0399, 0x08d8,  0x03a5, 0x08da,  0x03b9, 0x08dc,  0x03c5, 0x08e6,
+	0x03d2, 0x08f0,  0x0406, 0x08f2,  0x0410, 0x08f4,  0x0415, 0x08f6,
+	0x0416, 0x08f8,  0x0417, 0x08fa,  0x0418, 0x08fc,  0x041e, 0x08fe,
+	0x0423, 0x0900,  0x0427, 0x0902,  0x042b, 0x0904,  0x0430, 0x0906,
+	0x0435, 0x0908,  0x0436, 0x090a,  0x0437, 0x090c,  0x0438, 0x090e,
+	0x043e, 0x0910,  0x0443, 0x0912,  0x0447, 0x0914,  0x044b, 0x0916,
+	0x0456, 0x0918,
+	/* 0x0309 */
+	0x0000, 0x000c,  0x0041, 0x091a,  0x0045, 0x091c,  0x0049, 0x091e,
+	0x004f, 0x0920,  0x0055, 0x0922,  0x0059, 0x0924,  0x0061, 0x0926,
+	0x0065, 0x0928,  0x0069, 0x092a,  0x006f, 0x092c,  0x0075, 0x092e,
+	0x0079, 0x0930,
+	/* 0x030a */
+	0x0000, 0x0006,  0x0041, 0x0932,  0x0055, 0x0936,  0x0061, 0x0938,
+	0x0075, 0x093c,  0x0077, 0x093e,  0x0079, 0x0940,
+	/* 0x030b */
+	0x0000, 0x0006,  0x004f, 0x0942,  0x0055, 0x0944,  0x006f, 0x0946,
+	0x0075, 0x0948,  0x0423, 0x094a,  0x0443, 0x094c,
+	/* 0x030c */
+	0x0000, 0x0021,  0x0041, 0x094e,  0x0043, 0x0950,  0x0044, 0x0952,
+	0x0045, 0x0954,  0x0047, 0x0956,  0x0049, 0x0958,  0x004b, 0x095a,
+	0x004c, 0x095c,  0x004e, 0x095e,  0x004f, 0x0960,  0x0052, 0x0962,
+	0x0053, 0x0964,  0x0054, 0x0968,  0x0055, 0x096a,  0x005a, 0x096c,
+	0x0061, 0x096e,  0x0063, 0x0970,  0x0064, 0x0972,  0x0065, 0x0974,
+	0x0067, 0x0976,  0x0069, 0x0978,  0x006a, 0x097a,  0x006b, 0x097c,
+	0x006c, 0x097e,  0x006e, 0x0980,  0x006f, 0x0982,  0x0072, 0x0984,
+	0x0073, 0x0986,  0x0074, 0x098a,  0x0075, 0x098c,  0x007a, 0x098e,
+	0x01b7, 0x0990,  0x0292, 0x0992,
+	/* 0x030d */
+	0x0000, 0x0011,  0x00a8, 0x0994,  0x0308, 0x0996,  0x0391, 0x0998,
+	0x0395, 0x099a,  0x0397, 0x099c,  0x0399, 0x099e,  0x039f, 0x09a0,
+	0x03a5, 0x09a2,  0x03a9, 0x09a4,  0x03b1, 0x09a6,  0x03b5, 0x09a8,
+	0x03b7, 0x09aa,  0x03b9, 0x09ac,  0x03bf, 0x09ae,  0x03c5, 0x09b0,
+	0x03c9, 0x09b2,  0x03d2, 0x09b4,
+	/* 0x030f */
+	0x0000, 0x000e,  0x0041, 0x09b6,  0x0045, 0x09b8,  0x0049, 0x09ba,
+	0x004f, 0x09bc,  0x0052, 0x09be,  0x0055, 0x09c0,  0x0061, 0x09c2,
+	0x0065, 0x09c4,  0x0069, 0x09c6,  0x006f, 0x09c8,  0x0072, 0x09ca,
+	0x0075, 0x09cc,  0x0474, 0x09ce,  0x0475, 0x09d0,
+	/* 0x0311 */
+	0x0000, 0x000c,  0x0041, 0x09d2,  0x0045, 0x09d4,  0x0049, 0x09d6,
+	0x004f, 0x09d8,  0x0052, 0x09da,  0x0055, 0x09dc,  0x0061, 0x09de,
+	0x0065, 0x09e0,  0x0069, 0x09e2,  0x006f, 0x09e4,  0x0072, 0x09e6,
+	0x0075, 0x09e8,
+	/* 0x0313 */
+	0x0343, 0x000e,  0x0391, 0x09ea,  0x0395, 0x09f2,  0x0397, 0x09f8,
+	0x0399, 0x0a00,  0x039f, 0x0a08,  0x03a9, 0x0a0e,  0x03b1, 0x0a16,
+	0x03b5, 0x0a1e,  0x03b7, 0x0a24,  0x03b9, 0x0a2c,  0x03bf, 0x0a34,
+	0x03c1, 0x0a3a,  0x03c5, 0x0a3c,  0x03c9, 0x0a44,
+	/* 0x0314 */
+	0x0000, 0x0010,  0x0391, 0x0a4c,  0x0395, 0x0a54,  0x0397, 0x0a5a,
+	0x0399, 0x0a62,  0x039f, 0x0a6a,  0x03a1, 0x0a70,  0x03a5, 0x0a72,
+	0x03a9, 0x0a7a,  0x03b1, 0x0a82,  0x03b5, 0x0a8a,  0x03b7, 0x0a90,
+	0x03b9, 0x0a98,  0x03bf, 0x0aa0,  0x03c1, 0x0aa6,  0x03c5, 0x0aa8,
+	0x03c9, 0x0ab0,
+	/* 0x031b */
+	0x0000, 0x0004,  0x004f, 0x0ab8,  0x0055, 0x0ac4,  0x006f, 0x0ad0,
+	0x0075, 0x0adc,
+	/* 0x0323 */
+	0x0000, 0x0026,  0x0041, 0x0ae8,  0x0042, 0x0aee,  0x0044, 0x0af0,
+	0x0045, 0x0af2,  0x0048, 0x0af6,  0x0049, 0x0af8,  0x004b, 0x0afa,
+	0x004c, 0x0afc,  0x004d, 0x0b00,  0x004e, 0x0b02,  0x004f, 0x0b04,
+	0x0052, 0x0b08,  0x0053, 0x0b0c,  0x0054, 0x0b10,  0x0055, 0x0b12,
+	0x0056, 0x0b14,  0x0057, 0x0b16,  0x0059, 0x0b18,  0x005a, 0x0b1a,
+	0x0061, 0x0b1c,  0x0062, 0x0b22,  0x0064, 0x0b24,  0x0065, 0x0b26,
+	0x0068, 0x0b2a,  0x0069, 0x0b2c,  0x006b, 0x0b2e,  0x006c, 0x0b30,
+	0x006d, 0x0b34,  0x006e, 0x0b36,  0x006f, 0x0b38,  0x0072, 0x0b3c,
+	0x0073, 0x0b40,  0x0074, 0x0b44,  0x0075, 0x0b46,  0x0076, 0x0b48,
+	0x0077, 0x0b4a,  0x0079, 0x0b4c,  0x007a, 0x0b4e,
+	/* 0x0324 */
+	0x0000, 0x0002,  0x0055, 0x0b50,  0x0075, 0x0b52,
+	/* 0x0325 */
+	0x0000, 0x0002,  0x0041, 0x0b54,  0x0061, 0x0b56,
+	/* 0x0327 */
+	0x0000, 0x0016,  0x0043, 0x0b58,  0x0044, 0x0b5c,  0x0045, 0x0b5e,
+	0x0047, 0x0b62,  0x0048, 0x0b64,  0x004b, 0x0b66,  0x004c, 0x0b68,
+	0x004e, 0x0b6a,  0x0052, 0x0b6c,  0x0053, 0x0b6e,  0x0054, 0x0b70,
+	0x0063, 0x0b72,  0x0064, 0x0b76,  0x0065, 0x0b78,  0x0067, 0x0b7c,
+	0x0068, 0x0b7e,  0x006b, 0x0b80,  0x006c, 0x0b82,  0x006e, 0x0b84,
+	0x0072, 0x0b86,  0x0073, 0x0b88,  0x0074, 0x0b8a,
+	/* 0x0328 */
+	0x0000, 0x000a,  0x0041, 0x0b8c,  0x0045, 0x0b8e,  0x0049, 0x0b90,
+	0x004f, 0x0b92,  0x0055, 0x0b96,  0x0061, 0x0b98,  0x0065, 0x0b9a,
+	0x0069, 0x0b9c,  0x006f, 0x0b9e,  0x0075, 0x0ba2,
+	/* 0x032d */
+	0x0000, 0x000c,  0x0044, 0x0ba4,  0x0045, 0x0ba6,  0x004c, 0x0ba8,
+	0x004e, 0x0baa,  0x0054, 0x0bac,  0x0055, 0x0bae,  0x0064, 0x0bb0,
+	0x0065, 0x0bb2,  0x006c, 0x0bb4,  0x006e, 0x0bb6,  0x0074, 0x0bb8,
+	0x0075, 0x0bba,
+	/* 0x032e */
+	0x0000, 0x0002,  0x0048, 0x0bbc,  0x0068, 0x0bbe,
+	/* 0x0330 */
+	0x0000, 0x0006,  0x0045, 0x0bc0,  0x0049, 0x0bc2,  0x0055, 0x0bc4,
+	0x0065, 0x0bc6,  0x0069, 0x0bc8,  0x0075, 0x0bca,
+	/* 0x0331 */
+	0x0000, 0x0011,  0x0042, 0x0bcc,  0x0044, 0x0bce,  0x004b, 0x0bd0,
+	0x004c, 0x0bd2,  0x004e, 0x0bd4,  0x0052, 0x0bd6,  0x0054, 0x0bd8,
+	0x005a, 0x0bda,  0x0062, 0x0bdc,  0x0064, 0x0bde,  0x0068, 0x0be0,
+	0x006b, 0x0be2,  0x006c, 0x0be4,  0x006e, 0x0be6,  0x0072, 0x0be8,
+	0x0074, 0x0bea,  0x007a, 0x0bec,
+	/* 0x0342 */
+	0x0000, 0x0008,  0x00a8, 0x0bee,  0x03b1, 0x0bf0,  0x03b7, 0x0bf2,
+	0x03b9, 0x0bf4,  0x03c5, 0x0bf6,  0x03c9, 0x0bf8,  0x1fbf, 0x0bfa,
+	0x1ffe, 0x0bfc,
+	/* 0x0345 */
+	0x0000, 0x0007,  0x0391, 0x0bfe,  0x0397, 0x0c04,  0x03a9, 0x0c0a,
+	0x03b1, 0x0c10,  0x03b7, 0x0c1c,  0x03bf, 0x0c28,  0x03c9, 0x0c2c,
+	/* 0x05b7 */
+	0x0000, 0x0002,  0x05d0, 0x0c36,  0x05f2, 0x0c38,
+	/* 0x05b8 */
+	0x0000, 0x0001,  0x05d0, 0x0c3a,
+	/* 0x05b9 */
+	0x0000, 0x0001,  0x05d5, 0x0c3c,
+	/* 0x05bc */
+	0x0000, 0x0016,  0x05d0, 0x0c3e,  0x05d1, 0x0c40,  0x05d2, 0x0c42,
+	0x05d3, 0x0c44,  0x05d4, 0x0c46,  0x05d5, 0x0c48,  0x05d6, 0x0c4a,
+	0x05d8, 0x0c4c,  0x05d9, 0x0c4e,  0x05da, 0x0c50,  0x05db, 0x0c52,
+	0x05dc, 0x0c54,  0x05de, 0x0c56,  0x05e0, 0x0c58,  0x05e1, 0x0c5a,
+	0x05e3, 0x0c5c,  0x05e4, 0x0c5e,  0x05e6, 0x0c60,  0x05e7, 0x0c62,
+	0x05e8, 0x0c64,  0x05e9, 0x0c66,  0x05ea, 0x0c6c,
+	/* 0x05bf */
+	0x0000, 0x0003,  0x05d1, 0x0c6e,  0x05db, 0x0c70,  0x05e4, 0x0c72,
+	/* 0x05c1 */
+	0x0000, 0x0001,  0x05e9, 0x0c74,
+	/* 0x05c2 */
+	0x0000, 0x0001,  0x05e9, 0x0c76,
+	/* 0x093c */
+	0x0000, 0x000b,  0x0915, 0x0c78,  0x0916, 0x0c7a,  0x0917, 0x0c7c,
+	0x091c, 0x0c7e,  0x0921, 0x0c80,  0x0922, 0x0c82,  0x0928, 0x0c84,
+	0x092b, 0x0c86,  0x092f, 0x0c88,  0x0930, 0x0c8a,  0x0933, 0x0c8c,
+	/* 0x09bc */
+	0x0000, 0x0004,  0x09a1, 0x0c8e,  0x09a2, 0x0c90,  0x09ac, 0x0c92,
+	0x09af, 0x0c94,
+	/* 0x09be */
+	0x0000, 0x0001,  0x09c7, 0x0c96,
+	/* 0x09d7 */
+	0x0000, 0x0001,  0x09c7, 0x0c98,
+	/* 0x0a3c */
+	0x0000, 0x0005,  0x0a16, 0x0c9a,  0x0a17, 0x0c9c,  0x0a1c, 0x0c9e,
+	0x0a21, 0x0ca0,  0x0a2b, 0x0ca2,
+	/* 0x0b3c */
+	0x0000, 0x0003,  0x0b21, 0x0ca4,  0x0b22, 0x0ca6,  0x0b2f, 0x0ca8,
+	/* 0x0b3e */
+	0x0000, 0x0001,  0x0b47, 0x0caa,
+	/* 0x0b56 */
+	0x0000, 0x0001,  0x0b47, 0x0cac,
+	/* 0x0b57 */
+	0x0000, 0x0001,  0x0b47, 0x0cae,
+	/* 0x0bbe */
+	0x0000, 0x0002,  0x0bc6, 0x0cb0,  0x0bc7, 0x0cb2,
+	/* 0x0bd7 */
+	0x0000, 0x0002,  0x0b92, 0x0cb4,  0x0bc6, 0x0cb6,
+	/* 0x0c56 */
+	0x0000, 0x0001,  0x0c46, 0x0cb8,
+	/* 0x0cc2 */
+	0x0000, 0x0001,  0x0cc6, 0x0cba,
+	/* 0x0cd5 */
+	0x0000, 0x0002,  0x0cbf, 0x0cbe,  0x0cc6, 0x0cc0,
+	/* 0x0cd6 */
+	0x0000, 0x0001,  0x0cc6, 0x0cc2,
+	/* 0x0d3e */
+	0x0000, 0x0002,  0x0d46, 0x0cc4,  0x0d47, 0x0cc6,
+	/* 0x0d57 */
+	0x0000, 0x0001,  0x0d46, 0x0cc8,
+	/* 0x0e32 */
+	0x0000, 0x0001,  0x0e4d, 0x0cca,
+	/* 0x0eb2 */
+	0x0000, 0x0001,  0x0ecd, 0x0ccc,
+	/* 0x0f71 */
+	0x0000, 0x0003,  0x0f72, 0x0cce,  0x0f74, 0x0cd0,  0x0f80, 0x0cd2,
+	/* 0x0f80 */
+	0x0000, 0x0002,  0x0fb2, 0x0cd4,  0x0fb3, 0x0cd8,
+	/* 0x0fb5 */
+	0x0000, 0x0002,  0x0f40, 0x0cdc,  0x0f90, 0x0cde,
+	/* 0x0fb7 */
+	0x0000, 0x000a,  0x0f42, 0x0ce0,  0x0f4c, 0x0ce2,  0x0f51, 0x0ce4,
+	0x0f56, 0x0ce6,  0x0f5b, 0x0ce8,  0x0f92, 0x0cea,  0x0f9c, 0x0cec,
+	0x0fa1, 0x0cee,  0x0fa6, 0x0cf0,  0x0fab, 0x0cf2,
+	/* 0x3099 */
+	0x0000, 0x0030,  0x3046, 0x0cf4,  0x304b, 0x0cf6,  0x304d, 0x0cf8,
+	0x304f, 0x0cfa,  0x3051, 0x0cfc,  0x3053, 0x0cfe,  0x3055, 0x0d00,
+	0x3057, 0x0d02,  0x3059, 0x0d04,  0x305b, 0x0d06,  0x305d, 0x0d08,
+	0x305f, 0x0d0a,  0x3061, 0x0d0c,  0x3064, 0x0d0e,  0x3066, 0x0d10,
+	0x3068, 0x0d12,  0x306f, 0x0d14,  0x3072, 0x0d16,  0x3075, 0x0d18,
+	0x3078, 0x0d1a,  0x307b, 0x0d1c,  0x309d, 0x0d1e,  0x30a6, 0x0d20,
+	0x30ab, 0x0d22,  0x30ad, 0x0d24,  0x30af, 0x0d26,  0x30b1, 0x0d28,
+	0x30b3, 0x0d2a,  0x30b5, 0x0d2c,  0x30b7, 0x0d2e,  0x30b9, 0x0d30,
+	0x30bb, 0x0d32,  0x30bd, 0x0d34,  0x30bf, 0x0d36,  0x30c1, 0x0d38,
+	0x30c4, 0x0d3a,  0x30c6, 0x0d3c,  0x30c8, 0x0d3e,  0x30cf, 0x0d40,
+	0x30d2, 0x0d42,  0x30d5, 0x0d44,  0x30d8, 0x0d46,  0x30db, 0x0d48,
+	0x30ef, 0x0d4a,  0x30f0, 0x0d4c,  0x30f1, 0x0d4e,  0x30f2, 0x0d50,
+	0x30fd, 0x0d52,
+	/* 0x309a */
+	0x0000, 0x000a,  0x306f, 0x0d54,  0x3072, 0x0d56,  0x3075, 0x0d58,
+	0x3078, 0x0d5a,  0x307b, 0x0d5c,  0x30cf, 0x0d5e,  0x30d2, 0x0d60,
+	0x30d5, 0x0d62,  0x30d8, 0x0d64,  0x30db, 0x0d66,
+	/* 0x0041 0x0300 */
+	0x00c0, 0x0000,
+	/* 0x0045 0x0300 */
+	0x00c8, 0x0000,
+	/* 0x0049 0x0300 */
+	0x00cc, 0x0000,
+	/* 0x004f 0x0300 */
+	0x00d2, 0x0000,
+	/* 0x0055 0x0300 */
+	0x00d9, 0x0000,
+	/* 0x0057 0x0300 */
+	0x1e80, 0x0000,
+	/* 0x0059 0x0300 */
+	0x1ef2, 0x0000,
+	/* 0x0061 0x0300 */
+	0x00e0, 0x0000,
+	/* 0x0065 0x0300 */
+	0x00e8, 0x0000,
+	/* 0x0069 0x0300 */
+	0x00ec, 0x0000,
+	/* 0x006f 0x0300 */
+	0x00f2, 0x0000,
+	/* 0x0075 0x0300 */
+	0x00f9, 0x0000,
+	/* 0x0077 0x0300 */
+	0x1e81, 0x0000,
+	/* 0x0079 0x0300 */
+	0x1ef3, 0x0000,
+	/* 0x00a8 0x0300 */
+	0x1fed, 0x0000,
+	/* 0x0391 0x0300 */
+	0x1fba, 0x0000,
+	/* 0x0395 0x0300 */
+	0x1fc8, 0x0000,
+	/* 0x0397 0x0300 */
+	0x1fca, 0x0000,
+	/* 0x0399 0x0300 */
+	0x1fda, 0x0000,
+	/* 0x039f 0x0300 */
+	0x1ff8, 0x0000,
+	/* 0x03a5 0x0300 */
+	0x1fea, 0x0000,
+	/* 0x03a9 0x0300 */
+	0x1ffa, 0x0000,
+	/* 0x03b1 0x0300 */
+	0x1f70, 0x0000,
+	/* 0x03b5 0x0300 */
+	0x1f72, 0x0000,
+	/* 0x03b7 0x0300 */
+	0x1f74, 0x0000,
+	/* 0x03b9 0x0300 */
+	0x1f76, 0x0000,
+	/* 0x03bf 0x0300 */
+	0x1f78, 0x0000,
+	/* 0x03c5 0x0300 */
+	0x1f7a, 0x0000,
+	/* 0x03c9 0x0300 */
+	0x1f7c, 0x0000,
+	/* 0x1fbf 0x0300 */
+	0x1fcd, 0x0000,
+	/* 0x1ffe 0x0300 */
+	0x1fdd, 0x0000,
+	/* 0x0041 0x0301 */
+	0x00c1, 0x0000,
+	/* 0x0043 0x0301 */
+	0x0106, 0x0000,
+	/* 0x0045 0x0301 */
+	0x00c9, 0x0000,
+	/* 0x0047 0x0301 */
+	0x01f4, 0x0000,
+	/* 0x0049 0x0301 */
+	0x00cd, 0x0000,
+	/* 0x004b 0x0301 */
+	0x1e30, 0x0000,
+	/* 0x004c 0x0301 */
+	0x0139, 0x0000,
+	/* 0x004d 0x0301 */
+	0x1e3e, 0x0000,
+	/* 0x004e 0x0301 */
+	0x0143, 0x0000,
+	/* 0x004f 0x0301 */
+	0x00d3, 0x0000,
+	/* 0x0050 0x0301 */
+	0x1e54, 0x0000,
+	/* 0x0052 0x0301 */
+	0x0154, 0x0000,
+	/* 0x0053 0x0301 */
+	0x015a, 0x0001,  0x0307, 0x0d68,
+	/* 0x0055 0x0301 */
+	0x00da, 0x0000,
+	/* 0x0057 0x0301 */
+	0x1e82, 0x0000,
+	/* 0x0059 0x0301 */
+	0x00dd, 0x0000,
+	/* 0x005a 0x0301 */
+	0x0179, 0x0000,
+	/* 0x0061 0x0301 */
+	0x00e1, 0x0000,
+	/* 0x0063 0x0301 */
+	0x0107, 0x0000,
+	/* 0x0065 0x0301 */
+	0x00e9, 0x0000,
+	/* 0x0067 0x0301 */
+	0x01f5, 0x0000,
+	/* 0x0069 0x0301 */
+	0x00ed, 0x0000,
+	/* 0x006b 0x0301 */
+	0x1e31, 0x0000,
+	/* 0x006c 0x0301 */
+	0x013a, 0x0000,
+	/* 0x006d 0x0301 */
+	0x1e3f, 0x0000,
+	/* 0x006e 0x0301 */
+	0x0144, 0x0000,
+	/* 0x006f 0x0301 */
+	0x00f3, 0x0000,
+	/* 0x0070 0x0301 */
+	0x1e55, 0x0000,
+	/* 0x0072 0x0301 */
+	0x0155, 0x0000,
+	/* 0x0073 0x0301 */
+	0x015b, 0x0001,  0x0307, 0x0d6a,
+	/* 0x0075 0x0301 */
+	0x00fa, 0x0000,
+	/* 0x0077 0x0301 */
+	0x1e83, 0x0000,
+	/* 0x0079 0x0301 */
+	0x00fd, 0x0000,
+	/* 0x007a 0x0301 */
+	0x017a, 0x0000,
+	/* 0x00a8 0x0301 */
+	0x1fee, 0x0000,
+	/* 0x00c6 0x0301 */
+	0x01fc, 0x0000,
+	/* 0x00d8 0x0301 */
+	0x01fe, 0x0000,
+	/* 0x00e6 0x0301 */
+	0x01fd, 0x0000,
+	/* 0x00f8 0x0301 */
+	0x01ff, 0x0000,
+	/* 0x0391 0x0301 */
+	0x1fbb, 0x0000,
+	/* 0x0395 0x0301 */
+	0x1fc9, 0x0000,
+	/* 0x0397 0x0301 */
+	0x1fcb, 0x0000,
+	/* 0x0399 0x0301 */
+	0x1fdb, 0x0000,
+	/* 0x039f 0x0301 */
+	0x1ff9, 0x0000,
+	/* 0x03a5 0x0301 */
+	0x1feb, 0x0000,
+	/* 0x03a9 0x0301 */
+	0x1ffb, 0x0000,
+	/* 0x03b1 0x0301 */
+	0x1f71, 0x0000,
+	/* 0x03b5 0x0301 */
+	0x1f73, 0x0000,
+	/* 0x03b7 0x0301 */
+	0x1f75, 0x0000,
+	/* 0x03b9 0x0301 */
+	0x1f77, 0x0000,
+	/* 0x03bf 0x0301 */
+	0x1f79, 0x0000,
+	/* 0x03c5 0x0301 */
+	0x1f7b, 0x0000,
+	/* 0x03c9 0x0301 */
+	0x1f7d, 0x0000,
+	/* 0x0413 0x0301 */
+	0x0403, 0x0000,
+	/* 0x041a 0x0301 */
+	0x040c, 0x0000,
+	/* 0x0433 0x0301 */
+	0x0453, 0x0000,
+	/* 0x043a 0x0301 */
+	0x045c, 0x0000,
+	/* 0x1fbf 0x0301 */
+	0x1fce, 0x0000,
+	/* 0x1ffe 0x0301 */
+	0x1fde, 0x0000,
+	/* 0x0041 0x0302 */
+	0x00c2, 0x0004,  0x0300, 0x0d6c,  0x0301, 0x0d6e,  0x0303, 0x0d70,
+	0x0309, 0x0d72,
+	/* 0x0043 0x0302 */
+	0x0108, 0x0000,
+	/* 0x0045 0x0302 */
+	0x00ca, 0x0004,  0x0300, 0x0d74,  0x0301, 0x0d76,  0x0303, 0x0d78,
+	0x0309, 0x0d7a,
+	/* 0x0047 0x0302 */
+	0x011c, 0x0000,
+	/* 0x0048 0x0302 */
+	0x0124, 0x0000,
+	/* 0x0049 0x0302 */
+	0x00ce, 0x0000,
+	/* 0x004a 0x0302 */
+	0x0134, 0x0000,
+	/* 0x004f 0x0302 */
+	0x00d4, 0x0004,  0x0300, 0x0d7c,  0x0301, 0x0d7e,  0x0303, 0x0d80,
+	0x0309, 0x0d82,
+	/* 0x0053 0x0302 */
+	0x015c, 0x0000,
+	/* 0x0055 0x0302 */
+	0x00db, 0x0000,
+	/* 0x0057 0x0302 */
+	0x0174, 0x0000,
+	/* 0x0059 0x0302 */
+	0x0176, 0x0000,
+	/* 0x005a 0x0302 */
+	0x1e90, 0x0000,
+	/* 0x0061 0x0302 */
+	0x00e2, 0x0004,  0x0300, 0x0d84,  0x0301, 0x0d86,  0x0303, 0x0d88,
+	0x0309, 0x0d8a,
+	/* 0x0063 0x0302 */
+	0x0109, 0x0000,
+	/* 0x0065 0x0302 */
+	0x00ea, 0x0004,  0x0300, 0x0d8c,  0x0301, 0x0d8e,  0x0303, 0x0d90,
+	0x0309, 0x0d92,
+	/* 0x0067 0x0302 */
+	0x011d, 0x0000,
+	/* 0x0068 0x0302 */
+	0x0125, 0x0000,
+	/* 0x0069 0x0302 */
+	0x00ee, 0x0000,
+	/* 0x006a 0x0302 */
+	0x0135, 0x0000,
+	/* 0x006f 0x0302 */
+	0x00f4, 0x0004,  0x0300, 0x0d94,  0x0301, 0x0d96,  0x0303, 0x0d98,
+	0x0309, 0x0d9a,
+	/* 0x0073 0x0302 */
+	0x015d, 0x0000,
+	/* 0x0075 0x0302 */
+	0x00fb, 0x0000,
+	/* 0x0077 0x0302 */
+	0x0175, 0x0000,
+	/* 0x0079 0x0302 */
+	0x0177, 0x0000,
+	/* 0x007a 0x0302 */
+	0x1e91, 0x0000,
+	/* 0x0041 0x0303 */
+	0x00c3, 0x0000,
+	/* 0x0045 0x0303 */
+	0x1ebc, 0x0000,
+	/* 0x0049 0x0303 */
+	0x0128, 0x0000,
+	/* 0x004e 0x0303 */
+	0x00d1, 0x0000,
+	/* 0x004f 0x0303 */
+	0x00d5, 0x0002,  0x0301, 0x0d9c,  0x0308, 0x0d9e,
+	/* 0x0055 0x0303 */
+	0x0168, 0x0001,  0x0301, 0x0da0,
+	/* 0x0056 0x0303 */
+	0x1e7c, 0x0000,
+	/* 0x0059 0x0303 */
+	0x1ef8, 0x0000,
+	/* 0x0061 0x0303 */
+	0x00e3, 0x0000,
+	/* 0x0065 0x0303 */
+	0x1ebd, 0x0000,
+	/* 0x0069 0x0303 */
+	0x0129, 0x0000,
+	/* 0x006e 0x0303 */
+	0x00f1, 0x0000,
+	/* 0x006f 0x0303 */
+	0x00f5, 0x0002,  0x0301, 0x0da2,  0x0308, 0x0da4,
+	/* 0x0075 0x0303 */
+	0x0169, 0x0001,  0x0301, 0x0da6,
+	/* 0x0076 0x0303 */
+	0x1e7d, 0x0000,
+	/* 0x0079 0x0303 */
+	0x1ef9, 0x0000,
+	/* 0x0041 0x0304 */
+	0x0100, 0x0000,
+	/* 0x0045 0x0304 */
+	0x0112, 0x0002,  0x0300, 0x0da8,  0x0301, 0x0daa,
+	/* 0x0047 0x0304 */
+	0x1e20, 0x0000,
+	/* 0x0049 0x0304 */
+	0x012a, 0x0000,
+	/* 0x004f 0x0304 */
+	0x014c, 0x0002,  0x0300, 0x0dac,  0x0301, 0x0dae,
+	/* 0x0055 0x0304 */
+	0x016a, 0x0001,  0x0308, 0x0db0,
+	/* 0x0061 0x0304 */
+	0x0101, 0x0000,
+	/* 0x0065 0x0304 */
+	0x0113, 0x0002,  0x0300, 0x0db2,  0x0301, 0x0db4,
+	/* 0x0067 0x0304 */
+	0x1e21, 0x0000,
+	/* 0x0069 0x0304 */
+	0x012b, 0x0000,
+	/* 0x006f 0x0304 */
+	0x014d, 0x0002,  0x0300, 0x0db6,  0x0301, 0x0db8,
+	/* 0x0075 0x0304 */
+	0x016b, 0x0001,  0x0308, 0x0dba,
+	/* 0x00c6 0x0304 */
+	0x01e2, 0x0000,
+	/* 0x00e6 0x0304 */
+	0x01e3, 0x0000,
+	/* 0x0391 0x0304 */
+	0x1fb9, 0x0000,
+	/* 0x0399 0x0304 */
+	0x1fd9, 0x0000,
+	/* 0x03a5 0x0304 */
+	0x1fe9, 0x0000,
+	/* 0x03b1 0x0304 */
+	0x1fb1, 0x0000,
+	/* 0x03b9 0x0304 */
+	0x1fd1, 0x0000,
+	/* 0x03c5 0x0304 */
+	0x1fe1, 0x0000,
+	/* 0x0418 0x0304 */
+	0x04e2, 0x0000,
+	/* 0x0423 0x0304 */
+	0x04ee, 0x0000,
+	/* 0x0438 0x0304 */
+	0x04e3, 0x0000,
+	/* 0x0443 0x0304 */
+	0x04ef, 0x0000,
+	/* 0x0041 0x0306 */
+	0x0102, 0x0004,  0x0300, 0x0dbc,  0x0301, 0x0dbe,  0x0303, 0x0dc0,
+	0x0309, 0x0dc2,
+	/* 0x0045 0x0306 */
+	0x0114, 0x0000,
+	/* 0x0047 0x0306 */
+	0x011e, 0x0000,
+	/* 0x0049 0x0306 */
+	0x012c, 0x0000,
+	/* 0x004f 0x0306 */
+	0x014e, 0x0000,
+	/* 0x0055 0x0306 */
+	0x016c, 0x0000,
+	/* 0x0061 0x0306 */
+	0x0103, 0x0004,  0x0300, 0x0dc4,  0x0301, 0x0dc6,  0x0303, 0x0dc8,
+	0x0309, 0x0dca,
+	/* 0x0065 0x0306 */
+	0x0115, 0x0000,
+	/* 0x0067 0x0306 */
+	0x011f, 0x0000,
+	/* 0x0069 0x0306 */
+	0x012d, 0x0000,
+	/* 0x006f 0x0306 */
+	0x014f, 0x0000,
+	/* 0x0075 0x0306 */
+	0x016d, 0x0000,
+	/* 0x0391 0x0306 */
+	0x1fb8, 0x0000,
+	/* 0x0399 0x0306 */
+	0x1fd8, 0x0000,
+	/* 0x03a5 0x0306 */
+	0x1fe8, 0x0000,
+	/* 0x03b1 0x0306 */
+	0x1fb0, 0x0000,
+	/* 0x03b9 0x0306 */
+	0x1fd0, 0x0000,
+	/* 0x03c5 0x0306 */
+	0x1fe0, 0x0000,
+	/* 0x0410 0x0306 */
+	0x04d0, 0x0000,
+	/* 0x0415 0x0306 */
+	0x04d6, 0x0000,
+	/* 0x0416 0x0306 */
+	0x04c1, 0x0000,
+	/* 0x0418 0x0306 */
+	0x0419, 0x0000,
+	/* 0x0423 0x0306 */
+	0x040e, 0x0000,
+	/* 0x0430 0x0306 */
+	0x04d1, 0x0000,
+	/* 0x0435 0x0306 */
+	0x04d7, 0x0000,
+	/* 0x0436 0x0306 */
+	0x04c2, 0x0000,
+	/* 0x0438 0x0306 */
+	0x0439, 0x0000,
+	/* 0x0443 0x0306 */
+	0x045e, 0x0000,
+	/* 0x0041 0x0307 */
+	0x0000, 0x0001,  0x0304, 0x0dcc,
+	/* 0x0042 0x0307 */
+	0x1e02, 0x0000,
+	/* 0x0043 0x0307 */
+	0x010a, 0x0000,
+	/* 0x0044 0x0307 */
+	0x1e0a, 0x0000,
+	/* 0x0045 0x0307 */
+	0x0116, 0x0000,
+	/* 0x0046 0x0307 */
+	0x1e1e, 0x0000,
+	/* 0x0047 0x0307 */
+	0x0120, 0x0000,
+	/* 0x0048 0x0307 */
+	0x1e22, 0x0000,
+	/* 0x0049 0x0307 */
+	0x0130, 0x0000,
+	/* 0x004d 0x0307 */
+	0x1e40, 0x0000,
+	/* 0x004e 0x0307 */
+	0x1e44, 0x0000,
+	/* 0x0050 0x0307 */
+	0x1e56, 0x0000,
+	/* 0x0052 0x0307 */
+	0x1e58, 0x0000,
+	/* 0x0053 0x0307 */
+	0x1e60, 0x0000,
+	/* 0x0054 0x0307 */
+	0x1e6a, 0x0000,
+	/* 0x0057 0x0307 */
+	0x1e86, 0x0000,
+	/* 0x0058 0x0307 */
+	0x1e8a, 0x0000,
+	/* 0x0059 0x0307 */
+	0x1e8e, 0x0000,
+	/* 0x005a 0x0307 */
+	0x017b, 0x0000,
+	/* 0x0061 0x0307 */
+	0x0000, 0x0001,  0x0304, 0x0dce,
+	/* 0x0062 0x0307 */
+	0x1e03, 0x0000,
+	/* 0x0063 0x0307 */
+	0x010b, 0x0000,
+	/* 0x0064 0x0307 */
+	0x1e0b, 0x0000,
+	/* 0x0065 0x0307 */
+	0x0117, 0x0000,
+	/* 0x0066 0x0307 */
+	0x1e1f, 0x0000,
+	/* 0x0067 0x0307 */
+	0x0121, 0x0000,
+	/* 0x0068 0x0307 */
+	0x1e23, 0x0000,
+	/* 0x006d 0x0307 */
+	0x1e41, 0x0000,
+	/* 0x006e 0x0307 */
+	0x1e45, 0x0000,
+	/* 0x0070 0x0307 */
+	0x1e57, 0x0000,
+	/* 0x0072 0x0307 */
+	0x1e59, 0x0000,
+	/* 0x0073 0x0307 */
+	0x1e61, 0x0000,
+	/* 0x0074 0x0307 */
+	0x1e6b, 0x0000,
+	/* 0x0077 0x0307 */
+	0x1e87, 0x0000,
+	/* 0x0078 0x0307 */
+	0x1e8b, 0x0000,
+	/* 0x0079 0x0307 */
+	0x1e8f, 0x0000,
+	/* 0x007a 0x0307 */
+	0x017c, 0x0000,
+	/* 0x017f 0x0307 */
+	0x1e9b, 0x0000,
+	/* 0x0306 0x0307 */
+	0x0310, 0x0000,
+	/* 0x0041 0x0308 */
+	0x00c4, 0x0001,  0x0304, 0x0dd0,
+	/* 0x0045 0x0308 */
+	0x00cb, 0x0000,
+	/* 0x0048 0x0308 */
+	0x1e26, 0x0000,
+	/* 0x0049 0x0308 */
+	0x00cf, 0x0001,  0x0301, 0x0dd2,
+	/* 0x004f 0x0308 */
+	0x00d6, 0x0000,
+	/* 0x0055 0x0308 */
+	0x00dc, 0x0004,  0x0300, 0x0dd4,  0x0301, 0x0dd6,  0x0304, 0x0dd8,
+	0x030c, 0x0dda,
+	/* 0x0057 0x0308 */
+	0x1e84, 0x0000,
+	/* 0x0058 0x0308 */
+	0x1e8c, 0x0000,
+	/* 0x0059 0x0308 */
+	0x0178, 0x0000,
+	/* 0x0061 0x0308 */
+	0x00e4, 0x0001,  0x0304, 0x0ddc,
+	/* 0x0065 0x0308 */
+	0x00eb, 0x0000,
+	/* 0x0068 0x0308 */
+	0x1e27, 0x0000,
+	/* 0x0069 0x0308 */
+	0x00ef, 0x0001,  0x0301, 0x0dde,
+	/* 0x006f 0x0308 */
+	0x00f6, 0x0000,
+	/* 0x0074 0x0308 */
+	0x1e97, 0x0000,
+	/* 0x0075 0x0308 */
+	0x00fc, 0x0004,  0x0300, 0x0de0,  0x0301, 0x0de2,  0x0304, 0x0de4,
+	0x030c, 0x0de6,
+	/* 0x0077 0x0308 */
+	0x1e85, 0x0000,
+	/* 0x0078 0x0308 */
+	0x1e8d, 0x0000,
+	/* 0x0079 0x0308 */
+	0x00ff, 0x0000,
+	/* 0x018f 0x0308 */
+	0x04da, 0x0000,
+	/* 0x019f 0x0308 */
+	0x04ea, 0x0000,
+	/* 0x0259 0x0308 */
+	0x04db, 0x0000,
+	/* 0x0275 0x0308 */
+	0x04eb, 0x0000,
+	/* 0x0399 0x0308 */
+	0x03aa, 0x0000,
+	/* 0x03a5 0x0308 */
+	0x03ab, 0x0000,
+	/* 0x03b9 0x0308 */
+	0x03ca, 0x0004,  0x0300, 0x0de8,  0x0301, 0x0dea,  0x030d, 0x0dec,
+	0x0342, 0x0dee,
+	/* 0x03c5 0x0308 */
+	0x03cb, 0x0004,  0x0300, 0x0df0,  0x0301, 0x0df2,  0x030d, 0x0df4,
+	0x0342, 0x0df6,
+	/* 0x03d2 0x0308 */
+	0x03d4, 0x0000,
+	/* 0x0406 0x0308 */
+	0x0407, 0x0000,
+	/* 0x0410 0x0308 */
+	0x04d2, 0x0000,
+	/* 0x0415 0x0308 */
+	0x0401, 0x0000,
+	/* 0x0416 0x0308 */
+	0x04dc, 0x0000,
+	/* 0x0417 0x0308 */
+	0x04de, 0x0000,
+	/* 0x0418 0x0308 */
+	0x04e4, 0x0000,
+	/* 0x041e 0x0308 */
+	0x04e6, 0x0000,
+	/* 0x0423 0x0308 */
+	0x04f0, 0x0000,
+	/* 0x0427 0x0308 */
+	0x04f4, 0x0000,
+	/* 0x042b 0x0308 */
+	0x04f8, 0x0000,
+	/* 0x0430 0x0308 */
+	0x04d3, 0x0000,
+	/* 0x0435 0x0308 */
+	0x0451, 0x0000,
+	/* 0x0436 0x0308 */
+	0x04dd, 0x0000,
+	/* 0x0437 0x0308 */
+	0x04df, 0x0000,
+	/* 0x0438 0x0308 */
+	0x04e5, 0x0000,
+	/* 0x043e 0x0308 */
+	0x04e7, 0x0000,
+	/* 0x0443 0x0308 */
+	0x04f1, 0x0000,
+	/* 0x0447 0x0308 */
+	0x04f5, 0x0000,
+	/* 0x044b 0x0308 */
+	0x04f9, 0x0000,
+	/* 0x0456 0x0308 */
+	0x0457, 0x0000,
+	/* 0x0041 0x0309 */
+	0x1ea2, 0x0000,
+	/* 0x0045 0x0309 */
+	0x1eba, 0x0000,
+	/* 0x0049 0x0309 */
+	0x1ec8, 0x0000,
+	/* 0x004f 0x0309 */
+	0x1ece, 0x0000,
+	/* 0x0055 0x0309 */
+	0x1ee6, 0x0000,
+	/* 0x0059 0x0309 */
+	0x1ef6, 0x0000,
+	/* 0x0061 0x0309 */
+	0x1ea3, 0x0000,
+	/* 0x0065 0x0309 */
+	0x1ebb, 0x0000,
+	/* 0x0069 0x0309 */
+	0x1ec9, 0x0000,
+	/* 0x006f 0x0309 */
+	0x1ecf, 0x0000,
+	/* 0x0075 0x0309 */
+	0x1ee7, 0x0000,
+	/* 0x0079 0x0309 */
+	0x1ef7, 0x0000,
+	/* 0x0041 0x030a */
+	0x00c5, 0x0001,  0x0301, 0x0df8,
+	/* 0x0055 0x030a */
+	0x016e, 0x0000,
+	/* 0x0061 0x030a */
+	0x00e5, 0x0001,  0x0301, 0x0dfa,
+	/* 0x0075 0x030a */
+	0x016f, 0x0000,
+	/* 0x0077 0x030a */
+	0x1e98, 0x0000,
+	/* 0x0079 0x030a */
+	0x1e99, 0x0000,
+	/* 0x004f 0x030b */
+	0x0150, 0x0000,
+	/* 0x0055 0x030b */
+	0x0170, 0x0000,
+	/* 0x006f 0x030b */
+	0x0151, 0x0000,
+	/* 0x0075 0x030b */
+	0x0171, 0x0000,
+	/* 0x0423 0x030b */
+	0x04f2, 0x0000,
+	/* 0x0443 0x030b */
+	0x04f3, 0x0000,
+	/* 0x0041 0x030c */
+	0x01cd, 0x0000,
+	/* 0x0043 0x030c */
+	0x010c, 0x0000,
+	/* 0x0044 0x030c */
+	0x010e, 0x0000,
+	/* 0x0045 0x030c */
+	0x011a, 0x0000,
+	/* 0x0047 0x030c */
+	0x01e6, 0x0000,
+	/* 0x0049 0x030c */
+	0x01cf, 0x0000,
+	/* 0x004b 0x030c */
+	0x01e8, 0x0000,
+	/* 0x004c 0x030c */
+	0x013d, 0x0000,
+	/* 0x004e 0x030c */
+	0x0147, 0x0000,
+	/* 0x004f 0x030c */
+	0x01d1, 0x0000,
+	/* 0x0052 0x030c */
+	0x0158, 0x0000,
+	/* 0x0053 0x030c */
+	0x0160, 0x0001,  0x0307, 0x0dfc,
+	/* 0x0054 0x030c */
+	0x0164, 0x0000,
+	/* 0x0055 0x030c */
+	0x01d3, 0x0000,
+	/* 0x005a 0x030c */
+	0x017d, 0x0000,
+	/* 0x0061 0x030c */
+	0x01ce, 0x0000,
+	/* 0x0063 0x030c */
+	0x010d, 0x0000,
+	/* 0x0064 0x030c */
+	0x010f, 0x0000,
+	/* 0x0065 0x030c */
+	0x011b, 0x0000,
+	/* 0x0067 0x030c */
+	0x01e7, 0x0000,
+	/* 0x0069 0x030c */
+	0x01d0, 0x0000,
+	/* 0x006a 0x030c */
+	0x01f0, 0x0000,
+	/* 0x006b 0x030c */
+	0x01e9, 0x0000,
+	/* 0x006c 0x030c */
+	0x013e, 0x0000,
+	/* 0x006e 0x030c */
+	0x0148, 0x0000,
+	/* 0x006f 0x030c */
+	0x01d2, 0x0000,
+	/* 0x0072 0x030c */
+	0x0159, 0x0000,
+	/* 0x0073 0x030c */
+	0x0161, 0x0001,  0x0307, 0x0dfe,
+	/* 0x0074 0x030c */
+	0x0165, 0x0000,
+	/* 0x0075 0x030c */
+	0x01d4, 0x0000,
+	/* 0x007a 0x030c */
+	0x017e, 0x0000,
+	/* 0x01b7 0x030c */
+	0x01ee, 0x0000,
+	/* 0x0292 0x030c */
+	0x01ef, 0x0000,
+	/* 0x00a8 0x030d */
+	0x0385, 0x0000,
+	/* 0x0308 0x030d */
+	0x0344, 0x0000,
+	/* 0x0391 0x030d */
+	0x0386, 0x0000,
+	/* 0x0395 0x030d */
+	0x0388, 0x0000,
+	/* 0x0397 0x030d */
+	0x0389, 0x0000,
+	/* 0x0399 0x030d */
+	0x038a, 0x0000,
+	/* 0x039f 0x030d */
+	0x038c, 0x0000,
+	/* 0x03a5 0x030d */
+	0x038e, 0x0000,
+	/* 0x03a9 0x030d */
+	0x038f, 0x0000,
+	/* 0x03b1 0x030d */
+	0x03ac, 0x0000,
+	/* 0x03b5 0x030d */
+	0x03ad, 0x0000,
+	/* 0x03b7 0x030d */
+	0x03ae, 0x0000,
+	/* 0x03b9 0x030d */
+	0x03af, 0x0000,
+	/* 0x03bf 0x030d */
+	0x03cc, 0x0000,
+	/* 0x03c5 0x030d */
+	0x03cd, 0x0000,
+	/* 0x03c9 0x030d */
+	0x03ce, 0x0000,
+	/* 0x03d2 0x030d */
+	0x03d3, 0x0000,
+	/* 0x0041 0x030f */
+	0x0200, 0x0000,
+	/* 0x0045 0x030f */
+	0x0204, 0x0000,
+	/* 0x0049 0x030f */
+	0x0208, 0x0000,
+	/* 0x004f 0x030f */
+	0x020c, 0x0000,
+	/* 0x0052 0x030f */
+	0x0210, 0x0000,
+	/* 0x0055 0x030f */
+	0x0214, 0x0000,
+	/* 0x0061 0x030f */
+	0x0201, 0x0000,
+	/* 0x0065 0x030f */
+	0x0205, 0x0000,
+	/* 0x0069 0x030f */
+	0x0209, 0x0000,
+	/* 0x006f 0x030f */
+	0x020d, 0x0000,
+	/* 0x0072 0x030f */
+	0x0211, 0x0000,
+	/* 0x0075 0x030f */
+	0x0215, 0x0000,
+	/* 0x0474 0x030f */
+	0x0476, 0x0000,
+	/* 0x0475 0x030f */
+	0x0477, 0x0000,
+	/* 0x0041 0x0311 */
+	0x0202, 0x0000,
+	/* 0x0045 0x0311 */
+	0x0206, 0x0000,
+	/* 0x0049 0x0311 */
+	0x020a, 0x0000,
+	/* 0x004f 0x0311 */
+	0x020e, 0x0000,
+	/* 0x0052 0x0311 */
+	0x0212, 0x0000,
+	/* 0x0055 0x0311 */
+	0x0216, 0x0000,
+	/* 0x0061 0x0311 */
+	0x0203, 0x0000,
+	/* 0x0065 0x0311 */
+	0x0207, 0x0000,
+	/* 0x0069 0x0311 */
+	0x020b, 0x0000,
+	/* 0x006f 0x0311 */
+	0x020f, 0x0000,
+	/* 0x0072 0x0311 */
+	0x0213, 0x0000,
+	/* 0x0075 0x0311 */
+	0x0217, 0x0000,
+	/* 0x0391 0x0313 */
+	0x1f08, 0x0003,  0x0300, 0x0e00,  0x0301, 0x0e02,  0x0342, 0x0e04,
+	/* 0x0395 0x0313 */
+	0x1f18, 0x0002,  0x0300, 0x0e06,  0x0301, 0x0e08,
+	/* 0x0397 0x0313 */
+	0x1f28, 0x0003,  0x0300, 0x0e0a,  0x0301, 0x0e0c,  0x0342, 0x0e0e,
+	/* 0x0399 0x0313 */
+	0x1f38, 0x0003,  0x0300, 0x0e10,  0x0301, 0x0e12,  0x0342, 0x0e14,
+	/* 0x039f 0x0313 */
+	0x1f48, 0x0002,  0x0300, 0x0e16,  0x0301, 0x0e18,
+	/* 0x03a9 0x0313 */
+	0x1f68, 0x0003,  0x0300, 0x0e1a,  0x0301, 0x0e1c,  0x0342, 0x0e1e,
+	/* 0x03b1 0x0313 */
+	0x1f00, 0x0003,  0x0300, 0x0e20,  0x0301, 0x0e22,  0x0342, 0x0e24,
+	/* 0x03b5 0x0313 */
+	0x1f10, 0x0002,  0x0300, 0x0e26,  0x0301, 0x0e28,
+	/* 0x03b7 0x0313 */
+	0x1f20, 0x0003,  0x0300, 0x0e2a,  0x0301, 0x0e2c,  0x0342, 0x0e2e,
+	/* 0x03b9 0x0313 */
+	0x1f30, 0x0003,  0x0300, 0x0e30,  0x0301, 0x0e32,  0x0342, 0x0e34,
+	/* 0x03bf 0x0313 */
+	0x1f40, 0x0002,  0x0300, 0x0e36,  0x0301, 0x0e38,
+	/* 0x03c1 0x0313 */
+	0x1fe4, 0x0000,
+	/* 0x03c5 0x0313 */
+	0x1f50, 0x0003,  0x0300, 0x0e3a,  0x0301, 0x0e3c,  0x0342, 0x0e3e,
+	/* 0x03c9 0x0313 */
+	0x1f60, 0x0003,  0x0300, 0x0e40,  0x0301, 0x0e42,  0x0342, 0x0e44,
+	/* 0x0391 0x0314 */
+	0x1f09, 0x0003,  0x0300, 0x0e46,  0x0301, 0x0e48,  0x0342, 0x0e4a,
+	/* 0x0395 0x0314 */
+	0x1f19, 0x0002,  0x0300, 0x0e4c,  0x0301, 0x0e4e,
+	/* 0x0397 0x0314 */
+	0x1f29, 0x0003,  0x0300, 0x0e50,  0x0301, 0x0e52,  0x0342, 0x0e54,
+	/* 0x0399 0x0314 */
+	0x1f39, 0x0003,  0x0300, 0x0e56,  0x0301, 0x0e58,  0x0342, 0x0e5a,
+	/* 0x039f 0x0314 */
+	0x1f49, 0x0002,  0x0300, 0x0e5c,  0x0301, 0x0e5e,
+	/* 0x03a1 0x0314 */
+	0x1fec, 0x0000,
+	/* 0x03a5 0x0314 */
+	0x1f59, 0x0003,  0x0300, 0x0e60,  0x0301, 0x0e62,  0x0342, 0x0e64,
+	/* 0x03a9 0x0314 */
+	0x1f69, 0x0003,  0x0300, 0x0e66,  0x0301, 0x0e68,  0x0342, 0x0e6a,
+	/* 0x03b1 0x0314 */
+	0x1f01, 0x0003,  0x0300, 0x0e6c,  0x0301, 0x0e6e,  0x0342, 0x0e70,
+	/* 0x03b5 0x0314 */
+	0x1f11, 0x0002,  0x0300, 0x0e72,  0x0301, 0x0e74,
+	/* 0x03b7 0x0314 */
+	0x1f21, 0x0003,  0x0300, 0x0e76,  0x0301, 0x0e78,  0x0342, 0x0e7a,
+	/* 0x03b9 0x0314 */
+	0x1f31, 0x0003,  0x0300, 0x0e7c,  0x0301, 0x0e7e,  0x0342, 0x0e80,
+	/* 0x03bf 0x0314 */
+	0x1f41, 0x0002,  0x0300, 0x0e82,  0x0301, 0x0e84,
+	/* 0x03c1 0x0314 */
+	0x1fe5, 0x0000,
+	/* 0x03c5 0x0314 */
+	0x1f51, 0x0003,  0x0300, 0x0e86,  0x0301, 0x0e88,  0x0342, 0x0e8a,
+	/* 0x03c9 0x0314 */
+	0x1f61, 0x0003,  0x0300, 0x0e8c,  0x0301, 0x0e8e,  0x0342, 0x0e90,
+	/* 0x004f 0x031b */
+	0x01a0, 0x0005,  0x0300, 0x0e92,  0x0301, 0x0e94,  0x0303, 0x0e96,
+	0x0309, 0x0e98,  0x0323, 0x0e9a,
+	/* 0x0055 0x031b */
+	0x01af, 0x0005,  0x0300, 0x0e9c,  0x0301, 0x0e9e,  0x0303, 0x0ea0,
+	0x0309, 0x0ea2,  0x0323, 0x0ea4,
+	/* 0x006f 0x031b */
+	0x01a1, 0x0005,  0x0300, 0x0ea6,  0x0301, 0x0ea8,  0x0303, 0x0eaa,
+	0x0309, 0x0eac,  0x0323, 0x0eae,
+	/* 0x0075 0x031b */
+	0x01b0, 0x0005,  0x0300, 0x0eb0,  0x0301, 0x0eb2,  0x0303, 0x0eb4,
+	0x0309, 0x0eb6,  0x0323, 0x0eb8,
+	/* 0x0041 0x0323 */
+	0x1ea0, 0x0002,  0x0302, 0x0eba,  0x0306, 0x0ebc,
+	/* 0x0042 0x0323 */
+	0x1e04, 0x0000,
+	/* 0x0044 0x0323 */
+	0x1e0c, 0x0000,
+	/* 0x0045 0x0323 */
+	0x1eb8, 0x0001,  0x0302, 0x0ebe,
+	/* 0x0048 0x0323 */
+	0x1e24, 0x0000,
+	/* 0x0049 0x0323 */
+	0x1eca, 0x0000,
+	/* 0x004b 0x0323 */
+	0x1e32, 0x0000,
+	/* 0x004c 0x0323 */
+	0x1e36, 0x0001,  0x0304, 0x0ec0,
+	/* 0x004d 0x0323 */
+	0x1e42, 0x0000,
+	/* 0x004e 0x0323 */
+	0x1e46, 0x0000,
+	/* 0x004f 0x0323 */
+	0x1ecc, 0x0001,  0x0302, 0x0ec2,
+	/* 0x0052 0x0323 */
+	0x1e5a, 0x0001,  0x0304, 0x0ec4,
+	/* 0x0053 0x0323 */
+	0x1e62, 0x0001,  0x0307, 0x0ec6,
+	/* 0x0054 0x0323 */
+	0x1e6c, 0x0000,
+	/* 0x0055 0x0323 */
+	0x1ee4, 0x0000,
+	/* 0x0056 0x0323 */
+	0x1e7e, 0x0000,
+	/* 0x0057 0x0323 */
+	0x1e88, 0x0000,
+	/* 0x0059 0x0323 */
+	0x1ef4, 0x0000,
+	/* 0x005a 0x0323 */
+	0x1e92, 0x0000,
+	/* 0x0061 0x0323 */
+	0x1ea1, 0x0002,  0x0302, 0x0ec8,  0x0306, 0x0eca,
+	/* 0x0062 0x0323 */
+	0x1e05, 0x0000,
+	/* 0x0064 0x0323 */
+	0x1e0d, 0x0000,
+	/* 0x0065 0x0323 */
+	0x1eb9, 0x0001,  0x0302, 0x0ecc,
+	/* 0x0068 0x0323 */
+	0x1e25, 0x0000,
+	/* 0x0069 0x0323 */
+	0x1ecb, 0x0000,
+	/* 0x006b 0x0323 */
+	0x1e33, 0x0000,
+	/* 0x006c 0x0323 */
+	0x1e37, 0x0001,  0x0304, 0x0ece,
+	/* 0x006d 0x0323 */
+	0x1e43, 0x0000,
+	/* 0x006e 0x0323 */
+	0x1e47, 0x0000,
+	/* 0x006f 0x0323 */
+	0x1ecd, 0x0001,  0x0302, 0x0ed0,
+	/* 0x0072 0x0323 */
+	0x1e5b, 0x0001,  0x0304, 0x0ed2,
+	/* 0x0073 0x0323 */
+	0x1e63, 0x0001,  0x0307, 0x0ed4,
+	/* 0x0074 0x0323 */
+	0x1e6d, 0x0000,
+	/* 0x0075 0x0323 */
+	0x1ee5, 0x0000,
+	/* 0x0076 0x0323 */
+	0x1e7f, 0x0000,
+	/* 0x0077 0x0323 */
+	0x1e89, 0x0000,
+	/* 0x0079 0x0323 */
+	0x1ef5, 0x0000,
+	/* 0x007a 0x0323 */
+	0x1e93, 0x0000,
+	/* 0x0055 0x0324 */
+	0x1e72, 0x0000,
+	/* 0x0075 0x0324 */
+	0x1e73, 0x0000,
+	/* 0x0041 0x0325 */
+	0x1e00, 0x0000,
+	/* 0x0061 0x0325 */
+	0x1e01, 0x0000,
+	/* 0x0043 0x0327 */
+	0x00c7, 0x0001,  0x0301, 0x0ed6,
+	/* 0x0044 0x0327 */
+	0x1e10, 0x0000,
+	/* 0x0045 0x0327 */
+	0x0000, 0x0001,  0x0306, 0x0ed8,
+	/* 0x0047 0x0327 */
+	0x0122, 0x0000,
+	/* 0x0048 0x0327 */
+	0x1e28, 0x0000,
+	/* 0x004b 0x0327 */
+	0x0136, 0x0000,
+	/* 0x004c 0x0327 */
+	0x013b, 0x0000,
+	/* 0x004e 0x0327 */
+	0x0145, 0x0000,
+	/* 0x0052 0x0327 */
+	0x0156, 0x0000,
+	/* 0x0053 0x0327 */
+	0x015e, 0x0000,
+	/* 0x0054 0x0327 */
+	0x0162, 0x0000,
+	/* 0x0063 0x0327 */
+	0x00e7, 0x0001,  0x0301, 0x0eda,
+	/* 0x0064 0x0327 */
+	0x1e11, 0x0000,
+	/* 0x0065 0x0327 */
+	0x0000, 0x0001,  0x0306, 0x0edc,
+	/* 0x0067 0x0327 */
+	0x0123, 0x0000,
+	/* 0x0068 0x0327 */
+	0x1e29, 0x0000,
+	/* 0x006b 0x0327 */
+	0x0137, 0x0000,
+	/* 0x006c 0x0327 */
+	0x013c, 0x0000,
+	/* 0x006e 0x0327 */
+	0x0146, 0x0000,
+	/* 0x0072 0x0327 */
+	0x0157, 0x0000,
+	/* 0x0073 0x0327 */
+	0x015f, 0x0000,
+	/* 0x0074 0x0327 */
+	0x0163, 0x0000,
+	/* 0x0041 0x0328 */
+	0x0104, 0x0000,
+	/* 0x0045 0x0328 */
+	0x0118, 0x0000,
+	/* 0x0049 0x0328 */
+	0x012e, 0x0000,
+	/* 0x004f 0x0328 */
+	0x01ea, 0x0001,  0x0304, 0x0ede,
+	/* 0x0055 0x0328 */
+	0x0172, 0x0000,
+	/* 0x0061 0x0328 */
+	0x0105, 0x0000,
+	/* 0x0065 0x0328 */
+	0x0119, 0x0000,
+	/* 0x0069 0x0328 */
+	0x012f, 0x0000,
+	/* 0x006f 0x0328 */
+	0x01eb, 0x0001,  0x0304, 0x0ee0,
+	/* 0x0075 0x0328 */
+	0x0173, 0x0000,
+	/* 0x0044 0x032d */
+	0x1e12, 0x0000,
+	/* 0x0045 0x032d */
+	0x1e18, 0x0000,
+	/* 0x004c 0x032d */
+	0x1e3c, 0x0000,
+	/* 0x004e 0x032d */
+	0x1e4a, 0x0000,
+	/* 0x0054 0x032d */
+	0x1e70, 0x0000,
+	/* 0x0055 0x032d */
+	0x1e76, 0x0000,
+	/* 0x0064 0x032d */
+	0x1e13, 0x0000,
+	/* 0x0065 0x032d */
+	0x1e19, 0x0000,
+	/* 0x006c 0x032d */
+	0x1e3d, 0x0000,
+	/* 0x006e 0x032d */
+	0x1e4b, 0x0000,
+	/* 0x0074 0x032d */
+	0x1e71, 0x0000,
+	/* 0x0075 0x032d */
+	0x1e77, 0x0000,
+	/* 0x0048 0x032e */
+	0x1e2a, 0x0000,
+	/* 0x0068 0x032e */
+	0x1e2b, 0x0000,
+	/* 0x0045 0x0330 */
+	0x1e1a, 0x0000,
+	/* 0x0049 0x0330 */
+	0x1e2c, 0x0000,
+	/* 0x0055 0x0330 */
+	0x1e74, 0x0000,
+	/* 0x0065 0x0330 */
+	0x1e1b, 0x0000,
+	/* 0x0069 0x0330 */
+	0x1e2d, 0x0000,
+	/* 0x0075 0x0330 */
+	0x1e75, 0x0000,
+	/* 0x0042 0x0331 */
+	0x1e06, 0x0000,
+	/* 0x0044 0x0331 */
+	0x1e0e, 0x0000,
+	/* 0x004b 0x0331 */
+	0x1e34, 0x0000,
+	/* 0x004c 0x0331 */
+	0x1e3a, 0x0000,
+	/* 0x004e 0x0331 */
+	0x1e48, 0x0000,
+	/* 0x0052 0x0331 */
+	0x1e5e, 0x0000,
+	/* 0x0054 0x0331 */
+	0x1e6e, 0x0000,
+	/* 0x005a 0x0331 */
+	0x1e94, 0x0000,
+	/* 0x0062 0x0331 */
+	0x1e07, 0x0000,
+	/* 0x0064 0x0331 */
+	0x1e0f, 0x0000,
+	/* 0x0068 0x0331 */
+	0x1e96, 0x0000,
+	/* 0x006b 0x0331 */
+	0x1e35, 0x0000,
+	/* 0x006c 0x0331 */
+	0x1e3b, 0x0000,
+	/* 0x006e 0x0331 */
+	0x1e49, 0x0000,
+	/* 0x0072 0x0331 */
+	0x1e5f, 0x0000,
+	/* 0x0074 0x0331 */
+	0x1e6f, 0x0000,
+	/* 0x007a 0x0331 */
+	0x1e95, 0x0000,
+	/* 0x00a8 0x0342 */
+	0x1fc1, 0x0000,
+	/* 0x03b1 0x0342 */
+	0x1fb6, 0x0000,
+	/* 0x03b7 0x0342 */
+	0x1fc6, 0x0000,
+	/* 0x03b9 0x0342 */
+	0x1fd6, 0x0000,
+	/* 0x03c5 0x0342 */
+	0x1fe6, 0x0000,
+	/* 0x03c9 0x0342 */
+	0x1ff6, 0x0000,
+	/* 0x1fbf 0x0342 */
+	0x1fcf, 0x0000,
+	/* 0x1ffe 0x0342 */
+	0x1fdf, 0x0000,
+	/* 0x0391 0x0345 */
+	0x1fbc, 0x0002,  0x0313, 0x0ee2,  0x0314, 0x0eea,
+	/* 0x0397 0x0345 */
+	0x1fcc, 0x0002,  0x0313, 0x0ef2,  0x0314, 0x0efa,
+	/* 0x03a9 0x0345 */
+	0x1ffc, 0x0002,  0x0313, 0x0f02,  0x0314, 0x0f0a,
+	/* 0x03b1 0x0345 */
+	0x1fb3, 0x0005,  0x0300, 0x0f12,  0x0301, 0x0f14,  0x0313, 0x0f16,
+	0x0314, 0x0f1e,  0x0342, 0x0f26,
+	/* 0x03b7 0x0345 */
+	0x1fc3, 0x0005,  0x0300, 0x0f28,  0x0301, 0x0f2a,  0x0313, 0x0f2c,
+	0x0314, 0x0f34,  0x0342, 0x0f3c,
+	/* 0x03bf 0x0345 */
+	0x0000, 0x0001,  0x0301, 0x0f3e,
+	/* 0x03c9 0x0345 */
+	0x1ff3, 0x0004,  0x0300, 0x0f40,  0x0313, 0x0f42,  0x0314, 0x0f4a,
+	0x0342, 0x0f52,
+	/* 0x05d0 0x05b7 */
+	0xfb2e, 0x0000,
+	/* 0x05f2 0x05b7 */
+	0xfb1f, 0x0000,
+	/* 0x05d0 0x05b8 */
+	0xfb2f, 0x0000,
+	/* 0x05d5 0x05b9 */
+	0xfb4b, 0x0000,
+	/* 0x05d0 0x05bc */
+	0xfb30, 0x0000,
+	/* 0x05d1 0x05bc */
+	0xfb31, 0x0000,
+	/* 0x05d2 0x05bc */
+	0xfb32, 0x0000,
+	/* 0x05d3 0x05bc */
+	0xfb33, 0x0000,
+	/* 0x05d4 0x05bc */
+	0xfb34, 0x0000,
+	/* 0x05d5 0x05bc */
+	0xfb35, 0x0000,
+	/* 0x05d6 0x05bc */
+	0xfb36, 0x0000,
+	/* 0x05d8 0x05bc */
+	0xfb38, 0x0000,
+	/* 0x05d9 0x05bc */
+	0xfb39, 0x0000,
+	/* 0x05da 0x05bc */
+	0xfb3a, 0x0000,
+	/* 0x05db 0x05bc */
+	0xfb3b, 0x0000,
+	/* 0x05dc 0x05bc */
+	0xfb3c, 0x0000,
+	/* 0x05de 0x05bc */
+	0xfb3e, 0x0000,
+	/* 0x05e0 0x05bc */
+	0xfb40, 0x0000,
+	/* 0x05e1 0x05bc */
+	0xfb41, 0x0000,
+	/* 0x05e3 0x05bc */
+	0xfb43, 0x0000,
+	/* 0x05e4 0x05bc */
+	0xfb44, 0x0000,
+	/* 0x05e6 0x05bc */
+	0xfb46, 0x0000,
+	/* 0x05e7 0x05bc */
+	0xfb47, 0x0000,
+	/* 0x05e8 0x05bc */
+	0xfb48, 0x0000,
+	/* 0x05e9 0x05bc */
+	0xfb49, 0x0002,  0x05c1, 0x0f54,  0x05c2, 0x0f56,
+	/* 0x05ea 0x05bc */
+	0xfb4a, 0x0000,
+	/* 0x05d1 0x05bf */
+	0xfb4c, 0x0000,
+	/* 0x05db 0x05bf */
+	0xfb4d, 0x0000,
+	/* 0x05e4 0x05bf */
+	0xfb4e, 0x0000,
+	/* 0x05e9 0x05c1 */
+	0xfb2a, 0x0000,
+	/* 0x05e9 0x05c2 */
+	0xfb2b, 0x0000,
+	/* 0x0915 0x093c */
+	0x0958, 0x0000,
+	/* 0x0916 0x093c */
+	0x0959, 0x0000,
+	/* 0x0917 0x093c */
+	0x095a, 0x0000,
+	/* 0x091c 0x093c */
+	0x095b, 0x0000,
+	/* 0x0921 0x093c */
+	0x095c, 0x0000,
+	/* 0x0922 0x093c */
+	0x095d, 0x0000,
+	/* 0x0928 0x093c */
+	0x0929, 0x0000,
+	/* 0x092b 0x093c */
+	0x095e, 0x0000,
+	/* 0x092f 0x093c */
+	0x095f, 0x0000,
+	/* 0x0930 0x093c */
+	0x0931, 0x0000,
+	/* 0x0933 0x093c */
+	0x0934, 0x0000,
+	/* 0x09a1 0x09bc */
+	0x09dc, 0x0000,
+	/* 0x09a2 0x09bc */
+	0x09dd, 0x0000,
+	/* 0x09ac 0x09bc */
+	0x09b0, 0x0000,
+	/* 0x09af 0x09bc */
+	0x09df, 0x0000,
+	/* 0x09c7 0x09be */
+	0x09cb, 0x0000,
+	/* 0x09c7 0x09d7 */
+	0x09cc, 0x0000,
+	/* 0x0a16 0x0a3c */
+	0x0a59, 0x0000,
+	/* 0x0a17 0x0a3c */
+	0x0a5a, 0x0000,
+	/* 0x0a1c 0x0a3c */
+	0x0a5b, 0x0000,
+	/* 0x0a21 0x0a3c */
+	0x0a5c, 0x0000,
+	/* 0x0a2b 0x0a3c */
+	0x0a5e, 0x0000,
+	/* 0x0b21 0x0b3c */
+	0x0b5c, 0x0000,
+	/* 0x0b22 0x0b3c */
+	0x0b5d, 0x0000,
+	/* 0x0b2f 0x0b3c */
+	0x0b5f, 0x0000,
+	/* 0x0b47 0x0b3e */
+	0x0b4b, 0x0000,
+	/* 0x0b47 0x0b56 */
+	0x0b48, 0x0000,
+	/* 0x0b47 0x0b57 */
+	0x0b4c, 0x0000,
+	/* 0x0bc6 0x0bbe */
+	0x0bca, 0x0000,
+	/* 0x0bc7 0x0bbe */
+	0x0bcb, 0x0000,
+	/* 0x0b92 0x0bd7 */
+	0x0b94, 0x0000,
+	/* 0x0bc6 0x0bd7 */
+	0x0bcc, 0x0000,
+	/* 0x0c46 0x0c56 */
+	0x0c48, 0x0000,
+	/* 0x0cc6 0x0cc2 */
+	0x0cca, 0x0001,  0x0cd5, 0x0f58,
+	/* 0x0cbf 0x0cd5 */
+	0x0cc0, 0x0000,
+	/* 0x0cc6 0x0cd5 */
+	0x0cc7, 0x0000,
+	/* 0x0cc6 0x0cd6 */
+	0x0cc8, 0x0000,
+	/* 0x0d46 0x0d3e */
+	0x0d4a, 0x0000,
+	/* 0x0d47 0x0d3e */
+	0x0d4b, 0x0000,
+	/* 0x0d46 0x0d57 */
+	0x0d4c, 0x0000,
+	/* 0x0e4d 0x0e32 */
+	0x0e33, 0x0000,
+	/* 0x0ecd 0x0eb2 */
+	0x0eb3, 0x0000,
+	/* 0x0f72 0x0f71 */
+	0x0f73, 0x0000,
+	/* 0x0f74 0x0f71 */
+	0x0f75, 0x0000,
+	/* 0x0f80 0x0f71 */
+	0x0f81, 0x0000,
+	/* 0x0fb2 0x0f80 */
+	0x0f76, 0x0001,  0x0f71, 0x0f5a,
+	/* 0x0fb3 0x0f80 */
+	0x0f78, 0x0001,  0x0f71, 0x0f5c,
+	/* 0x0f40 0x0fb5 */
+	0x0f69, 0x0000,
+	/* 0x0f90 0x0fb5 */
+	0x0fb9, 0x0000,
+	/* 0x0f42 0x0fb7 */
+	0x0f43, 0x0000,
+	/* 0x0f4c 0x0fb7 */
+	0x0f4d, 0x0000,
+	/* 0x0f51 0x0fb7 */
+	0x0f52, 0x0000,
+	/* 0x0f56 0x0fb7 */
+	0x0f57, 0x0000,
+	/* 0x0f5b 0x0fb7 */
+	0x0f5c, 0x0000,
+	/* 0x0f92 0x0fb7 */
+	0x0f93, 0x0000,
+	/* 0x0f9c 0x0fb7 */
+	0x0f9d, 0x0000,
+	/* 0x0fa1 0x0fb7 */
+	0x0fa2, 0x0000,
+	/* 0x0fa6 0x0fb7 */
+	0x0fa7, 0x0000,
+	/* 0x0fab 0x0fb7 */
+	0x0fac, 0x0000,
+	/* 0x3046 0x3099 */
+	0x3094, 0x0000,
+	/* 0x304b 0x3099 */
+	0x304c, 0x0000,
+	/* 0x304d 0x3099 */
+	0x304e, 0x0000,
+	/* 0x304f 0x3099 */
+	0x3050, 0x0000,
+	/* 0x3051 0x3099 */
+	0x3052, 0x0000,
+	/* 0x3053 0x3099 */
+	0x3054, 0x0000,
+	/* 0x3055 0x3099 */
+	0x3056, 0x0000,
+	/* 0x3057 0x3099 */
+	0x3058, 0x0000,
+	/* 0x3059 0x3099 */
+	0x305a, 0x0000,
+	/* 0x305b 0x3099 */
+	0x305c, 0x0000,
+	/* 0x305d 0x3099 */
+	0x305e, 0x0000,
+	/* 0x305f 0x3099 */
+	0x3060, 0x0000,
+	/* 0x3061 0x3099 */
+	0x3062, 0x0000,
+	/* 0x3064 0x3099 */
+	0x3065, 0x0000,
+	/* 0x3066 0x3099 */
+	0x3067, 0x0000,
+	/* 0x3068 0x3099 */
+	0x3069, 0x0000,
+	/* 0x306f 0x3099 */
+	0x3070, 0x0000,
+	/* 0x3072 0x3099 */
+	0x3073, 0x0000,
+	/* 0x3075 0x3099 */
+	0x3076, 0x0000,
+	/* 0x3078 0x3099 */
+	0x3079, 0x0000,
+	/* 0x307b 0x3099 */
+	0x307c, 0x0000,
+	/* 0x309d 0x3099 */
+	0x309e, 0x0000,
+	/* 0x30a6 0x3099 */
+	0x30f4, 0x0000,
+	/* 0x30ab 0x3099 */
+	0x30ac, 0x0000,
+	/* 0x30ad 0x3099 */
+	0x30ae, 0x0000,
+	/* 0x30af 0x3099 */
+	0x30b0, 0x0000,
+	/* 0x30b1 0x3099 */
+	0x30b2, 0x0000,
+	/* 0x30b3 0x3099 */
+	0x30b4, 0x0000,
+	/* 0x30b5 0x3099 */
+	0x30b6, 0x0000,
+	/* 0x30b7 0x3099 */
+	0x30b8, 0x0000,
+	/* 0x30b9 0x3099 */
+	0x30ba, 0x0000,
+	/* 0x30bb 0x3099 */
+	0x30bc, 0x0000,
+	/* 0x30bd 0x3099 */
+	0x30be, 0x0000,
+	/* 0x30bf 0x3099 */
+	0x30c0, 0x0000,
+	/* 0x30c1 0x3099 */
+	0x30c2, 0x0000,
+	/* 0x30c4 0x3099 */
+	0x30c5, 0x0000,
+	/* 0x30c6 0x3099 */
+	0x30c7, 0x0000,
+	/* 0x30c8 0x3099 */
+	0x30c9, 0x0000,
+	/* 0x30cf 0x3099 */
+	0x30d0, 0x0000,
+	/* 0x30d2 0x3099 */
+	0x30d3, 0x0000,
+	/* 0x30d5 0x3099 */
+	0x30d6, 0x0000,
+	/* 0x30d8 0x3099 */
+	0x30d9, 0x0000,
+	/* 0x30db 0x3099 */
+	0x30dc, 0x0000,
+	/* 0x30ef 0x3099 */
+	0x30f7, 0x0000,
+	/* 0x30f0 0x3099 */
+	0x30f8, 0x0000,
+	/* 0x30f1 0x3099 */
+	0x30f9, 0x0000,
+	/* 0x30f2 0x3099 */
+	0x30fa, 0x0000,
+	/* 0x30fd 0x3099 */
+	0x30fe, 0x0000,
+	/* 0x306f 0x309a */
+	0x3071, 0x0000,
+	/* 0x3072 0x309a */
+	0x3074, 0x0000,
+	/* 0x3075 0x309a */
+	0x3077, 0x0000,
+	/* 0x3078 0x309a */
+	0x307a, 0x0000,
+	/* 0x307b 0x309a */
+	0x307d, 0x0000,
+	/* 0x30cf 0x309a */
+	0x30d1, 0x0000,
+	/* 0x30d2 0x309a */
+	0x30d4, 0x0000,
+	/* 0x30d5 0x309a */
+	0x30d7, 0x0000,
+	/* 0x30d8 0x309a */
+	0x30da, 0x0000,
+	/* 0x30db 0x309a */
+	0x30dd, 0x0000,
+	/* 0x0307 0x0053 0x0301 */
+	0x1e64, 0x0000,
+	/* 0x0307 0x0073 0x0301 */
+	0x1e65, 0x0000,
+	/* 0x0300 0x0041 0x0302 */
+	0x1ea6, 0x0000,
+	/* 0x0301 0x0041 0x0302 */
+	0x1ea4, 0x0000,
+	/* 0x0303 0x0041 0x0302 */
+	0x1eaa, 0x0000,
+	/* 0x0309 0x0041 0x0302 */
+	0x1ea8, 0x0000,
+	/* 0x0300 0x0045 0x0302 */
+	0x1ec0, 0x0000,
+	/* 0x0301 0x0045 0x0302 */
+	0x1ebe, 0x0000,
+	/* 0x0303 0x0045 0x0302 */
+	0x1ec4, 0x0000,
+	/* 0x0309 0x0045 0x0302 */
+	0x1ec2, 0x0000,
+	/* 0x0300 0x004f 0x0302 */
+	0x1ed2, 0x0000,
+	/* 0x0301 0x004f 0x0302 */
+	0x1ed0, 0x0000,
+	/* 0x0303 0x004f 0x0302 */
+	0x1ed6, 0x0000,
+	/* 0x0309 0x004f 0x0302 */
+	0x1ed4, 0x0000,
+	/* 0x0300 0x0061 0x0302 */
+	0x1ea7, 0x0000,
+	/* 0x0301 0x0061 0x0302 */
+	0x1ea5, 0x0000,
+	/* 0x0303 0x0061 0x0302 */
+	0x1eab, 0x0000,
+	/* 0x0309 0x0061 0x0302 */
+	0x1ea9, 0x0000,
+	/* 0x0300 0x0065 0x0302 */
+	0x1ec1, 0x0000,
+	/* 0x0301 0x0065 0x0302 */
+	0x1ebf, 0x0000,
+	/* 0x0303 0x0065 0x0302 */
+	0x1ec5, 0x0000,
+	/* 0x0309 0x0065 0x0302 */
+	0x1ec3, 0x0000,
+	/* 0x0300 0x006f 0x0302 */
+	0x1ed3, 0x0000,
+	/* 0x0301 0x006f 0x0302 */
+	0x1ed1, 0x0000,
+	/* 0x0303 0x006f 0x0302 */
+	0x1ed7, 0x0000,
+	/* 0x0309 0x006f 0x0302 */
+	0x1ed5, 0x0000,
+	/* 0x0301 0x004f 0x0303 */
+	0x1e4c, 0x0000,
+	/* 0x0308 0x004f 0x0303 */
+	0x1e4e, 0x0000,
+	/* 0x0301 0x0055 0x0303 */
+	0x1e78, 0x0000,
+	/* 0x0301 0x006f 0x0303 */
+	0x1e4d, 0x0000,
+	/* 0x0308 0x006f 0x0303 */
+	0x1e4f, 0x0000,
+	/* 0x0301 0x0075 0x0303 */
+	0x1e79, 0x0000,
+	/* 0x0300 0x0045 0x0304 */
+	0x1e14, 0x0000,
+	/* 0x0301 0x0045 0x0304 */
+	0x1e16, 0x0000,
+	/* 0x0300 0x004f 0x0304 */
+	0x1e50, 0x0000,
+	/* 0x0301 0x004f 0x0304 */
+	0x1e52, 0x0000,
+	/* 0x0308 0x0055 0x0304 */
+	0x1e7a, 0x0000,
+	/* 0x0300 0x0065 0x0304 */
+	0x1e15, 0x0000,
+	/* 0x0301 0x0065 0x0304 */
+	0x1e17, 0x0000,
+	/* 0x0300 0x006f 0x0304 */
+	0x1e51, 0x0000,
+	/* 0x0301 0x006f 0x0304 */
+	0x1e53, 0x0000,
+	/* 0x0308 0x0075 0x0304 */
+	0x1e7b, 0x0000,
+	/* 0x0300 0x0041 0x0306 */
+	0x1eb0, 0x0000,
+	/* 0x0301 0x0041 0x0306 */
+	0x1eae, 0x0000,
+	/* 0x0303 0x0041 0x0306 */
+	0x1eb4, 0x0000,
+	/* 0x0309 0x0041 0x0306 */
+	0x1eb2, 0x0000,
+	/* 0x0300 0x0061 0x0306 */
+	0x1eb1, 0x0000,
+	/* 0x0301 0x0061 0x0306 */
+	0x1eaf, 0x0000,
+	/* 0x0303 0x0061 0x0306 */
+	0x1eb5, 0x0000,
+	/* 0x0309 0x0061 0x0306 */
+	0x1eb3, 0x0000,
+	/* 0x0304 0x0041 0x0307 */
+	0x01e0, 0x0000,
+	/* 0x0304 0x0061 0x0307 */
+	0x01e1, 0x0000,
+	/* 0x0304 0x0041 0x0308 */
+	0x01de, 0x0000,
+	/* 0x0301 0x0049 0x0308 */
+	0x1e2e, 0x0000,
+	/* 0x0300 0x0055 0x0308 */
+	0x01db, 0x0000,
+	/* 0x0301 0x0055 0x0308 */
+	0x01d7, 0x0000,
+	/* 0x0304 0x0055 0x0308 */
+	0x01d5, 0x0000,
+	/* 0x030c 0x0055 0x0308 */
+	0x01d9, 0x0000,
+	/* 0x0304 0x0061 0x0308 */
+	0x01df, 0x0000,
+	/* 0x0301 0x0069 0x0308 */
+	0x1e2f, 0x0000,
+	/* 0x0300 0x0075 0x0308 */
+	0x01dc, 0x0000,
+	/* 0x0301 0x0075 0x0308 */
+	0x01d8, 0x0000,
+	/* 0x0304 0x0075 0x0308 */
+	0x01d6, 0x0000,
+	/* 0x030c 0x0075 0x0308 */
+	0x01da, 0x0000,
+	/* 0x0300 0x03b9 0x0308 */
+	0x1fd2, 0x0000,
+	/* 0x0301 0x03b9 0x0308 */
+	0x1fd3, 0x0000,
+	/* 0x030d 0x03b9 0x0308 */
+	0x0390, 0x0000,
+	/* 0x0342 0x03b9 0x0308 */
+	0x1fd7, 0x0000,
+	/* 0x0300 0x03c5 0x0308 */
+	0x1fe2, 0x0000,
+	/* 0x0301 0x03c5 0x0308 */
+	0x1fe3, 0x0000,
+	/* 0x030d 0x03c5 0x0308 */
+	0x03b0, 0x0000,
+	/* 0x0342 0x03c5 0x0308 */
+	0x1fe7, 0x0000,
+	/* 0x0301 0x0041 0x030a */
+	0x01fa, 0x0000,
+	/* 0x0301 0x0061 0x030a */
+	0x01fb, 0x0000,
+	/* 0x0307 0x0053 0x030c */
+	0x1e66, 0x0000,
+	/* 0x0307 0x0073 0x030c */
+	0x1e67, 0x0000,
+	/* 0x0300 0x0391 0x0313 */
+	0x1f0a, 0x0000,
+	/* 0x0301 0x0391 0x0313 */
+	0x1f0c, 0x0000,
+	/* 0x0342 0x0391 0x0313 */
+	0x1f0e, 0x0000,
+	/* 0x0300 0x0395 0x0313 */
+	0x1f1a, 0x0000,
+	/* 0x0301 0x0395 0x0313 */
+	0x1f1c, 0x0000,
+	/* 0x0300 0x0397 0x0313 */
+	0x1f2a, 0x0000,
+	/* 0x0301 0x0397 0x0313 */
+	0x1f2c, 0x0000,
+	/* 0x0342 0x0397 0x0313 */
+	0x1f2e, 0x0000,
+	/* 0x0300 0x0399 0x0313 */
+	0x1f3a, 0x0000,
+	/* 0x0301 0x0399 0x0313 */
+	0x1f3c, 0x0000,
+	/* 0x0342 0x0399 0x0313 */
+	0x1f3e, 0x0000,
+	/* 0x0300 0x039f 0x0313 */
+	0x1f4a, 0x0000,
+	/* 0x0301 0x039f 0x0313 */
+	0x1f4c, 0x0000,
+	/* 0x0300 0x03a9 0x0313 */
+	0x1f6a, 0x0000,
+	/* 0x0301 0x03a9 0x0313 */
+	0x1f6c, 0x0000,
+	/* 0x0342 0x03a9 0x0313 */
+	0x1f6e, 0x0000,
+	/* 0x0300 0x03b1 0x0313 */
+	0x1f02, 0x0000,
+	/* 0x0301 0x03b1 0x0313 */
+	0x1f04, 0x0000,
+	/* 0x0342 0x03b1 0x0313 */
+	0x1f06, 0x0000,
+	/* 0x0300 0x03b5 0x0313 */
+	0x1f12, 0x0000,
+	/* 0x0301 0x03b5 0x0313 */
+	0x1f14, 0x0000,
+	/* 0x0300 0x03b7 0x0313 */
+	0x1f22, 0x0000,
+	/* 0x0301 0x03b7 0x0313 */
+	0x1f24, 0x0000,
+	/* 0x0342 0x03b7 0x0313 */
+	0x1f26, 0x0000,
+	/* 0x0300 0x03b9 0x0313 */
+	0x1f32, 0x0000,
+	/* 0x0301 0x03b9 0x0313 */
+	0x1f34, 0x0000,
+	/* 0x0342 0x03b9 0x0313 */
+	0x1f36, 0x0000,
+	/* 0x0300 0x03bf 0x0313 */
+	0x1f42, 0x0000,
+	/* 0x0301 0x03bf 0x0313 */
+	0x1f44, 0x0000,
+	/* 0x0300 0x03c5 0x0313 */
+	0x1f52, 0x0000,
+	/* 0x0301 0x03c5 0x0313 */
+	0x1f54, 0x0000,
+	/* 0x0342 0x03c5 0x0313 */
+	0x1f56, 0x0000,
+	/* 0x0300 0x03c9 0x0313 */
+	0x1f62, 0x0000,
+	/* 0x0301 0x03c9 0x0313 */
+	0x1f64, 0x0000,
+	/* 0x0342 0x03c9 0x0313 */
+	0x1f66, 0x0000,
+	/* 0x0300 0x0391 0x0314 */
+	0x1f0b, 0x0000,
+	/* 0x0301 0x0391 0x0314 */
+	0x1f0d, 0x0000,
+	/* 0x0342 0x0391 0x0314 */
+	0x1f0f, 0x0000,
+	/* 0x0300 0x0395 0x0314 */
+	0x1f1b, 0x0000,
+	/* 0x0301 0x0395 0x0314 */
+	0x1f1d, 0x0000,
+	/* 0x0300 0x0397 0x0314 */
+	0x1f2b, 0x0000,
+	/* 0x0301 0x0397 0x0314 */
+	0x1f2d, 0x0000,
+	/* 0x0342 0x0397 0x0314 */
+	0x1f2f, 0x0000,
+	/* 0x0300 0x0399 0x0314 */
+	0x1f3b, 0x0000,
+	/* 0x0301 0x0399 0x0314 */
+	0x1f3d, 0x0000,
+	/* 0x0342 0x0399 0x0314 */
+	0x1f3f, 0x0000,
+	/* 0x0300 0x039f 0x0314 */
+	0x1f4b, 0x0000,
+	/* 0x0301 0x039f 0x0314 */
+	0x1f4d, 0x0000,
+	/* 0x0300 0x03a5 0x0314 */
+	0x1f5b, 0x0000,
+	/* 0x0301 0x03a5 0x0314 */
+	0x1f5d, 0x0000,
+	/* 0x0342 0x03a5 0x0314 */
+	0x1f5f, 0x0000,
+	/* 0x0300 0x03a9 0x0314 */
+	0x1f6b, 0x0000,
+	/* 0x0301 0x03a9 0x0314 */
+	0x1f6d, 0x0000,
+	/* 0x0342 0x03a9 0x0314 */
+	0x1f6f, 0x0000,
+	/* 0x0300 0x03b1 0x0314 */
+	0x1f03, 0x0000,
+	/* 0x0301 0x03b1 0x0314 */
+	0x1f05, 0x0000,
+	/* 0x0342 0x03b1 0x0314 */
+	0x1f07, 0x0000,
+	/* 0x0300 0x03b5 0x0314 */
+	0x1f13, 0x0000,
+	/* 0x0301 0x03b5 0x0314 */
+	0x1f15, 0x0000,
+	/* 0x0300 0x03b7 0x0314 */
+	0x1f23, 0x0000,
+	/* 0x0301 0x03b7 0x0314 */
+	0x1f25, 0x0000,
+	/* 0x0342 0x03b7 0x0314 */
+	0x1f27, 0x0000,
+	/* 0x0300 0x03b9 0x0314 */
+	0x1f33, 0x0000,
+	/* 0x0301 0x03b9 0x0314 */
+	0x1f35, 0x0000,
+	/* 0x0342 0x03b9 0x0314 */
+	0x1f37, 0x0000,
+	/* 0x0300 0x03bf 0x0314 */
+	0x1f43, 0x0000,
+	/* 0x0301 0x03bf 0x0314 */
+	0x1f45, 0x0000,
+	/* 0x0300 0x03c5 0x0314 */
+	0x1f53, 0x0000,
+	/* 0x0301 0x03c5 0x0314 */
+	0x1f55, 0x0000,
+	/* 0x0342 0x03c5 0x0314 */
+	0x1f57, 0x0000,
+	/* 0x0300 0x03c9 0x0314 */
+	0x1f63, 0x0000,
+	/* 0x0301 0x03c9 0x0314 */
+	0x1f65, 0x0000,
+	/* 0x0342 0x03c9 0x0314 */
+	0x1f67, 0x0000,
+	/* 0x0300 0x004f 0x031b */
+	0x1edc, 0x0000,
+	/* 0x0301 0x004f 0x031b */
+	0x1eda, 0x0000,
+	/* 0x0303 0x004f 0x031b */
+	0x1ee0, 0x0000,
+	/* 0x0309 0x004f 0x031b */
+	0x1ede, 0x0000,
+	/* 0x0323 0x004f 0x031b */
+	0x1ee2, 0x0000,
+	/* 0x0300 0x0055 0x031b */
+	0x1eea, 0x0000,
+	/* 0x0301 0x0055 0x031b */
+	0x1ee8, 0x0000,
+	/* 0x0303 0x0055 0x031b */
+	0x1eee, 0x0000,
+	/* 0x0309 0x0055 0x031b */
+	0x1eec, 0x0000,
+	/* 0x0323 0x0055 0x031b */
+	0x1ef0, 0x0000,
+	/* 0x0300 0x006f 0x031b */
+	0x1edd, 0x0000,
+	/* 0x0301 0x006f 0x031b */
+	0x1edb, 0x0000,
+	/* 0x0303 0x006f 0x031b */
+	0x1ee1, 0x0000,
+	/* 0x0309 0x006f 0x031b */
+	0x1edf, 0x0000,
+	/* 0x0323 0x006f 0x031b */
+	0x1ee3, 0x0000,
+	/* 0x0300 0x0075 0x031b */
+	0x1eeb, 0x0000,
+	/* 0x0301 0x0075 0x031b */
+	0x1ee9, 0x0000,
+	/* 0x0303 0x0075 0x031b */
+	0x1eef, 0x0000,
+	/* 0x0309 0x0075 0x031b */
+	0x1eed, 0x0000,
+	/* 0x0323 0x0075 0x031b */
+	0x1ef1, 0x0000,
+	/* 0x0302 0x0041 0x0323 */
+	0x1eac, 0x0000,
+	/* 0x0306 0x0041 0x0323 */
+	0x1eb6, 0x0000,
+	/* 0x0302 0x0045 0x0323 */
+	0x1ec6, 0x0000,
+	/* 0x0304 0x004c 0x0323 */
+	0x1e38, 0x0000,
+	/* 0x0302 0x004f 0x0323 */
+	0x1ed8, 0x0000,
+	/* 0x0304 0x0052 0x0323 */
+	0x1e5c, 0x0000,
+	/* 0x0307 0x0053 0x0323 */
+	0x1e68, 0x0000,
+	/* 0x0302 0x0061 0x0323 */
+	0x1ead, 0x0000,
+	/* 0x0306 0x0061 0x0323 */
+	0x1eb7, 0x0000,
+	/* 0x0302 0x0065 0x0323 */
+	0x1ec7, 0x0000,
+	/* 0x0304 0x006c 0x0323 */
+	0x1e39, 0x0000,
+	/* 0x0302 0x006f 0x0323 */
+	0x1ed9, 0x0000,
+	/* 0x0304 0x0072 0x0323 */
+	0x1e5d, 0x0000,
+	/* 0x0307 0x0073 0x0323 */
+	0x1e69, 0x0000,
+	/* 0x0301 0x0043 0x0327 */
+	0x1e08, 0x0000,
+	/* 0x0306 0x0045 0x0327 */
+	0x1e1c, 0x0000,
+	/* 0x0301 0x0063 0x0327 */
+	0x1e09, 0x0000,
+	/* 0x0306 0x0065 0x0327 */
+	0x1e1d, 0x0000,
+	/* 0x0304 0x004f 0x0328 */
+	0x01ec, 0x0000,
+	/* 0x0304 0x006f 0x0328 */
+	0x01ed, 0x0000,
+	/* 0x0313 0x0391 0x0345 */
+	0x1f88, 0x0003,  0x0300, 0x0f5e,  0x0301, 0x0f60,  0x0342, 0x0f62,
+	/* 0x0314 0x0391 0x0345 */
+	0x1f89, 0x0003,  0x0300, 0x0f64,  0x0301, 0x0f66,  0x0342, 0x0f68,
+	/* 0x0313 0x0397 0x0345 */
+	0x1f98, 0x0003,  0x0300, 0x0f6a,  0x0301, 0x0f6c,  0x0342, 0x0f6e,
+	/* 0x0314 0x0397 0x0345 */
+	0x1f99, 0x0003,  0x0300, 0x0f70,  0x0301, 0x0f72,  0x0342, 0x0f74,
+	/* 0x0313 0x03a9 0x0345 */
+	0x1fa8, 0x0003,  0x0300, 0x0f76,  0x0301, 0x0f78,  0x0342, 0x0f7a,
+	/* 0x0314 0x03a9 0x0345 */
+	0x1fa9, 0x0003,  0x0300, 0x0f7c,  0x0301, 0x0f7e,  0x0342, 0x0f80,
+	/* 0x0300 0x03b1 0x0345 */
+	0x1fb2, 0x0000,
+	/* 0x0301 0x03b1 0x0345 */
+	0x1fb4, 0x0000,
+	/* 0x0313 0x03b1 0x0345 */
+	0x1f80, 0x0003,  0x0300, 0x0f82,  0x0301, 0x0f84,  0x0342, 0x0f86,
+	/* 0x0314 0x03b1 0x0345 */
+	0x1f81, 0x0003,  0x0300, 0x0f88,  0x0301, 0x0f8a,  0x0342, 0x0f8c,
+	/* 0x0342 0x03b1 0x0345 */
+	0x1fb7, 0x0000,
+	/* 0x0300 0x03b7 0x0345 */
+	0x1fc2, 0x0000,
+	/* 0x0301 0x03b7 0x0345 */
+	0x1fc4, 0x0000,
+	/* 0x0313 0x03b7 0x0345 */
+	0x1f90, 0x0003,  0x0300, 0x0f8e,  0x0301, 0x0f90,  0x0342, 0x0f92,
+	/* 0x0314 0x03b7 0x0345 */
+	0x1f91, 0x0003,  0x0300, 0x0f94,  0x0301, 0x0f96,  0x0342, 0x0f98,
+	/* 0x0342 0x03b7 0x0345 */
+	0x1fc7, 0x0000,
+	/* 0x0301 0x03bf 0x0345 */
+	0x1ff4, 0x0000,
+	/* 0x0300 0x03c9 0x0345 */
+	0x1ff2, 0x0000,
+	/* 0x0313 0x03c9 0x0345 */
+	0x1fa0, 0x0003,  0x0300, 0x0f9a,  0x0301, 0x0f9c,  0x0342, 0x0f9e,
+	/* 0x0314 0x03c9 0x0345 */
+	0x1fa1, 0x0003,  0x0300, 0x0fa0,  0x0301, 0x0fa2,  0x0342, 0x0fa4,
+	/* 0x0342 0x03c9 0x0345 */
+	0x1ff7, 0x0000,
+	/* 0x05c1 0x05e9 0x05bc */
+	0xfb2c, 0x0000,
+	/* 0x05c2 0x05e9 0x05bc */
+	0xfb2d, 0x0000,
+	/* 0x0cd5 0x0cc6 0x0cc2 */
+	0x0ccb, 0x0000,
+	/* 0x0f71 0x0fb2 0x0f80 */
+	0x0f77, 0x0000,
+	/* 0x0f71 0x0fb3 0x0f80 */
+	0x0f79, 0x0000,
+	/* 0x0300 0x0313 0x0391 0x0345 */
+	0x1f8a, 0x0000,
+	/* 0x0301 0x0313 0x0391 0x0345 */
+	0x1f8c, 0x0000,
+	/* 0x0342 0x0313 0x0391 0x0345 */
+	0x1f8e, 0x0000,
+	/* 0x0300 0x0314 0x0391 0x0345 */
+	0x1f8b, 0x0000,
+	/* 0x0301 0x0314 0x0391 0x0345 */
+	0x1f8d, 0x0000,
+	/* 0x0342 0x0314 0x0391 0x0345 */
+	0x1f8f, 0x0000,
+	/* 0x0300 0x0313 0x0397 0x0345 */
+	0x1f9a, 0x0000,
+	/* 0x0301 0x0313 0x0397 0x0345 */
+	0x1f9c, 0x0000,
+	/* 0x0342 0x0313 0x0397 0x0345 */
+	0x1f9e, 0x0000,
+	/* 0x0300 0x0314 0x0397 0x0345 */
+	0x1f9b, 0x0000,
+	/* 0x0301 0x0314 0x0397 0x0345 */
+	0x1f9d, 0x0000,
+	/* 0x0342 0x0314 0x0397 0x0345 */
+	0x1f9f, 0x0000,
+	/* 0x0300 0x0313 0x03a9 0x0345 */
+	0x1faa, 0x0000,
+	/* 0x0301 0x0313 0x03a9 0x0345 */
+	0x1fac, 0x0000,
+	/* 0x0342 0x0313 0x03a9 0x0345 */
+	0x1fae, 0x0000,
+	/* 0x0300 0x0314 0x03a9 0x0345 */
+	0x1fab, 0x0000,
+	/* 0x0301 0x0314 0x03a9 0x0345 */
+	0x1fad, 0x0000,
+	/* 0x0342 0x0314 0x03a9 0x0345 */
+	0x1faf, 0x0000,
+	/* 0x0300 0x0313 0x03b1 0x0345 */
+	0x1f82, 0x0000,
+	/* 0x0301 0x0313 0x03b1 0x0345 */
+	0x1f84, 0x0000,
+	/* 0x0342 0x0313 0x03b1 0x0345 */
+	0x1f86, 0x0000,
+	/* 0x0300 0x0314 0x03b1 0x0345 */
+	0x1f83, 0x0000,
+	/* 0x0301 0x0314 0x03b1 0x0345 */
+	0x1f85, 0x0000,
+	/* 0x0342 0x0314 0x03b1 0x0345 */
+	0x1f87, 0x0000,
+	/* 0x0300 0x0313 0x03b7 0x0345 */
+	0x1f92, 0x0000,
+	/* 0x0301 0x0313 0x03b7 0x0345 */
+	0x1f94, 0x0000,
+	/* 0x0342 0x0313 0x03b7 0x0345 */
+	0x1f96, 0x0000,
+	/* 0x0300 0x0314 0x03b7 0x0345 */
+	0x1f93, 0x0000,
+	/* 0x0301 0x0314 0x03b7 0x0345 */
+	0x1f95, 0x0000,
+	/* 0x0342 0x0314 0x03b7 0x0345 */
+	0x1f97, 0x0000,
+	/* 0x0300 0x0313 0x03c9 0x0345 */
+	0x1fa2, 0x0000,
+	/* 0x0301 0x0313 0x03c9 0x0345 */
+	0x1fa4, 0x0000,
+	/* 0x0342 0x0313 0x03c9 0x0345 */
+	0x1fa6, 0x0000,
+	/* 0x0300 0x0314 0x03c9 0x0345 */
+	0x1fa3, 0x0000,
+	/* 0x0301 0x0314 0x03c9 0x0345 */
+	0x1fa5, 0x0000,
+	/* 0x0342 0x0314 0x03c9 0x0345 */
+	0x1fa7, 0x0000,
+};
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/transaction.c linux-2.6.32/fs/hfsplus_journal/transaction.c
--- linux-2.6.32-old//fs/hfsplus_journal/transaction.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/transaction.c	2011-11-17 10:37:48.738817353 -0500
@@ -0,0 +1,2214 @@
+/*
+ * linux/fs/transaction.c
+ * 
+ * Written by Stephen C. Tweedie <sct@redhat.com>, 1998
+ *
+ * Copyright 1998 Red Hat corp --- All Rights Reserved
+ *
+ * This file is part of the Linux kernel and is made available under
+ * the terms of the GNU General Public License, version 2, or at your
+ * option, any later version, incorporated herein by reference.
+ *
+ * Generic filesystem transaction handling code; part of the ext2fs
+ * journaling system.  
+ *
+ * This file manages transactions (compound commits managed by the
+ * journaling code) and handles (individual atomic operations by the
+ * filesystem).
+ */
+
+#include <linux/time.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/smp_lock.h>
+#include <linux/mm.h>
+#include <linux/highmem.h>
+#include <linux/hrtimer.h>
+#include "hfsplus_jbd.h"
+
+static void __hfsplus_jbd_temp_unlink_buffer(struct hfsplus_jbd_head *jh);
+
+/*
+ * get_transaction: obtain a new hfsplus_transaction_t object.
+ *
+ * Simply allocate and initialise a new transaction.  Create it in
+ * RUNNING state and add it to the current journal (which should not
+ * have an existing running transaction: we only make a new transaction
+ * once we have started to commit the old one).
+ *
+ * Preconditions:
+ *	The journal MUST be locked.  We don't perform atomic mallocs on the
+ *	new transaction	and we can't block without protecting against other
+ *	processes trying to touch the journal while it is in transition.
+ *
+ * Called under j_state_lock
+ */
+
+static hfsplus_transaction_t *
+get_transaction(hfsplus_jbd_t *journal, hfsplus_transaction_t *transaction)
+{
+	transaction->t_journal = journal;
+	transaction->t_state = HFSPLUS_T_RUNNING;
+	transaction->t_start_time = ktime_get();
+	transaction->t_tid = journal->j_transaction_sequence++;
+	transaction->t_expires = jiffies + journal->j_commit_interval;
+	spin_lock_init(&transaction->t_handle_lock);
+
+	/* Set up the commit timer for the new transaction. */
+	journal->j_commit_timer.expires =
+				round_jiffies_up(transaction->t_expires);
+	add_timer(&journal->j_commit_timer);
+
+	HFSPLUS_J_ASSERT(journal->j_running_transaction == NULL);
+	journal->j_running_transaction = transaction;
+
+	return transaction;
+}
+
+/*
+ * Handle management.
+ *
+ * A hfsplus_jbd_handle_t is an object which represents a single atomic update to a
+ * filesystem, and which tracks all of the modifications which form part
+ * of that one update.
+ */
+
+/*
+ * start_this_handle: Given a handle, deal with any locking or stalling
+ * needed to make sure that there is enough journal space for the handle
+ * to begin.  Attach the handle to a transaction and set up the
+ * transaction's buffer credits.  
+ */
+
+static int start_this_handle(hfsplus_jbd_t *journal, hfsplus_jbd_handle_t *handle)
+{
+	hfsplus_transaction_t *transaction;
+	int needed;
+	int nblocks = handle->h_buffer_credits;
+	hfsplus_transaction_t *new_transaction = NULL;
+	int ret = 0;
+
+	if (nblocks > journal->j_max_transaction_buffers) {
+		printk(KERN_ERR "JBD: %s wants too many credits (%d > %d)\n",
+		       current->comm, nblocks,
+		       journal->j_max_transaction_buffers);
+		ret = -ENOSPC;
+		goto out;
+	}
+
+alloc_transaction:
+	if (!journal->j_running_transaction) {
+		new_transaction = kzalloc(sizeof(*new_transaction),
+						GFP_NOFS|__GFP_NOFAIL);
+		if (!new_transaction) {
+			ret = -ENOMEM;
+			goto out;
+		}
+	}
+
+	hfsplus_jbd_debug(3, "New handle %p going live.\n", handle);
+
+repeat:
+
+	/*
+	 * We need to hold j_state_lock until t_updates has been incremented,
+	 * for proper journal barrier handling
+	 */
+	spin_lock(&journal->j_state_lock);
+repeat_locked:
+	if (is_hfsplus_jbd_aborted(journal) ||
+	    (journal->j_errno != 0 && !(journal->j_flags & JFS_ACK_ERR))) {
+		spin_unlock(&journal->j_state_lock);
+		ret = -EROFS; 
+		goto out;
+	}
+
+	/* Wait on the journal's transaction barrier if necessary */
+	if (journal->j_barrier_count) {
+		spin_unlock(&journal->j_state_lock);
+		wait_event(journal->j_wait_transaction_locked,
+				journal->j_barrier_count == 0);
+		goto repeat;
+	}
+
+	if (!journal->j_running_transaction) {
+		if (!new_transaction) {
+			spin_unlock(&journal->j_state_lock);
+			goto alloc_transaction;
+		}
+		get_transaction(journal, new_transaction);
+		new_transaction = NULL;
+	}
+
+	transaction = journal->j_running_transaction;
+
+	/*
+	 * If the current transaction is locked down for commit, wait for the
+	 * lock to be released.
+	 */
+	if (transaction->t_state == HFSPLUS_T_LOCKED) {
+		DEFINE_WAIT(wait);
+
+		prepare_to_wait(&journal->j_wait_transaction_locked,
+					&wait, TASK_UNINTERRUPTIBLE);
+		spin_unlock(&journal->j_state_lock);
+		schedule();
+		finish_wait(&journal->j_wait_transaction_locked, &wait);
+		goto repeat;
+	}
+
+	/*
+	 * If there is not enough space left in the log to write all potential
+	 * buffers requested by this operation, we need to stall pending a log
+	 * checkpoint to free some more log space.
+	 */
+	spin_lock(&transaction->t_handle_lock);
+	needed = transaction->t_outstanding_credits + nblocks;
+
+	if (needed > journal->j_max_transaction_buffers) {
+		/*
+		 * If the current transaction is already too large, then start
+		 * to commit it: we can then go back and attach this handle to
+		 * a new transaction.
+		 */
+		DEFINE_WAIT(wait);
+
+		hfsplus_jbd_debug(2, "Handle %p starting new commit...\n", handle);
+		spin_unlock(&transaction->t_handle_lock);
+		prepare_to_wait(&journal->j_wait_transaction_locked, &wait,
+				TASK_UNINTERRUPTIBLE);
+		__hfsplus__log_start_commit(journal, transaction->t_tid);
+		spin_unlock(&journal->j_state_lock);
+		schedule();
+		finish_wait(&journal->j_wait_transaction_locked, &wait);
+		goto repeat;
+	}
+
+	/* 
+	 * The commit code assumes that it can get enough log space
+	 * without forcing a checkpoint.  This is *critical* for
+	 * correctness: a checkpoint of a buffer which is also
+	 * associated with a committing transaction creates a deadlock,
+	 * so commit simply cannot force through checkpoints.
+	 *
+	 * We must therefore ensure the necessary space in the journal
+	 * *before* starting to dirty potentially checkpointed buffers
+	 * in the new transaction. 
+	 *
+	 * The worst part is, any transaction currently committing can
+	 * reduce the free space arbitrarily.  Be careful to account for
+	 * those buffers when checkpointing.
+	 */
+
+	/*
+	 * @@@ AKPM: This seems rather over-defensive.  We're giving commit
+	 * a _lot_ of headroom: 1/4 of the journal plus the size of
+	 * the committing transaction.  Really, we only need to give it
+	 * committing_transaction->t_outstanding_credits plus "enough" for
+	 * the log control blocks.
+	 * Also, this test is inconsitent with the matching one in
+	 * hfsplus_jbd_extend().
+	 */
+	if (__hfsplus__log_space_left(journal) < hfsplus_jbd_space_needed(journal)) {
+		hfsplus_jbd_debug(2, "Handle %p waiting for checkpoint...\n", handle);
+		spin_unlock(&transaction->t_handle_lock);
+		__hfsplus__log_wait_for_space(journal);
+		goto repeat_locked;
+	}
+
+	/* OK, account for the buffers that this operation expects to
+	 * use and add the handle to the running transaction. */
+
+	handle->h_transaction = transaction;
+	transaction->t_outstanding_credits += nblocks;
+	transaction->t_updates++;
+	transaction->t_handle_count++;
+	hfsplus_jbd_debug(4, "Handle %p given %d credits (total %d, free %d)\n",
+		  handle, nblocks, transaction->t_outstanding_credits,
+		  __hfsplus__log_space_left(journal));
+	spin_unlock(&transaction->t_handle_lock);
+	spin_unlock(&journal->j_state_lock);
+
+	lock_map_acquire(&handle->h_lockdep_map);
+out:
+	if (unlikely(new_transaction))		/* It's usually NULL */
+		kfree(new_transaction);
+	return ret;
+}
+
+static struct lock_class_key jbd_handle_key;
+
+/* Allocate a new handle.  This should probably be in a slab... */
+static hfsplus_jbd_handle_t *new_handle(int nblocks)
+{
+	hfsplus_jbd_handle_t *handle = hfsplus_jbd_alloc_handle(GFP_NOFS);
+	if (!handle)
+		return NULL;
+	memset(handle, 0, sizeof(*handle));
+	handle->h_buffer_credits = nblocks;
+	handle->h_ref = 1;
+
+	lockdep_init_map(&handle->h_lockdep_map, "jbd_handle", &jbd_handle_key, 0);
+
+	return handle;
+}
+
+/**
+ * hfsplus_jbd_handle_t *hfsplus_jbd_start() - Obtain a new handle.  
+ * @journal: Journal to start transaction on.
+ * @nblocks: number of block buffer we might modify
+ *
+ * We make sure that the transaction can guarantee at least nblocks of
+ * modified buffers in the log.  We block until the log can guarantee
+ * that much space.  
+ *
+ * This function is visible to journal users (like ext3fs), so is not
+ * called with the journal already locked.
+ *
+ * Return a pointer to a newly allocated handle, or NULL on failure
+ */
+hfsplus_jbd_handle_t *hfsplus_jbd_start(hfsplus_jbd_t *journal, int nblocks, hfsplus_handle_t *hfsplus_handle)
+{
+	hfsplus_handle_t *tmp_hfsplus_handle = hfsplus_jbd_current_handle();
+	int err;
+
+	if (!journal)
+		return ERR_PTR(-EROFS);
+
+	if (tmp_hfsplus_handle) {
+		HFSPLUS_J_ASSERT(tmp_hfsplus_handle->handle->h_transaction->t_journal == journal);
+		tmp_hfsplus_handle->handle->h_ref++;
+		return tmp_hfsplus_handle->handle;
+	}
+
+	hfsplus_handle->handle = new_handle(nblocks);
+	if (!hfsplus_handle->handle)
+		return ERR_PTR(-ENOMEM);
+
+	current->journal_info = hfsplus_handle;
+
+	err = start_this_handle(journal, hfsplus_handle->handle);
+	if (err < 0) {
+		hfsplus_jbd_free_handle(hfsplus_handle->handle);
+		current->journal_info = NULL;
+		hfsplus_handle->handle = ERR_PTR(err);
+	}
+	return hfsplus_handle->handle;
+}
+
+/**
+ * int hfsplus_jbd_extend() - extend buffer credits.
+ * @handle:  handle to 'extend'
+ * @nblocks: nr blocks to try to extend by.
+ * 
+ * Some transactions, such as large extends and truncates, can be done
+ * atomically all at once or in several stages.  The operation requests
+ * a credit for a number of buffer modications in advance, but can
+ * extend its credit if it needs more.  
+ *
+ * hfsplus_jbd_extend tries to give the running handle more buffer credits.
+ * It does not guarantee that allocation - this is a best-effort only.
+ * The calling process MUST be able to deal cleanly with a failure to
+ * extend here.
+ *
+ * Return 0 on success, non-zero on failure.
+ *
+ * return code < 0 implies an error
+ * return code > 0 implies normal transaction-full status.
+ */
+int hfsplus_jbd_extend(hfsplus_jbd_handle_t *handle, int nblocks)
+{
+	hfsplus_transaction_t *transaction = handle->h_transaction;
+	hfsplus_jbd_t *journal = transaction->t_journal;
+	int result;
+	int wanted;
+
+	result = -EIO;
+	if (hfsplus_jbd_is_handle_aborted(handle))
+		goto out;
+
+	result = 1;
+
+	spin_lock(&journal->j_state_lock);
+
+	/* Don't extend a locked-down transaction! */
+	if (handle->h_transaction->t_state != HFSPLUS_T_RUNNING) {
+		hfsplus_jbd_debug(3, "denied handle %p %d blocks: "
+			  "transaction not running\n", handle, nblocks);
+		goto error_out;
+	}
+
+	spin_lock(&transaction->t_handle_lock);
+	wanted = transaction->t_outstanding_credits + nblocks;
+
+	if (wanted > journal->j_max_transaction_buffers) {
+		hfsplus_jbd_debug(3, "denied handle %p %d blocks: "
+			  "transaction too large\n", handle, nblocks);
+		goto unlock;
+	}
+
+	if (wanted > __hfsplus__log_space_left(journal)) {
+		hfsplus_jbd_debug(3, "denied handle %p %d blocks: "
+			  "insufficient log space\n", handle, nblocks);
+		goto unlock;
+	}
+
+	handle->h_buffer_credits += nblocks;
+	transaction->t_outstanding_credits += nblocks;
+	result = 0;
+
+	hfsplus_jbd_debug(3, "extended handle %p by %d\n", handle, nblocks);
+unlock:
+	spin_unlock(&transaction->t_handle_lock);
+error_out:
+	spin_unlock(&journal->j_state_lock);
+out:
+	return result;
+}
+
+
+/**
+ * int hfsplus_jbd_restart() - restart a handle.
+ * @handle:  handle to restart
+ * @nblocks: nr credits requested
+ * 
+ * Restart a handle for a multi-transaction filesystem
+ * operation.
+ *
+ * If the hfsplus_jbd_extend() call above fails to grant new buffer credits
+ * to a running handle, a call to hfsplus_jbd_restart will commit the
+ * handle's transaction so far and reattach the handle to a new
+ * transaction capabable of guaranteeing the requested number of
+ * credits.
+ */
+
+int hfsplus_jbd_restart(hfsplus_jbd_handle_t *handle, int nblocks)
+{
+	hfsplus_transaction_t *transaction = handle->h_transaction;
+	hfsplus_jbd_t *journal = transaction->t_journal;
+	hfsplus_handle_t *hfsplus_handle;
+	int ret;
+
+	/* If we've had an abort of any type, don't even think about
+	 * actually doing the restart! */
+	if (hfsplus_jbd_is_handle_aborted(handle))
+		return 0;
+
+	/*
+	 * First unlink the handle from its current transaction, and start the
+	 * commit on that.
+	 */
+	HFSPLUS_J_ASSERT(transaction->t_updates > 0);
+	hfsplus_handle = hfsplus_jbd_current_handle();
+	HFSPLUS_J_ASSERT(hfsplus_handle->handle == handle);
+
+	spin_lock(&journal->j_state_lock);
+	spin_lock(&transaction->t_handle_lock);
+	transaction->t_outstanding_credits -= handle->h_buffer_credits;
+	transaction->t_updates--;
+
+	if (!transaction->t_updates)
+		wake_up(&journal->j_wait_updates);
+	spin_unlock(&transaction->t_handle_lock);
+
+	hfsplus_jbd_debug(2, "restarting handle %p\n", handle);
+	__hfsplus__log_start_commit(journal, transaction->t_tid);
+	spin_unlock(&journal->j_state_lock);
+
+	lock_map_release(&handle->h_lockdep_map);
+	handle->h_buffer_credits = nblocks;
+	ret = start_this_handle(journal, handle);
+	return ret;
+}
+
+
+/**
+ * void hfsplus_jbd_lock_updates () - establish a transaction barrier.
+ * @journal:  Journal to establish a barrier on.
+ *
+ * This locks out any further updates from being started, and blocks
+ * until all existing updates have completed, returning only once the
+ * journal is in a quiescent state with no updates running.
+ *
+ * The journal lock should not be held on entry.
+ */
+void hfsplus_jbd_lock_updates(hfsplus_jbd_t *journal)
+{
+	DEFINE_WAIT(wait);
+
+	spin_lock(&journal->j_state_lock);
+	++journal->j_barrier_count;
+
+	/* Wait until there are no running updates */
+	while (1) {
+		hfsplus_transaction_t *transaction = journal->j_running_transaction;
+
+		if (!transaction)
+			break;
+
+		spin_lock(&transaction->t_handle_lock);
+		if (!transaction->t_updates) {
+			spin_unlock(&transaction->t_handle_lock);
+			break;
+		}
+		prepare_to_wait(&journal->j_wait_updates, &wait,
+				TASK_UNINTERRUPTIBLE);
+		spin_unlock(&transaction->t_handle_lock);
+		spin_unlock(&journal->j_state_lock);
+		schedule();
+		finish_wait(&journal->j_wait_updates, &wait);
+		spin_lock(&journal->j_state_lock);
+	}
+	spin_unlock(&journal->j_state_lock);
+
+	/*
+	 * We have now established a barrier against other normal updates, but
+	 * we also need to barrier against other hfsplus_jbd_lock_updates() calls
+	 * to make sure that we serialise special journal-locked operations
+	 * too.
+	 */
+	mutex_lock(&journal->j_barrier);
+}
+
+/**
+ * void hfsplus_jbd_unlock_updates (hfsplus_jbd_t* journal) - release barrier
+ * @journal:  Journal to release the barrier on.
+ * 
+ * Release a transaction barrier obtained with hfsplus_jbd_lock_updates().
+ *
+ * Should be called without the journal lock held.
+ */
+void hfsplus_jbd_unlock_updates (hfsplus_jbd_t *journal)
+{
+	HFSPLUS_J_ASSERT(journal->j_barrier_count != 0);
+
+	mutex_unlock(&journal->j_barrier);
+	spin_lock(&journal->j_state_lock);
+	--journal->j_barrier_count;
+	spin_unlock(&journal->j_state_lock);
+	wake_up(&journal->j_wait_transaction_locked);
+}
+
+/*
+ * Report any unexpected dirty buffers which turn up.  Normally those
+ * indicate an error, but they can occur if the user is running (say)
+ * tune2fs to modify the live filesystem, so we need the option of
+ * continuing as gracefully as possible.  #
+ *
+ * The caller should already hold the journal lock and
+ * j_list_lock spinlock: most callers will need those anyway
+ * in order to probe the buffer's journaling state safely.
+ */
+static void hfsplus_jbd_unexpected_dirty_buffer(struct hfsplus_jbd_head *jh)
+{
+	int jlist;
+
+	/* If this buffer is one which might reasonably be dirty
+	 * --- ie. data, or not part of this journal --- then
+	 * we're OK to leave it alone, but otherwise we need to
+	 * move the dirty bit to the journal's own internal
+	 * JBDDirty bit. */
+	jlist = jh->b_jlist;
+
+	if (jlist == HFSPLUS_BJ_Metadata || jlist == HFSPLUS_BJ_Reserved ||
+	     jlist == HFSPLUS_BJ_Shadow || jlist == HFSPLUS_BJ_Forget) {
+		struct buffer_head *bh = hfsplus_jh2bh(jh);
+
+		if (test_clear_buffer_dirty(bh))
+			set_buffer_hfsplus_jbddirty(bh);
+		}
+}
+
+static void warn_dirty_buffer(struct buffer_head *bh)
+{
+	char b[BDEVNAME_SIZE];
+
+	printk(KERN_WARNING
+	       "JBD: Spotted dirty metadata buffer (dev = %s, blocknr = %llu). "
+	       "There's a risk of filesystem corruption in case of system "
+	       "crash.\n",
+	       bdevname(bh->b_bdev, b), (unsigned long long)bh->b_blocknr);
+}
+
+/*
+ * If the buffer is already part of the current transaction, then there
+ * is nothing we need to do.  If it is already part of a prior
+ * transaction which we are still committing to disk, then we need to
+ * make sure that we do not overwrite the old copy: we do copy-out to
+ * preserve the copy going to disk.  We also account the buffer against
+ * the handle's metadata buffer credits (unless the buffer is already
+ * part of the transaction, that is).
+ *
+ */
+static int
+do_get_write_access(hfsplus_jbd_handle_t *handle, struct hfsplus_jbd_head *jh,
+			int force_copy)
+{
+	struct buffer_head *bh;
+	hfsplus_transaction_t *transaction;
+	hfsplus_jbd_t *journal;
+	int error;
+	char *frozen_buffer = NULL;
+	int need_copy = 0;
+
+	if (hfsplus_jbd_is_handle_aborted(handle))
+		return -EROFS;
+
+	transaction = handle->h_transaction;
+	journal = transaction->t_journal;
+
+	hfsplus_jbd_debug(5, "buffer_head %p, force_copy %d\n", jh, force_copy);
+
+	HFSPLUS_JBUFFER_TRACE(jh, "entry");
+repeat:
+	bh = hfsplus_jh2bh(jh);
+
+	/* @@@ Need to check for errors here at some point. */
+
+	lock_buffer(bh);
+	hfsplus_jbd_lock_bh_state(bh);
+
+	/* We now hold the buffer lock so it is safe to query the buffer
+	 * state.  Is the buffer dirty? 
+	 * 
+	 * If so, there are two possibilities.  The buffer may be
+	 * non-journaled, and undergoing a quite legitimate writeback.
+	 * Otherwise, it is journaled, and we don't expect dirty buffers
+	 * in that state (the buffers should be marked JBD_Dirty
+	 * instead.)  So either the IO is being done under our own
+	 * control and this is a bug, or it's a third party IO such as
+	 * dump(8) (which may leave the buffer scheduled for read ---
+	 * ie. locked but not dirty) or tune2fs (which may actually have
+	 * the buffer dirtied, ugh.)  */
+
+	if (buffer_dirty(bh)) {
+		/*
+		 * First question: is this buffer already part of the current
+		 * transaction or the existing committing transaction?
+		 */
+		if (jh->b_transaction) {
+			HFSPLUS_J_ASSERT_JH(jh,
+				jh->b_transaction == transaction || 
+				jh->b_transaction ==
+					journal->j_committing_transaction);
+			if (jh->b_next_transaction)
+				HFSPLUS_J_ASSERT_JH(jh, jh->b_next_transaction ==
+							transaction);
+			//warn_dirty_buffer(bh);
+		}
+		/*
+		 * In any case we need to clean the dirty flag and we must
+		 * do it under the buffer lock to be sure we don't race
+		 * with running write-out.
+		 */
+		HFSPLUS_JBUFFER_TRACE(jh, "Journalling dirty buffer");
+		hfsplus_jbd_unexpected_dirty_buffer(jh);
+		//clear_buffer_dirty(bh);
+		//set_buffer_jbddirty(bh);
+	}
+
+	unlock_buffer(bh);
+
+	error = -EROFS;
+	if (hfsplus_jbd_is_handle_aborted(handle)) {
+		hfsplus_jbd_unlock_bh_state(bh);
+		goto out;
+	}
+	error = 0;
+
+	/*
+	 * The buffer is already part of this transaction if b_transaction or
+	 * b_next_transaction points to it
+	 */
+	if (jh->b_transaction == transaction ||
+	    jh->b_next_transaction == transaction)
+		goto done;
+
+	/*
+	 * this is the first time this transaction is touching this buffer,
+	 * reset the modified flag
+	 */
+	jh->b_modified = 0;
+
+	/*
+	 * If there is already a copy-out version of this buffer, then we don't
+	 * need to make another one
+	 */
+	if (jh->b_frozen_data) {
+		HFSPLUS_JBUFFER_TRACE(jh, "has frozen data");
+		HFSPLUS_J_ASSERT_JH(jh, jh->b_next_transaction == NULL);
+		jh->b_next_transaction = transaction;
+		goto done;
+	}
+
+	/* Is there data here we need to preserve? */
+
+	if (jh->b_transaction && jh->b_transaction != transaction) {
+		HFSPLUS_JBUFFER_TRACE(jh, "owned by older transaction");
+		HFSPLUS_J_ASSERT_JH(jh, jh->b_next_transaction == NULL);
+		HFSPLUS_J_ASSERT_JH(jh, jh->b_transaction ==
+					journal->j_committing_transaction);
+
+		/* There is one case we have to be very careful about.
+		 * If the committing transaction is currently writing
+		 * this buffer out to disk and has NOT made a copy-out,
+		 * then we cannot modify the buffer contents at all
+		 * right now.  The essence of copy-out is that it is the
+		 * extra copy, not the primary copy, which gets
+		 * journaled.  If the primary copy is already going to
+		 * disk then we cannot do copy-out here. */
+
+		if (jh->b_jlist == HFSPLUS_BJ_Shadow) {
+			DEFINE_WAIT_BIT(wait, &bh->b_state, BH_HFSPLUS_Unshadow);
+			wait_queue_head_t *wqh;
+
+			wqh = bit_waitqueue(&bh->b_state, BH_HFSPLUS_Unshadow);
+
+			HFSPLUS_JBUFFER_TRACE(jh, "on shadow: sleep");
+			hfsplus_jbd_unlock_bh_state(bh);
+			/* commit wakes up all shadow buffers after IO */
+			for ( ; ; ) {
+				prepare_to_wait(wqh, &wait.wait,
+						TASK_UNINTERRUPTIBLE);
+				if (jh->b_jlist != HFSPLUS_BJ_Shadow)
+					break;
+				schedule();
+			}
+			finish_wait(wqh, &wait.wait);
+			goto repeat;
+		}
+
+		/* Only do the copy if the currently-owning transaction
+		 * still needs it.  If it is on the Forget list, the
+		 * committing transaction is past that stage.  The
+		 * buffer had better remain locked during the kmalloc,
+		 * but that should be true --- we hold the journal lock
+		 * still and the buffer is already on the BUF_JOURNAL
+		 * list so won't be flushed. 
+		 *
+		 * Subtle point, though: if this is a get_undo_access,
+		 * then we will be relying on the frozen_data to contain
+		 * the new value of the committed_data record after the
+		 * transaction, so we HAVE to force the frozen_data copy
+		 * in that case. */
+
+		if (jh->b_jlist != HFSPLUS_BJ_Forget || force_copy) {
+			HFSPLUS_JBUFFER_TRACE(jh, "generate frozen data");
+			if (!frozen_buffer) {
+				HFSPLUS_JBUFFER_TRACE(jh, "allocate memory for buffer");
+				hfsplus_jbd_unlock_bh_state(bh);
+				frozen_buffer =
+					hfsplus_jbd_alloc(hfsplus_jh2bh(jh)->b_size,
+							 GFP_NOFS);
+				if (!frozen_buffer) {
+					printk(KERN_EMERG
+					       "%s: OOM for frozen_buffer\n",
+					       __func__);
+					HFSPLUS_JBUFFER_TRACE(jh, "oom!");
+					error = -ENOMEM;
+					hfsplus_jbd_lock_bh_state(bh);
+					goto done;
+				}
+				goto repeat;
+			}
+			jh->b_frozen_data = frozen_buffer;
+			frozen_buffer = NULL;
+			need_copy = 1;
+		}
+		jh->b_next_transaction = transaction;
+	}
+
+
+	/*
+	 * Finally, if the buffer is not journaled right now, we need to make
+	 * sure it doesn't get written to disk before the caller actually
+	 * commits the new data
+	 */
+	if (!jh->b_transaction) {
+		HFSPLUS_JBUFFER_TRACE(jh, "no transaction");
+		HFSPLUS_J_ASSERT_JH(jh, !jh->b_next_transaction);
+		jh->b_transaction = transaction;
+		HFSPLUS_JBUFFER_TRACE(jh, "file as HFSPLUS_BJ_Reserved");
+		spin_lock(&journal->j_list_lock);
+		__hfsplus_jbd_file_buffer(jh, transaction, HFSPLUS_BJ_Reserved);
+		spin_unlock(&journal->j_list_lock);
+	}
+
+done:
+	if (need_copy) {
+		struct page *page;
+		int offset;
+		char *source;
+
+		HFSPLUS_J_EXPECT_JH(jh, buffer_uptodate(hfsplus_jh2bh(jh)),
+			    "Possible IO failure.\n");
+		page = hfsplus_jh2bh(jh)->b_page;
+		offset = ((unsigned long) hfsplus_jh2bh(jh)->b_data) & ~PAGE_MASK;
+		source = kmap_atomic(page, KM_USER0);
+		memcpy(jh->b_frozen_data, source+offset, hfsplus_jh2bh(jh)->b_size);
+		kunmap_atomic(source, KM_USER0);
+	}
+	hfsplus_jbd_unlock_bh_state(bh);
+
+	/*
+	 * If we are about to journal a buffer, then any revoke pending on it is
+	 * no longer valid
+	 */
+	hfsplus_jbd_cancel_revoke(handle, jh);
+
+out:
+	if (unlikely(frozen_buffer))	/* It's usually NULL */
+		hfsplus_jbd_free(frozen_buffer, bh->b_size);
+
+	HFSPLUS_JBUFFER_TRACE(jh, "exit");
+	return error;
+}
+
+/**
+ * int hfsplus_jbd_get_write_access() - notify intent to modify a buffer for metadata (not data) update.
+ * @handle: transaction to add buffer modifications to
+ * @bh:     bh to be used for metadata writes
+ *
+ * Returns an error code or 0 on success.
+ *
+ * In full data journalling mode the buffer may be of type HFSPLUS_BJ_AsyncData,
+ * because we're write()ing a buffer which is also part of a shared mapping.
+ */
+
+int hfsplus_jbd_get_write_access(hfsplus_jbd_handle_t *handle, struct buffer_head *bh)
+{
+	struct hfsplus_jbd_head *jh = hfsplus_jbd_add_journal_head(bh);
+	int rc;
+
+	/* We do not want to get caught playing with fields which the
+	 * log thread also manipulates.  Make sure that the buffer
+	 * completes any outstanding IO before proceeding. */
+	rc = do_get_write_access(handle, jh, 0);
+	hfsplus_jbd_put_journal_head(jh);
+	return rc;
+}
+
+
+/*
+ * When the user wants to journal a newly created buffer_head
+ * (ie. getblk() returned a new buffer and we are going to populate it
+ * manually rather than reading off disk), then we need to keep the
+ * buffer_head locked until it has been completely filled with new
+ * data.  In this case, we should be able to make the assertion that
+ * the bh is not already part of an existing transaction.  
+ * 
+ * The buffer should already be locked by the caller by this point.
+ * There is no lock ranking violation: it was a newly created,
+ * unlocked buffer beforehand. */
+
+/**
+ * int hfsplus_jbd_get_create_access () - notify intent to use newly created bh
+ * @handle: transaction to new buffer to
+ * @bh: new buffer.
+ *
+ * Call this if you create a new bh.
+ */
+int hfsplus_jbd_get_create_access(hfsplus_jbd_handle_t *handle, struct buffer_head *bh) 
+{
+	hfsplus_transaction_t *transaction = handle->h_transaction;
+	hfsplus_jbd_t *journal = transaction->t_journal;
+	struct hfsplus_jbd_head *jh = hfsplus_jbd_add_journal_head(bh);
+	int err;
+
+	hfsplus_jbd_debug(5, "hfsplus_jbd_head %p\n", jh);
+	err = -EROFS;
+	if (hfsplus_jbd_is_handle_aborted(handle))
+		goto out;
+	err = 0;
+
+	HFSPLUS_JBUFFER_TRACE(jh, "entry");
+	/*
+	 * The buffer may already belong to this transaction due to pre-zeroing
+	 * in the filesystem's new_block code.  It may also be on the previous,
+	 * committing transaction's lists, but it HAS to be in Forget state in
+	 * that case: the transaction must have deleted the buffer for it to be
+	 * reused here.
+	 */
+	hfsplus_jbd_lock_bh_state(bh);
+	spin_lock(&journal->j_list_lock);
+	HFSPLUS_J_ASSERT_JH(jh, (jh->b_transaction == transaction ||
+		jh->b_transaction == NULL ||
+		(jh->b_transaction == journal->j_committing_transaction &&
+			  jh->b_jlist == HFSPLUS_BJ_Forget)));
+
+	HFSPLUS_J_ASSERT_JH(jh, jh->b_next_transaction == NULL);
+	HFSPLUS_J_ASSERT_JH(jh, buffer_locked(hfsplus_jh2bh(jh)));
+
+	if (jh->b_transaction == NULL) {
+		/*
+		 * Previous journal_forget() could have left the buffer
+		 * with jbddirty bit set because it was being committed. When
+		 * the commit finished, we've filed the buffer for
+		 * checkpointing and marked it dirty. Now we are reallocating
+		 * the buffer so the transaction freeing it must have
+		 * committed and so it's safe to clear the dirty bit.
+		 */
+		clear_buffer_dirty(hfsplus_jh2bh(jh));
+		jh->b_transaction = transaction;
+
+		/* first access by this transaction */
+		jh->b_modified = 0;
+
+		HFSPLUS_JBUFFER_TRACE(jh, "file as HFSPLUS_BJ_Reserved");
+		__hfsplus_jbd_file_buffer(jh, transaction, HFSPLUS_BJ_Reserved);
+	} else if (jh->b_transaction == journal->j_committing_transaction) {
+		/* first access by this transaction */
+		jh->b_modified = 0;
+
+		HFSPLUS_JBUFFER_TRACE(jh, "set next transaction");
+		jh->b_next_transaction = transaction;
+	}
+	spin_unlock(&journal->j_list_lock);
+	hfsplus_jbd_unlock_bh_state(bh);
+
+	/*
+	 * akpm: I added this.  ext3_alloc_branch can pick up new indirect
+	 * blocks which contain freed but then revoked metadata.  We need
+	 * to cancel the revoke in case we end up freeing it yet again
+	 * and the reallocating as data - this would cause a second revoke,
+	 * which hits an assertion error.
+	 */
+	HFSPLUS_JBUFFER_TRACE(jh, "cancelling revoke");
+	hfsplus_jbd_cancel_revoke(handle, jh);
+	hfsplus_jbd_put_journal_head(jh);
+out:
+	return err;
+}
+
+/**
+ * int hfsplus_jbd_get_undo_access() - Notify intent to modify metadata with non-rewindable consequences
+ * @handle: transaction
+ * @bh: buffer to undo
+ *
+ * Sometimes there is a need to distinguish between metadata which has
+ * been committed to disk and that which has not.  The ext3fs code uses
+ * this for freeing and allocating space, we have to make sure that we
+ * do not reuse freed space until the deallocation has been committed,
+ * since if we overwrote that space we would make the delete
+ * un-rewindable in case of a crash.
+ * 
+ * To deal with that, hfsplus_jbd_get_undo_access requests write access to a
+ * buffer for parts of non-rewindable operations such as delete
+ * operations on the bitmaps.  The journaling code must keep a copy of
+ * the buffer's contents prior to the undo_access call until such time
+ * as we know that the buffer has definitely been committed to disk.
+ * 
+ * We never need to know which transaction the committed data is part
+ * of, buffers touched here are guaranteed to be dirtied later and so
+ * will be committed to a new transaction in due course, at which point
+ * we can discard the old committed data pointer.
+ *
+ * Returns error number or 0 on success.
+ */
+int hfsplus_jbd_get_undo_access(hfsplus_jbd_handle_t *handle, struct buffer_head *bh)
+{
+	int err;
+	struct hfsplus_jbd_head *jh = hfsplus_jbd_add_journal_head(bh);
+	char *committed_data = NULL;
+
+	HFSPLUS_JBUFFER_TRACE(jh, "entry");
+
+	/*
+	 * Do this first --- it can drop the journal lock, so we want to
+	 * make sure that obtaining the committed_data is done
+	 * atomically wrt. completion of any outstanding commits.
+	 */
+	err = do_get_write_access(handle, jh, 1);
+	if (err)
+		goto out;
+
+repeat:
+	if (!jh->b_committed_data) {
+		committed_data = hfsplus_jbd_alloc(hfsplus_jh2bh(jh)->b_size, GFP_NOFS);
+		if (!committed_data) {
+			printk(KERN_EMERG "%s: No memory for committed data\n",
+				__func__);
+			err = -ENOMEM;
+			goto out;
+		}
+	}
+
+	hfsplus_jbd_lock_bh_state(bh);
+	if (!jh->b_committed_data) {
+		/* Copy out the current buffer contents into the
+		 * preserved, committed copy. */
+		HFSPLUS_JBUFFER_TRACE(jh, "generate b_committed data");
+		if (!committed_data) {
+			hfsplus_jbd_unlock_bh_state(bh);
+			goto repeat;
+		}
+
+		jh->b_committed_data = committed_data;
+		committed_data = NULL;
+		memcpy(jh->b_committed_data, bh->b_data, bh->b_size);
+	}
+	hfsplus_jbd_unlock_bh_state(bh);
+out:
+	hfsplus_jbd_put_journal_head(jh);
+	if (unlikely(committed_data))
+		hfsplus_jbd_free(committed_data, bh->b_size);
+	return err;
+}
+
+/** 
+ * int hfsplus_jbd_dirty_data() - mark a buffer as containing dirty data to be flushed
+ * @handle: transaction
+ * @bh: bufferhead to mark
+ * 
+ * Description:
+ * Mark a buffer as containing dirty data which needs to be flushed before
+ * we can commit the current transaction.
+ *
+ * The buffer is placed on the transaction's data list and is marked as
+ * belonging to the transaction.
+ *
+ * Returns error number or 0 on success.
+ *
+ * hfsplus_jbd_dirty_data() can be called via page_launder->ext3_writepage
+ * by kswapd.
+ */
+int hfsplus_jbd_dirty_data(hfsplus_jbd_handle_t *handle, struct buffer_head *bh)
+{
+	hfsplus_jbd_t *journal = handle->h_transaction->t_journal;
+	int need_brelse = 0;
+	struct hfsplus_jbd_head *jh;
+	int ret = 0;
+
+	if (hfsplus_jbd_is_handle_aborted(handle))
+		return ret;
+
+	jh = hfsplus_jbd_add_journal_head(bh);
+	HFSPLUS_JBUFFER_TRACE(jh, "entry");
+
+	/*
+	 * The buffer could *already* be dirty.  Writeout can start
+	 * at any time.
+	 */
+	hfsplus_jbd_debug(4, "jh: %p, tid:%d\n", jh, handle->h_transaction->t_tid);
+
+	/*
+	 * What if the buffer is already part of a running transaction?
+	 * 
+	 * There are two cases:
+	 * 1) It is part of the current running transaction.  Refile it,
+	 *    just in case we have allocated it as metadata, deallocated
+	 *    it, then reallocated it as data. 
+	 * 2) It is part of the previous, still-committing transaction.
+	 *    If all we want to do is to guarantee that the buffer will be
+	 *    written to disk before this new transaction commits, then
+	 *    being sure that the *previous* transaction has this same 
+	 *    property is sufficient for us!  Just leave it on its old
+	 *    transaction.
+	 *
+	 * In case (2), the buffer must not already exist as metadata
+	 * --- that would violate write ordering (a transaction is free
+	 * to write its data at any point, even before the previous
+	 * committing transaction has committed).  The caller must
+	 * never, ever allow this to happen: there's nothing we can do
+	 * about it in this layer.
+	 */
+	hfsplus_jbd_lock_bh_state(bh);
+	spin_lock(&journal->j_list_lock);
+
+	/* Now that we have bh_state locked, are we really still mapped? */
+	if (!buffer_mapped(bh)) {
+		HFSPLUS_JBUFFER_TRACE(jh, "unmapped buffer, bailing out");
+		goto no_journal;
+	}
+
+	if (jh->b_transaction) {
+		HFSPLUS_JBUFFER_TRACE(jh, "has transaction");
+		if (jh->b_transaction != handle->h_transaction) {
+			HFSPLUS_JBUFFER_TRACE(jh, "belongs to older transaction");
+			HFSPLUS_J_ASSERT_JH(jh, jh->b_transaction ==
+					journal->j_committing_transaction);
+
+			/* @@@ IS THIS TRUE  ? */
+			/*
+			 * Not any more.  Scenario: someone does a write()
+			 * in data=journal mode.  The buffer's transaction has
+			 * moved into commit.  Then someone does another
+			 * write() to the file.  We do the frozen data copyout
+			 * and set b_next_transaction to point to j_running_t.
+			 * And while we're in that state, someone does a
+			 * writepage() in an attempt to pageout the same area
+			 * of the file via a shared mapping.  At present that
+			 * calls hfsplus_jbd_dirty_data(), and we get right here.
+			 * It may be too late to journal the data.  Simply
+			 * falling through to the next test will suffice: the
+			 * data will be dirty and wil be checkpointed.  The
+			 * ordering comments in the next comment block still
+			 * apply.
+			 */
+			//HFSPLUS_J_ASSERT_JH(jh, jh->b_next_transaction == NULL);
+
+			/*
+			 * If we're journalling data, and this buffer was
+			 * subject to a write(), it could be metadata, forget
+			 * or shadow against the committing transaction.  Now,
+			 * someone has dirtied the same darn page via a mapping
+			 * and it is being writepage()'d.
+			 * We *could* just steal the page from commit, with some
+			 * fancy locking there.  Instead, we just skip it -
+			 * don't tie the page's buffers to the new transaction
+			 * at all.
+			 * Implication: if we crash before the writepage() data
+			 * is written into the filesystem, recovery will replay
+			 * the write() data.
+			 */
+			if (jh->b_jlist != HFSPLUS_BJ_None &&
+					jh->b_jlist != HFSPLUS_BJ_SyncData &&
+					jh->b_jlist != HFSPLUS_BJ_Locked) {
+				HFSPLUS_JBUFFER_TRACE(jh, "Not stealing");
+				goto no_journal;
+			}
+
+			/*
+			 * This buffer may be undergoing writeout in commit.  We
+			 * can't return from here and let the caller dirty it
+			 * again because that can cause the write-out loop in
+			 * commit to never terminate.
+			 */
+			if (buffer_dirty(bh)) {
+				get_bh(bh);
+				spin_unlock(&journal->j_list_lock);
+				hfsplus_jbd_unlock_bh_state(bh);
+				need_brelse = 1;
+				sync_dirty_buffer(bh);
+				hfsplus_jbd_lock_bh_state(bh);
+				spin_lock(&journal->j_list_lock);
+				/* Since we dropped the lock... */
+				if (!buffer_mapped(bh)) {
+					HFSPLUS_JBUFFER_TRACE(jh, "buffer got unmapped");
+					goto no_journal;
+				}
+				/* The buffer may become locked again at any
+				   time if it is redirtied */
+			}
+
+			/*
+			 * We cannot remove the buffer with io error from the
+			 * committing transaction, because otherwise it would
+			 * miss the error and the commit would not abort.
+			 */
+			if (unlikely(!buffer_uptodate(bh))) {
+				ret = -EIO;
+				goto no_journal;
+			}
+
+			if (jh->b_transaction != NULL) {
+				HFSPLUS_JBUFFER_TRACE(jh, "unfile from commit");
+				__hfsplus_jbd_temp_unlink_buffer(jh);
+				/* It still points to the committing
+				 * transaction; move it to this one so
+				 * that the refile assert checks are
+				 * happy. */
+				jh->b_transaction = handle->h_transaction;
+			}
+			/* The buffer will be refiled below */
+
+		}
+		/*
+		 * Special case --- the buffer might actually have been
+		 * allocated and then immediately deallocated in the previous,
+		 * committing transaction, so might still be left on that
+		 * transaction's metadata lists.
+		 */
+		if (jh->b_jlist != HFSPLUS_BJ_SyncData && jh->b_jlist != HFSPLUS_BJ_Locked) {
+			HFSPLUS_JBUFFER_TRACE(jh, "not on correct data list: unfile");
+			HFSPLUS_J_ASSERT_JH(jh, jh->b_jlist != HFSPLUS_BJ_Shadow);
+			__hfsplus_jbd_temp_unlink_buffer(jh);
+			jh->b_transaction = handle->h_transaction;
+			HFSPLUS_JBUFFER_TRACE(jh, "file as data");
+			__hfsplus_jbd_file_buffer(jh, handle->h_transaction,
+						HFSPLUS_BJ_SyncData);
+		}
+	} else {
+		HFSPLUS_JBUFFER_TRACE(jh, "not on a transaction");
+		__hfsplus_jbd_file_buffer(jh, handle->h_transaction, HFSPLUS_BJ_SyncData);
+	}
+no_journal:
+	spin_unlock(&journal->j_list_lock);
+	hfsplus_jbd_unlock_bh_state(bh);
+	if (need_brelse) {
+		HFSPLUS_BUFFER_TRACE(bh, "brelse");
+		__brelse(bh);
+	}
+	HFSPLUS_JBUFFER_TRACE(jh, "exit");
+	hfsplus_jbd_put_journal_head(jh);
+	return ret;
+}
+
+/** 
+ * int hfsplus_jbd_dirty_metadata() -  mark a buffer as containing dirty metadata
+ * @handle: transaction to add buffer to.
+ * @bh: buffer to mark 
+ *
+ * Mark dirty metadata which needs to be journaled as part of the current
+ * transaction.
+ *
+ * The buffer is placed on the transaction's metadata list and is marked
+ * as belonging to the transaction.  
+ *
+ * Returns error number or 0 on success.  
+ *
+ * Special care needs to be taken if the buffer already belongs to the
+ * current committing transaction (in which case we should have frozen
+ * data present for that commit).  In that case, we don't relink the
+ * buffer: that only gets done when the old transaction finally
+ * completes its commit.
+ */
+int hfsplus_jbd_dirty_metadata(hfsplus_jbd_handle_t *handle, struct buffer_head *bh)
+{
+	hfsplus_transaction_t *transaction = handle->h_transaction;
+	hfsplus_jbd_t *journal = transaction->t_journal;
+	struct hfsplus_jbd_head *jh = hfsplus_bh2jh(bh);
+
+	hfsplus_jbd_debug(5, "hfsplus_jbd_head %p\n", jh);
+	HFSPLUS_JBUFFER_TRACE(jh, "entry");
+	if (hfsplus_jbd_is_handle_aborted(handle))
+		goto out;
+
+	hfsplus_jbd_lock_bh_state(bh);
+
+	if (jh->b_modified == 0) {
+		/*
+		 * This buffer's got modified and becoming part
+		 * of the transaction. This needs to be done
+		 * once a transaction -bzzz
+		 */
+		jh->b_modified = 1;
+		HFSPLUS_J_ASSERT_JH(jh, handle->h_buffer_credits > 0);
+		handle->h_buffer_credits--;
+	}
+
+	/*
+	 * fastpath, to avoid expensive locking.  If this buffer is already
+	 * on the running transaction's metadata list there is nothing to do.
+	 * Nobody can take it off again because there is a handle open.
+	 * I _think_ we're OK here with SMP barriers - a mistaken decision will
+	 * result in this test being false, so we go in and take the locks.
+	 */
+	if (jh->b_transaction == transaction && jh->b_jlist == HFSPLUS_BJ_Metadata) {
+		HFSPLUS_JBUFFER_TRACE(jh, "fastpath");
+		HFSPLUS_J_ASSERT_JH(jh, jh->b_transaction ==
+					journal->j_running_transaction);
+		goto out_unlock_bh;
+	}
+
+	set_buffer_hfsplus_jbddirty(bh);
+
+	/* 
+	 * Metadata already on the current transaction list doesn't
+	 * need to be filed.  Metadata on another transaction's list must
+	 * be committing, and will be refiled once the commit completes:
+	 * leave it alone for now. 
+	 */
+	if (jh->b_transaction != transaction) {
+		HFSPLUS_JBUFFER_TRACE(jh, "already on other transaction");
+		HFSPLUS_J_ASSERT_JH(jh, jh->b_transaction ==
+					journal->j_committing_transaction);
+		HFSPLUS_J_ASSERT_JH(jh, jh->b_next_transaction == transaction);
+		/* And this case is illegal: we can't reuse another
+		 * transaction's data buffer, ever. */
+		goto out_unlock_bh;
+	}
+
+	/* That test should have eliminated the following case: */
+	HFSPLUS_J_ASSERT_JH(jh, jh->b_frozen_data == NULL);
+
+	HFSPLUS_JBUFFER_TRACE(jh, "file as HFSPLUS_BJ_Metadata");
+	spin_lock(&journal->j_list_lock);
+	__hfsplus_jbd_file_buffer(jh, handle->h_transaction, HFSPLUS_BJ_Metadata);
+	spin_unlock(&journal->j_list_lock);
+out_unlock_bh:
+	hfsplus_jbd_unlock_bh_state(bh);
+out:
+	HFSPLUS_JBUFFER_TRACE(jh, "exit");
+	return 0;
+}
+
+/* 
+ * hfsplus_jbd_release_buffer: undo a get_write_access without any buffer
+ * updates, if the update decided in the end that it didn't need access.
+ *
+ */
+void
+hfsplus_jbd_release_buffer(hfsplus_jbd_handle_t *handle, struct buffer_head *bh)
+{
+	HFSPLUS_BUFFER_TRACE(bh, "entry");
+}
+
+/** 
+ * void hfsplus_jbd_forget() - bforget() for potentially-journaled buffers.
+ * @handle: transaction handle
+ * @bh:     bh to 'forget'
+ *
+ * We can only do the bforget if there are no commits pending against the
+ * buffer.  If the buffer is dirty in the current running transaction we
+ * can safely unlink it. 
+ *
+ * bh may not be a journalled buffer at all - it may be a non-JBD
+ * buffer which came off the hashtable.  Check for this.
+ *
+ * Decrements bh->b_count by one.
+ * 
+ * Allow this call even if the handle has aborted --- it may be part of
+ * the caller's cleanup after an abort.
+ */
+int hfsplus_jbd_forget (hfsplus_jbd_handle_t *handle, struct buffer_head *bh)
+{
+	hfsplus_transaction_t *transaction = handle->h_transaction;
+	hfsplus_jbd_t *journal = transaction->t_journal;
+	struct hfsplus_jbd_head *jh;
+	int drop_reserve = 0;
+	int err = 0;
+	int was_modified = 0;
+
+	HFSPLUS_BUFFER_TRACE(bh, "entry");
+
+	hfsplus_jbd_lock_bh_state(bh);
+	spin_lock(&journal->j_list_lock);
+
+	if (!buffer_hfsplus_jbd(bh))
+		goto not_jbd;
+	jh = hfsplus_bh2jh(bh);
+
+	/* Critical error: attempting to delete a bitmap buffer, maybe?
+	 * Don't do any jbd operations, and return an error. */
+	if (!HFSPLUS_J_EXPECT_JH(jh, !jh->b_committed_data,
+			 "inconsistent data on disk")) {
+		err = -EIO;
+		goto not_jbd;
+	}
+
+	/* keep track of wether or not this transaction modified us */
+	was_modified = jh->b_modified;
+
+	/*
+	 * The buffer's going from the transaction, we must drop
+	 * all references -bzzz
+	 */
+	jh->b_modified = 0;
+
+	if (jh->b_transaction == handle->h_transaction) {
+		HFSPLUS_J_ASSERT_JH(jh, !jh->b_frozen_data);
+
+		/* If we are forgetting a buffer which is already part
+		 * of this transaction, then we can just drop it from
+		 * the transaction immediately. */
+		clear_buffer_dirty(bh);
+		clear_buffer_hfsplus_jbddirty(bh);
+
+		HFSPLUS_JBUFFER_TRACE(jh, "belongs to current transaction: unfile");
+
+		/*
+		 * we only want to drop a reference if this transaction
+		 * modified the buffer
+		 */
+		if (was_modified)
+			drop_reserve = 1;
+
+		/* 
+		 * We are no longer going to journal this buffer.
+		 * However, the commit of this transaction is still
+		 * important to the buffer: the delete that we are now
+		 * processing might obsolete an old log entry, so by
+		 * committing, we can satisfy the buffer's checkpoint.
+		 *
+		 * So, if we have a checkpoint on the buffer, we should
+		 * now refile the buffer on our HFSPLUS_BJ_Forget list so that
+		 * we know to remove the checkpoint after we commit. 
+		 */
+
+		if (jh->b_cp_transaction) {
+			__hfsplus_jbd_temp_unlink_buffer(jh);
+			__hfsplus_jbd_file_buffer(jh, transaction, HFSPLUS_BJ_Forget);
+		} else {
+			__hfsplus_jbd_unfile_buffer(jh);
+			hfsplus_jbd_remove_journal_head(bh);
+			__brelse(bh);
+			if (!buffer_hfsplus_jbd(bh)) {
+				spin_unlock(&journal->j_list_lock);
+				hfsplus_jbd_unlock_bh_state(bh);
+				__bforget(bh);
+				goto drop;
+			}
+		}
+	} else if (jh->b_transaction) {
+		HFSPLUS_J_ASSERT_JH(jh, (jh->b_transaction ==
+				 journal->j_committing_transaction));
+		/* However, if the buffer is still owned by a prior
+		 * (committing) transaction, we can't drop it yet... */
+		HFSPLUS_JBUFFER_TRACE(jh, "belongs to older transaction");
+		/* ... but we CAN drop it from the new transaction if we
+		 * have also modified it since the original commit. */
+
+		if (jh->b_next_transaction) {
+			HFSPLUS_J_ASSERT(jh->b_next_transaction == transaction);
+			jh->b_next_transaction = NULL;
+
+			/*
+			 * only drop a reference if this transaction modified
+			 * the buffer
+			 */
+			if (was_modified)
+				drop_reserve = 1;
+		}
+	}
+
+not_jbd:
+	spin_unlock(&journal->j_list_lock);
+	hfsplus_jbd_unlock_bh_state(bh);
+	__brelse(bh);
+drop:
+	if (drop_reserve) {
+		/* no need to reserve log space for this block -bzzz */
+		handle->h_buffer_credits++;
+	}
+	return err;
+}
+
+/**
+ * int hfsplus_jbd_stop() - complete a transaction
+ * @handle: tranaction to complete.
+ * 
+ * All done for a particular handle.
+ *
+ * There is not much action needed here.  We just return any remaining
+ * buffer credits to the transaction and remove the handle.  The only
+ * complication is that we need to start a commit operation if the
+ * filesystem is marked for synchronous update.
+ *
+ * hfsplus_jbd_stop itself will not usually return an error, but it may
+ * do so in unusual circumstances.  In particular, expect it to 
+ * return -EIO if a hfsplus_jbd_abort has been executed since the
+ * transaction began.
+ */
+int hfsplus_jbd_stop(hfsplus_jbd_handle_t *handle)
+{
+	hfsplus_transaction_t *transaction = handle->h_transaction;
+	hfsplus_jbd_t *journal = transaction->t_journal;
+	hfsplus_handle_t *hfsplus_handle;
+	int err;
+	hfsplus_jbd_tid_t pid;
+
+	hfsplus_handle = hfsplus_jbd_current_handle();
+	HFSPLUS_J_ASSERT(hfsplus_handle->handle == handle);
+
+	if (hfsplus_jbd_is_handle_aborted(handle))
+		err = -EIO;
+	else {
+		HFSPLUS_J_ASSERT(transaction->t_updates > 0);
+		err = 0;
+	}
+
+	if (--handle->h_ref > 0) {
+		hfsplus_jbd_debug(4, "h_ref %d -> %d\n", handle->h_ref + 1,
+			  handle->h_ref);
+		return err;
+	}
+
+	hfsplus_jbd_debug(4, "Handle %p going down\n", handle);
+
+	/*
+	 * Implement synchronous transaction batching.  If the handle
+	 * was synchronous, don't force a commit immediately.  Let's
+	 * yield and let another thread piggyback onto this transaction.
+	 * Keep doing that while new threads continue to arrive.
+	 * It doesn't cost much - we're about to run a commit and sleep
+	 * on IO anyway.  Speeds up many-threaded, many-dir operations
+	 * by 30x or more...
+	 *
+	 * We try and optimize the sleep time against what the underlying disk
+	 * can do, instead of having a static sleep time.  This is usefull for
+	 * the case where our storage is so fast that it is more optimal to go
+	 * ahead and force a flush and wait for the transaction to be committed
+	 * than it is to wait for an arbitrary amount of time for new writers to
+	 * join the transaction.  We acheive this by measuring how long it takes
+	 * to commit a transaction, and compare it with how long this
+	 * transaction has been running, and if run time < commit time then we
+	 * sleep for the delta and commit.  This greatly helps super fast disks
+	 * that would see slowdowns as more threads started doing fsyncs.
+	 *
+	 * But don't do this if this process was the most recent one to
+	 * perform a synchronous write.  We do this to detect the case where a
+	 * single process is doing a stream of sync writes.  No point in waiting
+	 * for joiners in that case.
+	 */
+	pid = current->pid;
+	if (handle->h_sync && journal->j_last_sync_writer != pid) {
+		u64 commit_time, trans_time;
+
+		journal->j_last_sync_writer = pid;
+
+		spin_lock(&journal->j_state_lock);
+		commit_time = journal->j_average_commit_time;
+		spin_unlock(&journal->j_state_lock);
+
+		trans_time = ktime_to_ns(ktime_sub(ktime_get(),
+						   transaction->t_start_time));
+
+		commit_time = min_t(u64, commit_time,
+				    1000*jiffies_to_usecs(1));
+
+		if (trans_time < commit_time) {
+			ktime_t expires = ktime_add_ns(ktime_get(),
+						       commit_time);
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_hrtimeout(&expires, HRTIMER_MODE_ABS);
+		}
+	}
+
+	if (handle->h_sync)
+		transaction->t_synchronous_commit = 1;
+	current->journal_info = NULL;
+	spin_lock(&journal->j_state_lock);
+	spin_lock(&transaction->t_handle_lock);
+	transaction->t_outstanding_credits -= handle->h_buffer_credits;
+	transaction->t_updates--;
+	if (!transaction->t_updates) {
+		wake_up(&journal->j_wait_updates);
+		if (journal->j_barrier_count)
+			wake_up(&journal->j_wait_transaction_locked);
+	}
+
+	/*
+	 * If the handle is marked SYNC, we need to set another commit
+	 * going!  We also want to force a commit if the current
+	 * transaction is occupying too much of the log, or if the
+	 * transaction is too old now.
+	 */
+	if (handle->h_sync ||
+			transaction->t_outstanding_credits >
+				journal->j_max_transaction_buffers ||
+			time_after_eq(jiffies, transaction->t_expires)) {
+		/* Do this even for aborted journals: an abort still
+		 * completes the commit thread, it just doesn't write
+		 * anything to disk. */
+		hfsplus_jbd_tid_t tid = transaction->t_tid;
+
+		spin_unlock(&transaction->t_handle_lock);
+		hfsplus_jbd_debug(2, "transaction too old, requesting commit for "
+					"handle %p\n", handle);
+		/* This is non-blocking */
+		__hfsplus__log_start_commit(journal, transaction->t_tid);
+		spin_unlock(&journal->j_state_lock);
+
+		/*
+		 * Special case: JFS_SYNC synchronous updates require us
+		 * to wait for the commit to complete.  
+		 */
+		if (handle->h_sync && !(current->flags & PF_MEMALLOC))
+			err = hfsplus_jbd_log_wait_commit(journal, tid);
+	} else {
+		spin_unlock(&transaction->t_handle_lock);
+		spin_unlock(&journal->j_state_lock);
+	}
+
+	lock_map_release(&handle->h_lockdep_map);
+
+	hfsplus_jbd_free_handle(handle);
+	return err;
+}
+
+/**
+ * int hfsplus_jbd_force_commit() - force any uncommitted transactions
+ * @journal: journal to force
+ *
+ * For synchronous operations: force any uncommitted transactions
+ * to disk.  May seem kludgy, but it reuses all the handle batching
+ * code in a very simple manner.
+ */
+int hfsplus_jbd_force_commit(hfsplus_jbd_t *journal)
+{
+	hfsplus_handle_t hfsplus_handle;
+	int ret;
+
+	hfsplus_handle.handle = hfsplus_jbd_start(journal, 1, &hfsplus_handle);
+	if (IS_ERR(hfsplus_handle.handle)) {
+		ret = PTR_ERR(hfsplus_handle.handle);
+	} else {
+		hfsplus_handle.handle->h_sync = 1;
+		ret = hfsplus_jbd_stop(hfsplus_handle.handle);
+	}
+	return ret;
+}
+
+/*
+ *
+ * List management code snippets: various functions for manipulating the
+ * transaction buffer lists.
+ *
+ */
+
+/*
+ * Append a buffer to a transaction list, given the transaction's list head
+ * pointer.
+ *
+ * j_list_lock is held.
+ *
+ * hfsplus_jbd_lock_bh_state(hfsplus_jh2bh(jh)) is held.
+ */
+
+static inline void 
+__blist_add_buffer(struct hfsplus_jbd_head **list, struct hfsplus_jbd_head *jh)
+{
+	if (!*list) {
+		jh->b_tnext = jh->b_tprev = jh;
+		*list = jh;
+	} else {
+		/* Insert at the tail of the list to preserve order */
+		struct hfsplus_jbd_head *first = *list, *last = first->b_tprev;
+		jh->b_tprev = last;
+		jh->b_tnext = first;
+		last->b_tnext = first->b_tprev = jh;
+	}
+}
+
+/* 
+ * Remove a buffer from a transaction list, given the transaction's list
+ * head pointer.
+ *
+ * Called with j_list_lock held, and the journal may not be locked.
+ *
+ * hfsplus_jbd_lock_bh_state(hfsplus_jh2bh(jh)) is held.
+ */
+
+static inline void
+__blist_del_buffer(struct hfsplus_jbd_head **list, struct hfsplus_jbd_head *jh)
+{
+	if (*list == jh) {
+		*list = jh->b_tnext;
+		if (*list == jh)
+			*list = NULL;
+	}
+	jh->b_tprev->b_tnext = jh->b_tnext;
+	jh->b_tnext->b_tprev = jh->b_tprev;
+}
+
+/* 
+ * Remove a buffer from the appropriate transaction list.
+ *
+ * Note that this function can *change* the value of
+ * bh->b_transaction->t_sync_datalist, t_buffers, t_forget,
+ * t_iobuf_list, t_shadow_list, t_log_list or t_reserved_list.  If the caller
+ * is holding onto a copy of one of thee pointers, it could go bad.
+ * Generally the caller needs to re-read the pointer from the hfsplus_transaction_t.
+ *
+ * Called under j_list_lock.  The journal may not be locked.
+ */
+static void __hfsplus_jbd_temp_unlink_buffer(struct hfsplus_jbd_head *jh)
+{
+	struct hfsplus_jbd_head **list = NULL;
+	hfsplus_transaction_t *transaction;
+	struct buffer_head *bh = hfsplus_jh2bh(jh);
+
+	HFSPLUS_J_ASSERT_JH(jh, hfsplus_jbd_is_locked_bh_state(bh));
+	transaction = jh->b_transaction;
+	if (transaction)
+		assert_spin_locked(&transaction->t_journal->j_list_lock);
+
+	HFSPLUS_J_ASSERT_JH(jh, jh->b_jlist < HFSPLUS_BJ_Types);
+	if (jh->b_jlist != HFSPLUS_BJ_None)
+		HFSPLUS_J_ASSERT_JH(jh, transaction != NULL);
+
+	switch (jh->b_jlist) {
+	case HFSPLUS_BJ_None:
+		return;
+	case HFSPLUS_BJ_SyncData:
+		list = &transaction->t_sync_datalist;
+		break;
+	case HFSPLUS_BJ_Metadata:
+		transaction->t_nr_buffers--;
+		HFSPLUS_J_ASSERT_JH(jh, transaction->t_nr_buffers >= 0);
+		list = &transaction->t_buffers;
+		break;
+	case HFSPLUS_BJ_Forget:
+		list = &transaction->t_forget;
+		break;
+	case HFSPLUS_BJ_IO:
+		list = &transaction->t_iobuf_list;
+		break;
+	case HFSPLUS_BJ_Shadow:
+		list = &transaction->t_shadow_list;
+		break;
+	case HFSPLUS_BJ_LogCtl:
+		list = &transaction->t_log_list;
+		break;
+	case HFSPLUS_BJ_Reserved:
+		list = &transaction->t_reserved_list;
+		break;
+	case HFSPLUS_BJ_Locked:
+		list = &transaction->t_locked_list;
+		break;
+	}
+
+	__blist_del_buffer(list, jh);
+	jh->b_jlist = HFSPLUS_BJ_None;
+	if (test_clear_buffer_hfsplus_jbddirty(bh))
+		mark_buffer_dirty(bh);	/* Expose it to the VM */
+}
+
+void __hfsplus_jbd_unfile_buffer(struct hfsplus_jbd_head *jh)
+{
+	__hfsplus_jbd_temp_unlink_buffer(jh);
+	jh->b_transaction = NULL;
+}
+
+void hfsplus_jbd_unfile_buffer(hfsplus_jbd_t *journal, struct hfsplus_jbd_head *jh)
+{
+	hfsplus_jbd_lock_bh_state(hfsplus_jh2bh(jh));
+	spin_lock(&journal->j_list_lock);
+	__hfsplus_jbd_unfile_buffer(jh);
+	spin_unlock(&journal->j_list_lock);
+	hfsplus_jbd_unlock_bh_state(hfsplus_jh2bh(jh));
+}
+
+/*
+ * Called from hfsplus_jbd_try_to_free_buffers().
+ *
+ * Called under hfsplus_jbd_lock_bh_state(bh)
+ */
+static void
+__hfsplus_jbd_try_to_free_buffer(hfsplus_jbd_t *journal, struct buffer_head *bh)
+{
+	struct hfsplus_jbd_head *jh;
+
+	jh = hfsplus_bh2jh(bh);
+
+	if (buffer_locked(bh) || buffer_dirty(bh))
+		goto out;
+
+	if (jh->b_next_transaction != NULL)
+		goto out;
+
+	spin_lock(&journal->j_list_lock);
+	if (jh->b_transaction != NULL && jh->b_cp_transaction == NULL) {
+		if (jh->b_jlist == HFSPLUS_BJ_SyncData || jh->b_jlist == HFSPLUS_BJ_Locked) {
+			/* A written-back ordered data buffer */
+			HFSPLUS_JBUFFER_TRACE(jh, "release data");
+			__hfsplus_jbd_unfile_buffer(jh);
+			hfsplus_jbd_remove_journal_head(bh);
+			__brelse(bh);
+		}
+	} else if (jh->b_cp_transaction != NULL && jh->b_transaction == NULL) {
+		/* written-back checkpointed metadata buffer */
+		if (jh->b_jlist == HFSPLUS_BJ_None) {
+			HFSPLUS_JBUFFER_TRACE(jh, "remove from checkpoint list");
+			__hfsplus_jbd_remove_checkpoint(jh);
+			hfsplus_jbd_remove_journal_head(bh);
+			__brelse(bh);
+		}
+	}
+	spin_unlock(&journal->j_list_lock);
+out:
+	return;
+}
+
+/** 
+ * int hfsplus_jbd_try_to_free_buffers() - try to free page buffers.
+ * @journal: journal for operation
+ * @page: to try and free
+ * @gfp_mask: we use the mask to detect how hard should we try to release
+ * buffers. If __GFP_WAIT and __GFP_FS is set, we wait for commit code to
+ * release the buffers.
+ * 
+ *
+ * For all the buffers on this page,
+ * if they are fully written out ordered data, move them onto BUF_CLEAN
+ * so try_to_free_buffers() can reap them.
+ * 
+ * This function returns non-zero if we wish try_to_free_buffers()
+ * to be called. We do this if the page is releasable by try_to_free_buffers().
+ * We also do it if the page has locked or dirty buffers and the caller wants
+ * us to perform sync or async writeout.
+ *
+ * This complicates JBD locking somewhat.  We aren't protected by the
+ * BKL here.  We wish to remove the buffer from its committing or
+ * running transaction's ->t_datalist via __hfsplus_jbd_unfile_buffer.
+ *
+ * This may *change* the value of hfsplus_transaction_t->t_datalist, so anyone
+ * who looks at t_datalist needs to lock against this function.
+ *
+ * Even worse, someone may be doing a hfsplus_jbd_dirty_data on this
+ * buffer.  So we need to lock against that.  hfsplus_jbd_dirty_data()
+ * will come out of the lock with the buffer dirty, which makes it
+ * ineligible for release here.
+ *
+ * Who else is affected by this?  hmm...  Really the only contender
+ * is do_get_write_access() - it could be looking at the buffer while
+ * hfsplus_jbd_try_to_free_buffer() is changing its state.  But that
+ * cannot happen because we never reallocate freed data as metadata
+ * while the data is part of a transaction.  Yes?
+ *
+ * Return 0 on failure, 1 on success
+ */
+int hfsplus_jbd_try_to_free_buffers(hfsplus_jbd_t *journal, 
+				struct page *page, gfp_t gfp_mask)
+{
+	struct buffer_head *head;
+	struct buffer_head *bh;
+	int ret = 0;
+
+	HFSPLUS_J_ASSERT(PageLocked(page));
+
+	head = page_buffers(page);
+	bh = head;
+	do {
+		struct hfsplus_jbd_head *jh;
+
+		/*
+		 * We take our own ref against the hfsplus_jbd_head here to avoid
+		 * having to add tons of locking around each instance of
+		 * hfsplus_jbd_remove_journal_head() and hfsplus_jbd_put_journal_head().
+		 */
+		jh = hfsplus_jbd_grab_journal_head(bh);
+		if (!jh)
+			continue;
+
+		hfsplus_jbd_lock_bh_state(bh);
+		__hfsplus_jbd_try_to_free_buffer(journal, bh);
+		hfsplus_jbd_put_journal_head(jh);
+		hfsplus_jbd_unlock_bh_state(bh);
+		if (buffer_hfsplus_jbd(bh))
+			goto busy;
+	} while ((bh = bh->b_this_page) != head);
+
+	ret = try_to_free_buffers(page);
+
+busy:
+	return ret;
+}
+
+/*
+ * This buffer is no longer needed.  If it is on an older transaction's
+ * checkpoint list we need to record it on this transaction's forget list
+ * to pin this buffer (and hence its checkpointing transaction) down until
+ * this transaction commits.  If the buffer isn't on a checkpoint list, we
+ * release it.
+ * Returns non-zero if JBD no longer has an interest in the buffer.
+ *
+ * Called under j_list_lock.
+ *
+ * Called under jbd_lock_bh_state(bh).
+ */
+static int __dispose_buffer(struct hfsplus_jbd_head *jh, hfsplus_transaction_t *transaction)
+{
+	int may_free = 1;
+	struct buffer_head *bh = hfsplus_jh2bh(jh);
+
+	__hfsplus_jbd_unfile_buffer(jh);
+
+	if (jh->b_cp_transaction) {
+		HFSPLUS_JBUFFER_TRACE(jh, "on running+cp transaction");
+		/*
+		 * We don't want to write the buffer anymore, clear the
+		 * bit so that we don't confuse checks in
+		 * __hfsplus_jbd_file_buffer
+		 */
+		clear_buffer_dirty(bh);
+		__hfsplus_jbd_file_buffer(jh, transaction, HFSPLUS_BJ_Forget);
+		may_free = 0;
+	} else {
+		HFSPLUS_JBUFFER_TRACE(jh, "on running transaction");
+		hfsplus_jbd_remove_journal_head(bh);
+		__brelse(bh);
+	}
+	return may_free;
+}
+
+/*
+ * hfsplus_jbd_invalidatepage 
+ *
+ * This code is tricky.  It has a number of cases to deal with.
+ *
+ * There are two invariants which this code relies on:
+ *
+ * i_size must be updated on disk before we start calling invalidatepage on the
+ * data.
+ * 
+ *  This is done in ext3 by defining an ext3_setattr method which
+ *  updates i_size before truncate gets going.  By maintaining this
+ *  invariant, we can be sure that it is safe to throw away any buffers
+ *  attached to the current transaction: once the transaction commits,
+ *  we know that the data will not be needed.
+ * 
+ *  Note however that we can *not* throw away data belonging to the
+ *  previous, committing transaction!  
+ *
+ * Any disk blocks which *are* part of the previous, committing
+ * transaction (and which therefore cannot be discarded immediately) are
+ * not going to be reused in the new running transaction
+ *
+ *  The bitmap committed_data images guarantee this: any block which is
+ *  allocated in one transaction and removed in the next will be marked
+ *  as in-use in the committed_data bitmap, so cannot be reused until
+ *  the next transaction to delete the block commits.  This means that
+ *  leaving committing buffers dirty is quite safe: the disk blocks
+ *  cannot be reallocated to a different file and so buffer aliasing is
+ *  not possible.
+ *
+ *
+ * The above applies mainly to ordered data mode.  In writeback mode we
+ * don't make guarantees about the order in which data hits disk --- in
+ * particular we don't guarantee that new dirty data is flushed before
+ * transaction commit --- so it is always safe just to discard data
+ * immediately in that mode.  --sct 
+ */
+
+/*
+ * The hfsplus_jbd_unmap_buffer helper function returns zero if the buffer
+ * concerned remains pinned as an anonymous buffer belonging to an older
+ * transaction.
+ *
+ * We're outside-transaction here.  Either or both of j_running_transaction
+ * and j_committing_transaction may be NULL.
+ */
+static int hfsplus_jbd_unmap_buffer(hfsplus_jbd_t *journal, struct buffer_head *bh)
+{
+	hfsplus_transaction_t *transaction;
+	struct hfsplus_jbd_head *jh;
+	int may_free = 1;
+	int ret;
+
+	HFSPLUS_BUFFER_TRACE(bh, "entry");
+
+	/*
+	 * It is safe to proceed here without the j_list_lock because the
+	 * buffers cannot be stolen by try_to_free_buffers as long as we are
+	 * holding the page lock. --sct
+	 */
+
+	if (!buffer_hfsplus_jbd(bh))
+		goto zap_buffer_unlocked;
+
+	spin_lock(&journal->j_state_lock);
+	hfsplus_jbd_lock_bh_state(bh);
+	spin_lock(&journal->j_list_lock);
+
+	jh = hfsplus_jbd_grab_journal_head(bh);
+	if (!jh)
+		goto zap_buffer_no_jh;
+
+	transaction = jh->b_transaction;
+	if (transaction == NULL) {
+		/* First case: not on any transaction.  If it
+		 * has no checkpoint link, then we can zap it:
+		 * it's a writeback-mode buffer so we don't care
+		 * if it hits disk safely. */
+		if (!jh->b_cp_transaction) {
+			HFSPLUS_JBUFFER_TRACE(jh, "not on any transaction: zap");
+			goto zap_buffer;
+		}
+
+		if (!buffer_dirty(bh)) {
+			/* bdflush has written it.  We can drop it now */
+			goto zap_buffer;
+		}
+
+		/* OK, it must be in the journal but still not
+		 * written fully to disk: it's metadata or
+		 * journaled data... */
+
+		if (journal->j_running_transaction) {
+			/* ... and once the current transaction has
+			 * committed, the buffer won't be needed any
+			 * longer. */
+			HFSPLUS_JBUFFER_TRACE(jh, "checkpointed: add to HFSPLUS_BJ_Forget");
+			ret = __dispose_buffer(jh,
+					journal->j_running_transaction);
+			hfsplus_jbd_put_journal_head(jh);
+			spin_unlock(&journal->j_list_lock);
+			hfsplus_jbd_unlock_bh_state(bh);
+			spin_unlock(&journal->j_state_lock);
+			return ret;
+		} else {
+			/* There is no currently-running transaction. So the
+			 * orphan record which we wrote for this file must have
+			 * passed into commit.  We must attach this buffer to
+			 * the committing transaction, if it exists. */
+			if (journal->j_committing_transaction) {
+				HFSPLUS_JBUFFER_TRACE(jh, "give to committing trans");
+				ret = __dispose_buffer(jh,
+					journal->j_committing_transaction);
+				hfsplus_jbd_put_journal_head(jh);
+				spin_unlock(&journal->j_list_lock);
+				hfsplus_jbd_unlock_bh_state(bh);
+				spin_unlock(&journal->j_state_lock);
+				return ret;
+			} else {
+				/* The orphan record's transaction has
+				 * committed.  We can cleanse this buffer */
+				clear_buffer_hfsplus_jbddirty(bh);
+				goto zap_buffer;
+			}
+		}
+	} else if (transaction == journal->j_committing_transaction) {
+		HFSPLUS_JBUFFER_TRACE(jh, "on committing transaction");
+		if (jh->b_jlist == HFSPLUS_BJ_Locked) {
+			/*
+			 * The buffer is on the committing transaction's locked
+			 * list.  We have the buffer locked, so I/O has
+			 * completed.  So we can nail the buffer now.
+			 */
+			may_free = __dispose_buffer(jh, transaction);
+			goto zap_buffer;
+		}
+		/*
+		 * If it is committing, we simply cannot touch it.  We
+		 * can remove it's next_transaction pointer from the
+		 * running transaction if that is set, but nothing
+		 * else. */
+		set_buffer_hfsplus_jbd_freed(bh);
+		if (jh->b_next_transaction) {
+			HFSPLUS_J_ASSERT(jh->b_next_transaction ==
+					journal->j_running_transaction);
+			jh->b_next_transaction = NULL;
+		}
+		hfsplus_jbd_put_journal_head(jh);
+		spin_unlock(&journal->j_list_lock);
+		hfsplus_jbd_unlock_bh_state(bh);
+		spin_unlock(&journal->j_state_lock);
+		return 0;
+	} else {
+		/* Good, the buffer belongs to the running transaction.
+		 * We are writing our own transaction's data, not any
+		 * previous one's, so it is safe to throw it away
+		 * (remember that we expect the filesystem to have set
+		 * i_size already for this truncate so recovery will not
+		 * expose the disk blocks we are discarding here.) */
+		HFSPLUS_J_ASSERT_JH(jh, transaction == journal->j_running_transaction);
+		HFSPLUS_JBUFFER_TRACE(jh, "on running transaction");
+		may_free = __dispose_buffer(jh, transaction);
+	}
+
+zap_buffer:
+	hfsplus_jbd_put_journal_head(jh);
+zap_buffer_no_jh:
+	spin_unlock(&journal->j_list_lock);
+	hfsplus_jbd_unlock_bh_state(bh);
+	spin_unlock(&journal->j_state_lock);
+zap_buffer_unlocked:
+	clear_buffer_dirty(bh);
+	HFSPLUS_J_ASSERT_BH(bh, !buffer_hfsplus_jbddirty(bh));
+	clear_buffer_mapped(bh);
+	clear_buffer_req(bh);
+	clear_buffer_new(bh);
+	bh->b_bdev = NULL;
+	return may_free;
+}
+
+/** 
+ * void hfsplus_jbd_invalidatepage() - invalidate a journal page
+ * @journal: journal to use for flush
+ * @page:    page to flush
+ * @offset:  length of page to invalidate.
+ *
+ * Reap page buffers containing data after offset in page.
+ */
+void hfsplus_jbd_invalidatepage(hfsplus_jbd_t *journal, 
+		      struct page *page, 
+		      unsigned long offset)
+{
+	struct buffer_head *head, *bh, *next;
+	unsigned int curr_off = 0;
+	int may_free = 1;
+
+	if (!PageLocked(page))
+		BUG();
+	if (!page_has_buffers(page))
+		return;
+
+	/* We will potentially be playing with lists other than just the
+	 * data lists (especially for journaled data mode), so be
+	 * cautious in our locking. */
+
+	head = bh = page_buffers(page);
+	do {
+		unsigned int next_off = curr_off + bh->b_size;
+		next = bh->b_this_page;
+
+		if (offset <= curr_off) {
+			/* This block is wholly outside the truncation point */
+			lock_buffer(bh);
+			may_free &= hfsplus_jbd_unmap_buffer(journal, bh);
+			unlock_buffer(bh);
+		}
+		curr_off = next_off;
+		bh = next;
+
+	} while (bh != head);
+
+	if (!offset) {
+		if (may_free && try_to_free_buffers(page))
+			HFSPLUS_J_ASSERT(!page_has_buffers(page));
+	}
+}
+
+/* 
+ * File a buffer on the given transaction list. 
+ */
+void __hfsplus_jbd_file_buffer(struct hfsplus_jbd_head *jh,
+			hfsplus_transaction_t *transaction, int jlist)
+{
+	struct hfsplus_jbd_head **list = NULL;
+	int was_dirty = 0;
+	struct buffer_head *bh = hfsplus_jh2bh(jh);
+
+	HFSPLUS_J_ASSERT_JH(jh, hfsplus_jbd_is_locked_bh_state(bh));
+	assert_spin_locked(&transaction->t_journal->j_list_lock);
+
+	HFSPLUS_J_ASSERT_JH(jh, jh->b_jlist < HFSPLUS_BJ_Types);
+	HFSPLUS_J_ASSERT_JH(jh, jh->b_transaction == transaction ||
+				jh->b_transaction == NULL);
+
+	if (jh->b_transaction && jh->b_jlist == jlist)
+		return;
+
+	if (jlist == HFSPLUS_BJ_Metadata || jlist == HFSPLUS_BJ_Reserved || 
+	    jlist == HFSPLUS_BJ_Shadow || jlist == HFSPLUS_BJ_Forget) {
+		/*
+		 * For metadata buffers, we track dirty bit in buffer_jbddirty
+		 * instead of buffer_dirty. We should not see a dirty bit set
+		 * here because we clear it in do_get_write_access but e.g.
+		 * tune2fs can modify the sb and set the dirty bit at any time
+		 * so we try to gracefully handle that.
+		 */
+		//if (buffer_dirty(bh))
+		//	warn_dirty_buffer(bh);
+		if (test_clear_buffer_dirty(bh) ||
+		    test_clear_buffer_hfsplus_jbddirty(bh))
+			was_dirty = 1;
+	}
+
+	if (jh->b_transaction)
+		__hfsplus_jbd_temp_unlink_buffer(jh);
+	jh->b_transaction = transaction;
+
+	switch (jlist) {
+	case HFSPLUS_BJ_None:
+		HFSPLUS_J_ASSERT_JH(jh, !jh->b_committed_data);
+		HFSPLUS_J_ASSERT_JH(jh, !jh->b_frozen_data);
+		return;
+	case HFSPLUS_BJ_SyncData:
+		list = &transaction->t_sync_datalist;
+		break;
+	case HFSPLUS_BJ_Metadata:
+		transaction->t_nr_buffers++;
+		list = &transaction->t_buffers;
+		break;
+	case HFSPLUS_BJ_Forget:
+		list = &transaction->t_forget;
+		break;
+	case HFSPLUS_BJ_IO:
+		list = &transaction->t_iobuf_list;
+		break;
+	case HFSPLUS_BJ_Shadow:
+		list = &transaction->t_shadow_list;
+		break;
+	case HFSPLUS_BJ_LogCtl:
+		list = &transaction->t_log_list;
+		break;
+	case HFSPLUS_BJ_Reserved:
+		list = &transaction->t_reserved_list;
+		break;
+	case HFSPLUS_BJ_Locked:
+		list =  &transaction->t_locked_list;
+		break;
+	}
+
+	__blist_add_buffer(list, jh);
+	jh->b_jlist = jlist;
+
+	if (was_dirty)
+		set_buffer_hfsplus_jbddirty(bh);
+}
+
+void hfsplus_jbd_file_buffer(struct hfsplus_jbd_head *jh,
+				hfsplus_transaction_t *transaction, int jlist)
+{
+	hfsplus_jbd_lock_bh_state(hfsplus_jh2bh(jh));
+	spin_lock(&transaction->t_journal->j_list_lock);
+	__hfsplus_jbd_file_buffer(jh, transaction, jlist);
+	spin_unlock(&transaction->t_journal->j_list_lock);
+	hfsplus_jbd_unlock_bh_state(hfsplus_jh2bh(jh));
+}
+
+/* 
+ * Remove a buffer from its current buffer list in preparation for
+ * dropping it from its current transaction entirely.  If the buffer has
+ * already started to be used by a subsequent transaction, refile the
+ * buffer on that transaction's metadata list.
+ *
+ * Called under journal->j_list_lock
+ *
+ * Called under hfsplus_jbd_lock_bh_state(hfsplus_jh2bh(jh))
+ */
+void __hfsplus_jbd_refile_buffer(struct hfsplus_jbd_head *jh)
+{
+	int was_dirty;
+	struct buffer_head *bh = hfsplus_jh2bh(jh);
+
+	HFSPLUS_J_ASSERT_JH(jh, hfsplus_jbd_is_locked_bh_state(bh));
+	if (jh->b_transaction)
+		assert_spin_locked(&jh->b_transaction->t_journal->j_list_lock);
+
+	/* If the buffer is now unused, just drop it. */
+	if (jh->b_next_transaction == NULL) {
+		__hfsplus_jbd_unfile_buffer(jh);
+		return;
+	}
+
+	/*
+	 * It has been modified by a later transaction: add it to the new
+	 * transaction's metadata list.
+	 */
+
+	was_dirty = test_clear_buffer_hfsplus_jbddirty(bh);
+	__hfsplus_jbd_temp_unlink_buffer(jh);
+	jh->b_transaction = jh->b_next_transaction;
+	jh->b_next_transaction = NULL;
+	__hfsplus_jbd_file_buffer(jh, jh->b_transaction,
+				jh->b_modified ? HFSPLUS_BJ_Metadata : HFSPLUS_BJ_Reserved);
+	HFSPLUS_J_ASSERT_JH(jh, jh->b_transaction->t_state == HFSPLUS_T_RUNNING);
+
+	if (was_dirty)
+		set_buffer_hfsplus_jbddirty(bh);
+}
+
+/*
+ * For the unlocked version of this call, also make sure that any
+ * hanging hfsplus_jbd_head is cleaned up if necessary.
+ *
+ * __hfsplus_jbd_refile_buffer is usually called as part of a single locked
+ * operation on a buffer_head, in which the caller is probably going to
+ * be hooking the hfsplus_jbd_head onto other lists.  In that case it is up
+ * to the caller to remove the hfsplus_jbd_head if necessary.  For the
+ * unlocked hfsplus_jbd_refile_buffer call, the caller isn't going to be
+ * doing anything else to the buffer so we need to do the cleanup
+ * ourselves to avoid a jh leak. 
+ *
+ * *** The hfsplus_jbd_head may be freed by this call! ***
+ */
+void hfsplus_jbd_refile_buffer(hfsplus_jbd_t *journal, struct hfsplus_jbd_head *jh)
+{
+	struct buffer_head *bh = hfsplus_jh2bh(jh);
+
+	hfsplus_jbd_lock_bh_state(bh);
+	spin_lock(&journal->j_list_lock);
+
+	__hfsplus_jbd_refile_buffer(jh);
+	hfsplus_jbd_unlock_bh_state(bh);
+	hfsplus_jbd_remove_journal_head(bh);
+
+	spin_unlock(&journal->j_list_lock);
+	__brelse(bh);
+}
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/unicode.c linux-2.6.32/fs/hfsplus_journal/unicode.c
--- linux-2.6.32-old//fs/hfsplus_journal/unicode.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/unicode.c	2011-11-17 09:00:40.788818402 -0500
@@ -0,0 +1,440 @@
+/*
+ *  linux/fs/hfsplus/unicode.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handler routines for unicode strings
+ */
+
+#include <linux/types.h>
+#include <linux/nls.h>
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+/* Fold the case of a unicode char, given the 16 bit value */
+/* Returns folded char, or 0 if ignorable */
+static inline u16 case_fold(u16 c)
+{
+        u16 tmp;
+
+        tmp = hfsplus_case_fold_table[c >> 8];
+        if (tmp)
+                tmp = hfsplus_case_fold_table[tmp + (c & 0xff)];
+        else
+                tmp = c;
+        return tmp;
+}
+
+/* Compare unicode strings, return values like normal strcmp */
+int hfsplus_strcasecmp(const struct hfsplus_unistr *s1,
+		       const struct hfsplus_unistr *s2)
+{
+	u16 len1, len2, c1, c2;
+	const hfsplus_unichr *p1, *p2;
+
+	len1 = be16_to_cpu(s1->length);
+	len2 = be16_to_cpu(s2->length);
+	p1 = s1->unicode;
+	p2 = s2->unicode;
+
+	while (1) {
+		c1 = c2 = 0;
+
+		while (len1 && !c1) {
+			c1 = case_fold(be16_to_cpu(*p1));
+			p1++;
+			len1--;
+		}
+		while (len2 && !c2) {
+			c2 = case_fold(be16_to_cpu(*p2));
+			p2++;
+			len2--;
+		}
+
+		if (c1 != c2)
+			return (c1 < c2) ? -1 : 1;
+		if (!c1 && !c2)
+			return 0;
+	}
+}
+
+/* Compare names as a sequence of 16-bit unsigned integers */
+int hfsplus_strcmp(const struct hfsplus_unistr *s1,
+		   const struct hfsplus_unistr *s2)
+{
+	u16 len1, len2, c1, c2;
+	const hfsplus_unichr *p1, *p2;
+	int len;
+
+	len1 = be16_to_cpu(s1->length);
+	len2 = be16_to_cpu(s2->length);
+	p1 = s1->unicode;
+	p2 = s2->unicode;
+
+	for (len = min(len1, len2); len > 0; len--) {
+		c1 = be16_to_cpu(*p1);
+		c2 = be16_to_cpu(*p2);
+		if (c1 != c2)
+			return c1 < c2 ? -1 : 1;
+		p1++;
+		p2++;
+	}
+
+	return len1 < len2 ? -1 :
+	       len1 > len2 ? 1 : 0;
+}
+
+
+#define Hangul_SBase	0xac00
+#define Hangul_LBase	0x1100
+#define Hangul_VBase	0x1161
+#define Hangul_TBase	0x11a7
+#define Hangul_SCount	11172
+#define Hangul_LCount	19
+#define Hangul_VCount	21
+#define Hangul_TCount	28
+#define Hangul_NCount	(Hangul_VCount * Hangul_TCount)
+
+
+static u16 *hfsplus_compose_lookup(u16 *p, u16 cc)
+{
+	int i, s, e;
+
+	s = 1;
+	e = p[1];
+	if (!e || cc < p[s * 2] || cc > p[e * 2])
+		return NULL;
+	do {
+		i = (s + e) / 2;
+		if (cc > p[i * 2])
+			s = i + 1;
+		else if (cc < p[i * 2])
+			e = i - 1;
+		else
+			return hfsplus_compose_table + p[i * 2 + 1];
+	} while (s <= e);
+	return NULL;
+}
+
+int hfsplus_uni2asc(struct super_block *sb, const struct hfsplus_unistr *ustr, char *astr, int *len_p)
+{
+	const hfsplus_unichr *ip;
+	struct nls_table *nls = HFSPLUS_SB(sb).nls;
+	u8 *op;
+	u16 cc, c0, c1;
+	u16 *ce1, *ce2;
+	int i, len, ustrlen, res, compose;
+
+	op = astr;
+	ip = ustr->unicode;
+	ustrlen = be16_to_cpu(ustr->length);
+	len = *len_p;
+	ce1 = NULL;
+	compose = !(HFSPLUS_SB(sb).flags & HFSPLUS_SB_NODECOMPOSE);
+
+	while (ustrlen > 0) {
+		c0 = be16_to_cpu(*ip++);
+		ustrlen--;
+		/* search for single decomposed char */
+		if (likely(compose))
+			ce1 = hfsplus_compose_lookup(hfsplus_compose_table, c0);
+		if (ce1 && (cc = ce1[0])) {
+			/* start of a possibly decomposed Hangul char */
+			if (cc != 0xffff)
+				goto done;
+			if (!ustrlen)
+				goto same;
+			c1 = be16_to_cpu(*ip) - Hangul_VBase;
+			if (c1 < Hangul_VCount) {
+				/* compose the Hangul char */
+				cc = (c0 - Hangul_LBase) * Hangul_VCount;
+				cc = (cc + c1) * Hangul_TCount;
+				cc += Hangul_SBase;
+				ip++;
+				ustrlen--;
+				if (!ustrlen)
+					goto done;
+				c1 = be16_to_cpu(*ip) - Hangul_TBase;
+				if (c1 > 0 && c1 < Hangul_TCount) {
+					cc += c1;
+					ip++;
+					ustrlen--;
+				}
+				goto done;
+			}
+		}
+		while (1) {
+			/* main loop for common case of not composed chars */
+			if (!ustrlen)
+				goto same;
+			c1 = be16_to_cpu(*ip);
+			if (likely(compose))
+				ce1 = hfsplus_compose_lookup(hfsplus_compose_table, c1);
+			if (ce1)
+				break;
+			switch (c0) {
+			case 0:
+				c0 = 0x2400;
+				break;
+			case '/':
+				c0 = ':';
+				break;
+			}
+			res = nls->uni2char(c0, op, len);
+			if (res < 0) {
+				if (res == -ENAMETOOLONG)
+					goto out;
+				*op = '?';
+				res = 1;
+			}
+			op += res;
+			len -= res;
+			c0 = c1;
+			ip++;
+			ustrlen--;
+		}
+		ce2 = hfsplus_compose_lookup(ce1, c0);
+		if (ce2) {
+			i = 1;
+			while (i < ustrlen) {
+				ce1 = hfsplus_compose_lookup(ce2, be16_to_cpu(ip[i]));
+				if (!ce1)
+					break;
+				i++;
+				ce2 = ce1;
+			}
+			if ((cc = ce2[0])) {
+				ip += i;
+				ustrlen -= i;
+				goto done;
+			}
+		}
+	same:
+		switch (c0) {
+		case 0:
+			cc = 0x2400;
+			break;
+		case '/':
+			cc = ':';
+			break;
+		default:
+			cc = c0;
+		}
+	done:
+		res = nls->uni2char(cc, op, len);
+		if (res < 0) {
+			if (res == -ENAMETOOLONG)
+				goto out;
+			*op = '?';
+			res = 1;
+		}
+		op += res;
+		len -= res;
+	}
+	res = 0;
+out:
+	*len_p = (char *)op - astr;
+	return res;
+}
+
+/*
+ * Convert one or more ASCII characters into a single unicode character.
+ * Returns the number of ASCII characters corresponding to the unicode char.
+ */
+static inline int asc2unichar(struct super_block *sb, const char *astr, int len,
+			      wchar_t *uc)
+{
+	int size = HFSPLUS_SB(sb).nls->char2uni(astr, len, uc);
+	if (size <= 0) {
+		*uc = '?';
+		size = 1;
+	}
+	switch (*uc) {
+	case 0x2400:
+		*uc = 0;
+		break;
+	case ':':
+		*uc = '/';
+		break;
+	}
+	return size;
+}
+
+/* Decomposes a single unicode character. */
+static inline u16 *decompose_unichar(wchar_t uc, int *size)
+{
+	int off;
+
+	off = hfsplus_decompose_table[(uc >> 12) & 0xf];
+	if (off == 0 || off == 0xffff)
+		return NULL;
+
+	off = hfsplus_decompose_table[off + ((uc >> 8) & 0xf)];
+	if (!off)
+		return NULL;
+
+	off = hfsplus_decompose_table[off + ((uc >> 4) & 0xf)];
+	if (!off)
+		return NULL;
+
+	off = hfsplus_decompose_table[off + (uc & 0xf)];
+	*size = off & 3;
+	if (*size == 0)
+		return NULL;
+	return hfsplus_decompose_table + (off / 4);
+}
+
+int hfsplus_asc2uni(struct super_block *sb, struct hfsplus_unistr *ustr,
+		    const char *astr, int len)
+{
+	int size, dsize, decompose;
+	u16 *dstr, outlen = 0;
+	wchar_t c;
+
+	decompose = !(HFSPLUS_SB(sb).flags & HFSPLUS_SB_NODECOMPOSE);
+	while (outlen < HFSPLUS_MAX_STRLEN && len > 0) {
+		size = asc2unichar(sb, astr, len, &c);
+
+		if (decompose && (dstr = decompose_unichar(c, &dsize))) {
+			if (outlen + dsize > HFSPLUS_MAX_STRLEN)
+				break;
+			do {
+				ustr->unicode[outlen++] = cpu_to_be16(*dstr++);
+			} while (--dsize > 0);
+		} else
+			ustr->unicode[outlen++] = cpu_to_be16(c);
+
+		astr += size;
+		len -= size;
+	}
+	ustr->length = cpu_to_be16(outlen);
+	if (len > 0)
+		return -ENAMETOOLONG;
+	return 0;
+}
+
+/*
+ * Hash a string to an integer as appropriate for the HFS+ filesystem.
+ * Composed unicode characters are decomposed and case-folding is performed
+ * if the appropriate bits are (un)set on the superblock.
+ */
+int hfsplus_hash_dentry(struct dentry *dentry, struct qstr *str)
+{
+	struct super_block *sb = dentry->d_sb;
+	const char *astr;
+	const u16 *dstr;
+	int casefold, decompose, size, len;
+	unsigned long hash;
+	wchar_t c;
+	u16 c2;
+
+	casefold = (HFSPLUS_SB(sb).flags & HFSPLUS_SB_CASEFOLD);
+	decompose = !(HFSPLUS_SB(sb).flags & HFSPLUS_SB_NODECOMPOSE);
+	hash = init_name_hash();
+	astr = str->name;
+	len = str->len;
+	while (len > 0) {
+		int uninitialized_var(dsize);
+		size = asc2unichar(sb, astr, len, &c);
+		astr += size;
+		len -= size;
+
+		if (decompose && (dstr = decompose_unichar(c, &dsize))) {
+			do {
+				c2 = *dstr++;
+				if (!casefold || (c2 = case_fold(c2)))
+					hash = partial_name_hash(c2, hash);
+			} while (--dsize > 0);
+		} else {
+			c2 = c;
+			if (!casefold || (c2 = case_fold(c2)))
+				hash = partial_name_hash(c2, hash);
+		}
+	}
+	str->hash = end_name_hash(hash);
+
+	return 0;
+}
+
+/*
+ * Compare strings with HFS+ filename ordering.
+ * Composed unicode characters are decomposed and case-folding is performed
+ * if the appropriate bits are (un)set on the superblock.
+ */
+int hfsplus_compare_dentry(struct dentry *dentry, struct qstr *s1, struct qstr *s2)
+{
+	struct super_block *sb = dentry->d_sb;
+	int casefold, decompose, size;
+	int dsize1, dsize2, len1, len2;
+	const u16 *dstr1, *dstr2;
+	const char *astr1, *astr2;
+	u16 c1, c2;
+	wchar_t c;
+
+	casefold = (HFSPLUS_SB(sb).flags & HFSPLUS_SB_CASEFOLD);
+	decompose = !(HFSPLUS_SB(sb).flags & HFSPLUS_SB_NODECOMPOSE);
+	astr1 = s1->name;
+	len1 = s1->len;
+	astr2 = s2->name;
+	len2 = s2->len;
+	dsize1 = dsize2 = 0;
+	dstr1 = dstr2 = NULL;
+
+	while (len1 > 0 && len2 > 0) {
+		if (!dsize1) {
+			size = asc2unichar(sb, astr1, len1, &c);
+			astr1 += size;
+			len1 -= size;
+
+			if (!decompose || !(dstr1 = decompose_unichar(c, &dsize1))) {
+				c1 = c;
+				dstr1 = &c1;
+				dsize1 = 1;
+			}
+		}
+
+		if (!dsize2) {
+			size = asc2unichar(sb, astr2, len2, &c);
+			astr2 += size;
+			len2 -= size;
+
+			if (!decompose || !(dstr2 = decompose_unichar(c, &dsize2))) {
+				c2 = c;
+				dstr2 = &c2;
+				dsize2 = 1;
+			}
+		}
+
+		c1 = *dstr1;
+		c2 = *dstr2;
+		if (casefold) {
+			if  (!(c1 = case_fold(c1))) {
+				dstr1++;
+				dsize1--;
+				continue;
+			}
+			if (!(c2 = case_fold(c2))) {
+				dstr2++;
+				dsize2--;
+				continue;
+			}
+		}
+		if (c1 < c2)
+			return -1;
+		else if (c1 > c2)
+			return 1;
+
+		dstr1++;
+		dsize1--;
+		dstr2++;
+		dsize2--;
+	}
+
+	if (len1 < len2)
+		return -1;
+	if (len1 > len2)
+		return 1;
+	return 0;
+}
diff -Nur linux-2.6.32-old//fs/hfsplus_journal/wrapper.c linux-2.6.32/fs/hfsplus_journal/wrapper.c
--- linux-2.6.32-old//fs/hfsplus_journal/wrapper.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.32/fs/hfsplus_journal/wrapper.c	2011-11-17 09:00:40.788818402 -0500
@@ -0,0 +1,179 @@
+/*
+ *  linux/fs/hfsplus/wrapper.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handling of HFS wrappers around HFS+ volumes
+ */
+
+#include <linux/fs.h>
+#include <linux/blkdev.h>
+#include <linux/cdrom.h>
+#include <linux/genhd.h>
+#include <asm/unaligned.h>
+
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+struct hfsplus_wd {
+	u32 ablk_size;
+	u16 ablk_start;
+	u16 embed_start;
+	u16 embed_count;
+};
+
+static int hfsplus_read_mdb(void *bufptr, struct hfsplus_wd *wd)
+{
+	u32 extent;
+	u16 attrib;
+	__be16 sig;
+
+	sig = *(__be16 *)(bufptr + HFSP_WRAPOFF_EMBEDSIG);
+	if (sig != cpu_to_be16(HFSPLUS_VOLHEAD_SIG) &&
+	    sig != cpu_to_be16(HFSPLUS_VOLHEAD_SIGX))
+		return 0;
+
+	attrib = be16_to_cpu(*(__be16 *)(bufptr + HFSP_WRAPOFF_ATTRIB));
+	if (!(attrib & HFSP_WRAP_ATTRIB_SLOCK) ||
+	   !(attrib & HFSP_WRAP_ATTRIB_SPARED))
+		return 0;
+
+	wd->ablk_size = be32_to_cpu(*(__be32 *)(bufptr + HFSP_WRAPOFF_ABLKSIZE));
+	if (wd->ablk_size < HFSPLUS_SECTOR_SIZE)
+		return 0;
+	if (wd->ablk_size % HFSPLUS_SECTOR_SIZE)
+		return 0;
+	wd->ablk_start = be16_to_cpu(*(__be16 *)(bufptr + HFSP_WRAPOFF_ABLKSTART));
+
+	extent = get_unaligned_be32(bufptr + HFSP_WRAPOFF_EMBEDEXT);
+	wd->embed_start = (extent >> 16) & 0xFFFF;
+	wd->embed_count = extent & 0xFFFF;
+
+	return 1;
+}
+
+static int hfsplus_get_last_session(struct super_block *sb,
+				    sector_t *start, sector_t *size)
+{
+	struct cdrom_multisession ms_info;
+	struct cdrom_tocentry te;
+	int res;
+
+	/* default values */
+	*start = 0;
+	*size = sb->s_bdev->bd_inode->i_size >> 9;
+
+	if (HFSPLUS_SB(sb).session >= 0) {
+		te.cdte_track = HFSPLUS_SB(sb).session;
+		te.cdte_format = CDROM_LBA;
+		res = ioctl_by_bdev(sb->s_bdev, CDROMREADTOCENTRY, (unsigned long)&te);
+		if (!res && (te.cdte_ctrl & CDROM_DATA_TRACK) == 4) {
+			*start = (sector_t)te.cdte_addr.lba << 2;
+			return 0;
+		}
+		printk(KERN_ERR "hfs: invalid session number or type of track\n");
+		return -EINVAL;
+	}
+	ms_info.addr_format = CDROM_LBA;
+	res = ioctl_by_bdev(sb->s_bdev, CDROMMULTISESSION, (unsigned long)&ms_info);
+	if (!res && ms_info.xa_flag)
+		*start = (sector_t)ms_info.addr.lba << 2;
+	return 0;
+}
+
+/* Find the volume header and fill in some minimum bits in superblock */
+/* Takes in super block, returns true if good data read */
+int hfsplus_read_wrapper(struct super_block *sb)
+{
+	struct buffer_head *bh;
+	struct hfsplus_vh *vhdr;
+	struct hfsplus_wd wd;
+	sector_t part_start, part_size;
+	u32 blocksize;
+
+	blocksize = sb_min_blocksize(sb, HFSPLUS_SECTOR_SIZE);
+	if (!blocksize)
+		return -EINVAL;
+
+	if (hfsplus_get_last_session(sb, &part_start, &part_size))
+		return -EINVAL;
+	while (1) {
+		bh = sb_bread512(sb, part_start + HFSPLUS_VOLHEAD_SECTOR, vhdr);
+		if (!bh)
+			return -EIO;
+
+		if (vhdr->signature == cpu_to_be16(HFSP_WRAP_MAGIC)) {
+			if (!hfsplus_read_mdb(vhdr, &wd))
+				goto error;
+			wd.ablk_size >>= HFSPLUS_SECTOR_SHIFT;
+			part_start += wd.ablk_start + wd.embed_start * wd.ablk_size;
+			part_size = wd.embed_count * wd.ablk_size;
+			brelse(bh);
+			bh = sb_bread512(sb, part_start + HFSPLUS_VOLHEAD_SECTOR, vhdr);
+			if (!bh)
+				return -EIO;
+		}
+		if (vhdr->signature == cpu_to_be16(HFSPLUS_VOLHEAD_SIG))
+			break;
+		if (vhdr->signature == cpu_to_be16(HFSPLUS_VOLHEAD_SIGX)) {
+			HFSPLUS_SB(sb).flags |= HFSPLUS_SB_HFSX;
+			break;
+		}
+		brelse(bh);
+
+		/* check for a partition block
+		 * (should do this only for cdrom/loop though)
+		 */
+		if (hfs_part_find(sb, &part_start, &part_size))
+			return -EINVAL;
+	}
+
+	blocksize = be32_to_cpu(vhdr->blocksize);
+	brelse(bh);
+
+	/* block size must be at least as large as a sector
+	 * and a multiple of 2
+	 */
+	if (blocksize < HFSPLUS_SECTOR_SIZE ||
+	    ((blocksize - 1) & blocksize))
+		return -EINVAL;
+	HFSPLUS_SB(sb).alloc_blksz = blocksize;
+	HFSPLUS_SB(sb).alloc_blksz_shift = 0;
+	while ((blocksize >>= 1) != 0)
+		HFSPLUS_SB(sb).alloc_blksz_shift++;
+	blocksize = min(HFSPLUS_SB(sb).alloc_blksz, (u32)PAGE_SIZE);
+
+	/* align block size to block offset */
+	while (part_start & ((blocksize >> HFSPLUS_SECTOR_SHIFT) - 1))
+		blocksize >>= 1;
+
+	if (sb_set_blocksize(sb, blocksize) != blocksize) {
+		printk(KERN_ERR "hfs: unable to set blocksize to %u!\n", blocksize);
+		return -EINVAL;
+	}
+
+	HFSPLUS_SB(sb).blockoffset = part_start >>
+			(sb->s_blocksize_bits - HFSPLUS_SECTOR_SHIFT);
+	HFSPLUS_SB(sb).sect_count = part_size;
+	HFSPLUS_SB(sb).fs_shift = HFSPLUS_SB(sb).alloc_blksz_shift -
+			sb->s_blocksize_bits;
+
+	bh = sb_bread512(sb, part_start + HFSPLUS_VOLHEAD_SECTOR, vhdr);
+	if (!bh)
+		return -EIO;
+
+	/* should still be the same... */
+	if (vhdr->signature != (HFSPLUS_SB(sb).flags & HFSPLUS_SB_HFSX ?
+				cpu_to_be16(HFSPLUS_VOLHEAD_SIGX) :
+				cpu_to_be16(HFSPLUS_VOLHEAD_SIG)))
+		goto error;
+	HFSPLUS_SB(sb).s_vhbh = bh;
+	HFSPLUS_SB(sb).s_vhdr = vhdr;
+
+	return 0;
+ error:
+	brelse(bh);
+	return -EINVAL;
+}
